---
phase: 01-plugin-shell
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/bindings/src/well-known/site.ts
  - packages/bindings/src/well-known/index.ts
  - packages/mesh-plugin-site-editor/package.json
  - packages/mesh-plugin-site-editor/tsconfig.json
  - packages/mesh-plugin-site-editor/shared.ts
  - packages/mesh-plugin-site-editor/server/index.ts
  - packages/mesh-plugin-site-editor/server/tools/index.ts
  - packages/mesh-plugin-site-editor/client/index.tsx
  - packages/mesh-plugin-site-editor/client/lib/router.ts
  - apps/mesh/src/server-plugins.ts
  - apps/mesh/src/web/plugins.ts
autonomous: true

must_haves:
  truths:
    - "site-editor plugin appears in Mesh admin sidebar when a connection implementing SITE_BINDING exists"
    - "SITE_BINDING is defined as a Binder array in packages/bindings/src/well-known/site.ts with READ_FILE, PUT_FILE, and LIST_FILES tool binders"
    - "ServerPlugin is registered and its tools are accessible via the plugin-loader"
    - "ClientPlugin declares the SITE_BINDING and registers sidebar groups for Pages, Sections, and Loaders"
  artifacts:
    - path: "packages/bindings/src/well-known/site.ts"
      provides: "SITE_BINDING definition as Binder array"
      contains: "SITE_BINDING"
      exports: ["SITE_BINDING", "SiteBinding"]
    - path: "packages/mesh-plugin-site-editor/server/index.ts"
      provides: "ServerPlugin registration"
      exports: ["serverPlugin"]
    - path: "packages/mesh-plugin-site-editor/client/index.tsx"
      provides: "ClientPlugin with SITE_BINDING, sidebar groups, routes"
      exports: ["clientPlugin"]
    - path: "apps/mesh/src/server-plugins.ts"
      provides: "Server plugin registry entry"
      contains: "siteEditorPlugin"
    - path: "apps/mesh/src/web/plugins.ts"
      provides: "Client plugin registry entry"
      contains: "siteEditorPlugin"
  key_links:
    - from: "packages/mesh-plugin-site-editor/client/index.tsx"
      to: "packages/bindings/src/well-known/site.ts"
      via: "import SITE_BINDING for binding property"
      pattern: "import.*SITE_BINDING.*from.*@decocms/bindings"
    - from: "apps/mesh/src/server-plugins.ts"
      to: "packages/mesh-plugin-site-editor/server/index.ts"
      via: "import serverPlugin from mesh-plugin-site-editor/server"
      pattern: "import.*siteEditor.*from.*mesh-plugin-site-editor/server"
    - from: "apps/mesh/src/web/plugins.ts"
      to: "packages/mesh-plugin-site-editor/client/index.tsx"
      via: "import clientPlugin from mesh-plugin-site-editor/client"
      pattern: "import.*siteEditor.*from.*mesh-plugin-site-editor/client"
---

<objective>
Create the mesh-plugin-site-editor package skeleton with SITE_BINDING definition, ServerPlugin, ClientPlugin, and Mesh registration.

Purpose: Establishes the plugin infrastructure so the site-editor appears in Mesh admin with Pages, Sections, and Loaders sidebar items. This is the foundation all subsequent plans build on.

Output: A new `packages/mesh-plugin-site-editor/` package with server and client entry points, SITE_BINDING in `packages/bindings/src/well-known/site.ts`, and registrations in both `apps/mesh/src/server-plugins.ts` and `apps/mesh/src/web/plugins.ts`.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-plugin-shell/01-RESEARCH.md

# Reference files (read these to follow exact patterns):
@packages/bindings/src/well-known/object-storage.ts          # OBJECT_STORAGE_BINDING pattern to mirror
@packages/bindings/src/core/binder.ts                         # Binder, ToolBinder types
@packages/bindings/src/core/server-plugin.ts                  # ServerPlugin interface
@packages/bindings/src/core/plugins.ts                        # ClientPlugin interface
@packages/bindings/src/core/plugin-router.tsx                 # createPluginRouter
@packages/mesh-plugin-object-storage/index.tsx                # ClientPlugin reference (binding, setup, sidebar)
@packages/mesh-plugin-object-storage/lib/router.ts            # Router reference
@packages/mesh-plugin-workflows/server/index.ts               # ServerPlugin reference
@packages/mesh-plugin-workflows/client/index.tsx              # ClientPlugin without binding reference
@apps/mesh/src/server-plugins.ts                              # Server registration
@apps/mesh/src/web/plugins.ts                                 # Client registration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define SITE_BINDING in bindings package and create plugin package skeleton</name>
  <files>
    packages/bindings/src/well-known/site.ts
    packages/bindings/src/well-known/index.ts
    packages/mesh-plugin-site-editor/package.json
    packages/mesh-plugin-site-editor/tsconfig.json
    packages/mesh-plugin-site-editor/shared.ts
  </files>
  <action>
**Step 1: Create SITE_BINDING** in `packages/bindings/src/well-known/site.ts`.

Follow the EXACT pattern of `packages/bindings/src/well-known/object-storage.ts`:
- Import `z` from `"zod"`, `Binder` and `ToolBinder` from `"../core/binder"`
- Define three tool binders: `READ_FILE`, `PUT_FILE`, `LIST_FILES`
- Export `SITE_BINDING` as `const satisfies Binder` and `SiteBinding` type

Schema details:

```typescript
// READ_FILE
const ReadFileInputSchema = z.object({
  path: z.string().describe("File path relative to project root"),
});
const ReadFileOutputSchema = z.object({
  content: z.string().describe("File content as UTF-8 string"),
});

// PUT_FILE
const PutFileInputSchema = z.object({
  path: z.string().describe("File path relative to project root"),
  content: z.string().describe("File content as UTF-8 string"),
});
const PutFileOutputSchema = z.object({
  success: z.boolean().describe("Whether the write succeeded"),
});

// LIST_FILES
const ListFilesInputSchema = z.object({
  prefix: z.string().optional().describe("Path prefix filter (e.g., '.deco/pages/')"),
});
const ListFilesOutputSchema = z.object({
  files: z.array(z.object({
    path: z.string().describe("File path relative to project root"),
    sizeInBytes: z.number().describe("File size"),
    mtime: z.number().describe("Last modified timestamp (epoch ms)"),
  })),
  count: z.number().describe("Total file count"),
});
```

Export types for input/output of each tool. Use `satisfies ToolBinder<"READ_FILE", ...>` for each tool in the array, matching the object-storage pattern exactly.

**Step 2: Update well-known index** -- Add `export * from "./site"` to `packages/bindings/src/well-known/index.ts` if it exists. If no index file, skip.

**Step 3: Create package.json** for `packages/mesh-plugin-site-editor/`:
- Copy structure from `packages/mesh-plugin-workflows/package.json`
- Name: `"mesh-plugin-site-editor"`
- Two entry points: `"./server"` -> `"./server/index.ts"`, `"./client"` -> `"./client/index.tsx"`
- Dependencies: `"@decocms/bindings": "workspace:*"`, `"@decocms/mesh-sdk": "workspace:*"`, `"@deco/ui": "workspace:*"`, `"zod": "^4.0.0"`, `"react": "^19.0.0"`, `"@tanstack/react-router": "^1.139.0"`, `"@tanstack/react-query": "^5.90.0"`, `"nanoid": "^5.1.0"`, `"@untitledui/icons": "^0.0.19"`
- Include both `"exports"` and `"main"` fields

**Step 4: Create tsconfig.json** -- Copy from `packages/mesh-plugin-workflows/tsconfig.json`, adjust paths as needed.

**Step 5: Create shared.ts**:
```typescript
export const PLUGIN_ID = "site-editor";
export const PLUGIN_DESCRIPTION = "CMS for managing site pages, sections, and loaders";
```

IMPORTANT: Do NOT use Zod 4 mini or classic imports -- use plain `import { z } from "zod"` matching the object-storage pattern.
  </action>
  <verify>
    - `packages/bindings/src/well-known/site.ts` exists and exports `SITE_BINDING` and `SiteBinding`
    - `packages/mesh-plugin-site-editor/package.json` exists with correct entry points
    - `packages/mesh-plugin-site-editor/shared.ts` exports PLUGIN_ID and PLUGIN_DESCRIPTION
    - Run: `cd /Users/guilherme/Projects/mesh && cat packages/bindings/src/well-known/site.ts | grep "SITE_BINDING"` shows the export
  </verify>
  <done>SITE_BINDING is defined as a Binder array with READ_FILE, PUT_FILE, LIST_FILES tool binders. Package skeleton exists with correct entry points.</done>
</task>

<task type="auto">
  <name>Task 2: Implement ServerPlugin, ClientPlugin, and register in Mesh</name>
  <files>
    packages/mesh-plugin-site-editor/server/index.ts
    packages/mesh-plugin-site-editor/server/tools/index.ts
    packages/mesh-plugin-site-editor/client/index.tsx
    packages/mesh-plugin-site-editor/client/lib/router.ts
    packages/mesh-plugin-site-editor/client/components/pages-list.tsx
    packages/mesh-plugin-site-editor/client/components/sections-list.tsx
    packages/mesh-plugin-site-editor/client/components/loaders-list.tsx
    packages/mesh-plugin-site-editor/client/components/plugin-header.tsx
    packages/mesh-plugin-site-editor/client/components/plugin-empty-state.tsx
    apps/mesh/src/server-plugins.ts
    apps/mesh/src/web/plugins.ts
  </files>
  <action>
**Step 1: Create ServerPlugin** at `packages/mesh-plugin-site-editor/server/index.ts`:
- Follow `packages/mesh-plugin-workflows/server/index.ts` pattern exactly
- Import `ServerPlugin` from `"@decocms/bindings/server-plugin"`
- Import `PLUGIN_ID`, `PLUGIN_DESCRIPTION` from `"../shared"`
- Import tools from `"./tools/index"`
- Export `serverPlugin: ServerPlugin` with id, description, tools array
- No migrations, events, or storage for Phase 1

**Step 2: Create tools stub** at `packages/mesh-plugin-site-editor/server/tools/index.ts`:
- Export an empty array: `export const tools = [];`
- Add comment: `// Page CRUD tools will be added in plan 01-03`
- This is a placeholder so the server plugin compiles

**Step 3: Create ClientPlugin** at `packages/mesh-plugin-site-editor/client/index.tsx`:
- Follow `packages/mesh-plugin-object-storage/index.tsx` pattern
- Import `Plugin` (or `ClientPlugin`) and `PluginSetupContext` from `"@decocms/bindings/plugins"`
- Import `SITE_BINDING` from `"@decocms/bindings/site"` (the well-known binding path -- check how object-storage imports its binding and follow same pattern)
- Import router from `"./lib/router"`
- Set `binding: SITE_BINDING`
- In `setup()`: call `registerSidebarGroup` with id `"site-editor"`, label `"CMS"`, three items:
  - `{ icon: <FileTextIcon />, label: "Pages" }` -- use @untitledui/icons (check which icons object-storage uses and pick similar ones: `File06`, `LayoutAlt03`, `Database01` or similar)
  - `{ icon: <LayoutIcon />, label: "Sections" }`
  - `{ icon: <DatabaseIcon />, label: "Loaders" }`
  - Set `defaultExpanded: true`
- Call `registerPluginRoutes` with router routes
- Implement `renderHeader` -- simple header showing plugin name (copy pattern from object-storage plugin header)
- Implement `renderEmptyState` -- message saying "Connect a local-fs MCP server to manage your site" (copy pattern from object-storage empty state)

**Step 4: Create router** at `packages/mesh-plugin-site-editor/client/lib/router.ts`:
- Follow `packages/mesh-plugin-object-storage/lib/router.ts` pattern exactly
- Use `createPluginRouter` from `"@decocms/bindings/plugins"`
- Define 4 routes:
  - `/` -> pages-list (default route)
  - `/pages/$pageId` -> page-editor (placeholder for now)
  - `/sections` -> sections-list
  - `/loaders` -> loaders-list
- Use `lazyRouteComponent(() => import("../components/..."))` for each

**Step 5: Create stub page components**:
- `pages-list.tsx`: Render `<div>Pages will appear here</div>` with basic layout. Export as default.
- `sections-list.tsx`: Render `<div>Sections will appear here</div>`. Export as default.
- `loaders-list.tsx`: Render `<div>Loaders will appear here</div>`. Export as default.
- `plugin-header.tsx`: Simple header component (copy object-storage pattern).
- `plugin-empty-state.tsx`: Empty state with connection instructions (copy object-storage pattern).

**Step 6: Register in Mesh**

In `apps/mesh/src/server-plugins.ts`:
```typescript
import { serverPlugin as siteEditorPlugin } from "mesh-plugin-site-editor/server";
// Add to serverPlugins array
```

In `apps/mesh/src/web/plugins.ts`:
```typescript
import { clientPlugin as siteEditorPlugin } from "mesh-plugin-site-editor/client";
// Add to sourcePlugins array
```

IMPORTANT:
- Check the actual import paths used by existing plugins (e.g., does object-storage use `"mesh-plugin-object-storage"` or `"mesh-plugin-object-storage/client"`?)
- Check the actual `Plugin`/`ClientPlugin` type name used in the bindings package and use the correct one
- Match icon imports to what @untitledui/icons actually exports (check existing plugins for icon usage patterns)
- The sidebar item `to` paths must match the router paths (check how object-storage maps sidebar items to routes)
  </action>
  <verify>
    - All files exist in the expected locations
    - `apps/mesh/src/server-plugins.ts` imports and includes siteEditorPlugin
    - `apps/mesh/src/web/plugins.ts` imports and includes siteEditorPlugin
    - `packages/mesh-plugin-site-editor/client/index.tsx` imports SITE_BINDING and declares it as binding
    - `packages/mesh-plugin-site-editor/client/lib/router.ts` defines 4 routes
    - Run: `cd /Users/guilherme/Projects/mesh && grep -r "site-editor" apps/mesh/src/` shows both registrations
  </verify>
  <done>ServerPlugin and ClientPlugin are implemented following existing plugin patterns. Both are registered in Mesh. Sidebar shows Pages, Sections, and Loaders. Stub page components render placeholder content. Plugin appears in Mesh admin when a SITE_BINDING-compatible connection exists.</done>
</task>

</tasks>

<verification>
1. `packages/bindings/src/well-known/site.ts` exports SITE_BINDING as Binder array with READ_FILE, PUT_FILE, LIST_FILES
2. `packages/mesh-plugin-site-editor/` has correct package.json with server and client entry points
3. ServerPlugin exports tools array (empty for now) and is registered in server-plugins.ts
4. ClientPlugin declares SITE_BINDING binding and registers 3 sidebar items (Pages, Sections, Loaders)
5. Router defines routes for /, /pages/$pageId, /sections, /loaders
6. Both server and client plugins are registered in their respective Mesh registries
</verification>

<success_criteria>
- SITE_BINDING exists as a well-known binding with READ_FILE, PUT_FILE, LIST_FILES
- Plugin package compiles with both server/ and client/ entry points
- Plugin appears in Mesh server-plugins.ts and web/plugins.ts
- ClientPlugin has sidebar with Pages, Sections, Loaders items
- All stub components render without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-plugin-shell/01-01-SUMMARY.md`
</output>
