---
phase: 01-plugin-shell
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/mesh-plugin-site-editor/server/tools/index.ts
  - packages/mesh-plugin-site-editor/server/tools/page-list.ts
  - packages/mesh-plugin-site-editor/server/tools/page-get.ts
  - packages/mesh-plugin-site-editor/server/tools/page-create.ts
  - packages/mesh-plugin-site-editor/server/tools/page-update.ts
  - packages/mesh-plugin-site-editor/server/tools/page-delete.ts
  - packages/mesh-plugin-site-editor/client/components/pages-list.tsx
  - packages/mesh-plugin-site-editor/client/components/page-editor.tsx
  - packages/mesh-plugin-site-editor/client/lib/query-keys.ts
autonomous: true

must_haves:
  truths:
    - "User can create a new page and see it listed in the Pages view"
    - "User can open a page, edit its title and path metadata, and save changes"
    - "User can delete a page and it disappears from the list"
    - "Page configs are persisted as JSON in .deco/pages/ via MCP file operations"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/server/tools/page-list.ts"
      provides: "CMS_PAGE_LIST tool calling LIST_FILES via MCP proxy"
      exports: ["PAGE_LIST"]
    - path: "packages/mesh-plugin-site-editor/server/tools/page-get.ts"
      provides: "CMS_PAGE_GET tool calling READ_FILE via MCP proxy"
      exports: ["PAGE_GET"]
    - path: "packages/mesh-plugin-site-editor/server/tools/page-create.ts"
      provides: "CMS_PAGE_CREATE tool calling PUT_FILE via MCP proxy"
      exports: ["PAGE_CREATE"]
    - path: "packages/mesh-plugin-site-editor/server/tools/page-update.ts"
      provides: "CMS_PAGE_UPDATE tool calling READ_FILE + PUT_FILE via MCP proxy"
      exports: ["PAGE_UPDATE"]
    - path: "packages/mesh-plugin-site-editor/server/tools/page-delete.ts"
      provides: "CMS_PAGE_DELETE tool calling PUT_FILE (empty) or DELETE via MCP proxy"
      exports: ["PAGE_DELETE"]
    - path: "packages/mesh-plugin-site-editor/client/components/pages-list.tsx"
      provides: "Pages list UI with create/delete actions"
      exports: ["default"]
    - path: "packages/mesh-plugin-site-editor/client/components/page-editor.tsx"
      provides: "Page metadata editor (title, path)"
      exports: ["default"]
  key_links:
    - from: "packages/mesh-plugin-site-editor/server/tools/page-list.ts"
      to: "MCP connection via ctx.createMCPProxy"
      via: "LIST_FILES tool call with prefix .deco/pages/"
      pattern: "LIST_FILES.*\\.deco/pages"
    - from: "packages/mesh-plugin-site-editor/server/tools/page-create.ts"
      to: "MCP connection via ctx.createMCPProxy"
      via: "PUT_FILE tool call writing JSON to .deco/pages/{id}.json"
      pattern: "PUT_FILE.*\\.deco/pages"
    - from: "packages/mesh-plugin-site-editor/client/components/pages-list.tsx"
      to: "packages/mesh-plugin-site-editor/server/tools/page-list.ts"
      via: "toolCaller from usePluginContext calling CMS_PAGE_LIST"
      pattern: "toolCaller.*CMS_PAGE_LIST"
---

<objective>
Implement the five page CRUD server tools (list, get, create, update, delete) and the Pages UI with create, edit, and delete functionality.

Purpose: Users can manage CMS pages through the Mesh admin -- creating pages, editing their metadata (title, path), and deleting them. All data is stored as JSON files in `.deco/pages/` via MCP file operations, making page configs git-tracked and diffable.

Output: Five server-side MCP tools for page CRUD, a pages list view, and a page metadata editor.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-plugin-shell/01-RESEARCH.md
@.planning/phases/01-plugin-shell/01-01-SUMMARY.md

# Reference files:
@packages/mesh-plugin-workflows/server/tools/workflow-collection.ts  # ServerPluginToolDefinition pattern
@packages/mesh-plugin-object-storage/components/                      # UI component patterns
@packages/mesh-sdk/src/plugins/plugin-context-provider.tsx            # usePluginContext hook
@packages/site-binding-renderer/dist/src/bindings/site.d.ts           # PageSchema reference
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement five page CRUD server tools</name>
  <files>
    packages/mesh-plugin-site-editor/server/tools/page-list.ts
    packages/mesh-plugin-site-editor/server/tools/page-get.ts
    packages/mesh-plugin-site-editor/server/tools/page-create.ts
    packages/mesh-plugin-site-editor/server/tools/page-update.ts
    packages/mesh-plugin-site-editor/server/tools/page-delete.ts
    packages/mesh-plugin-site-editor/server/tools/index.ts
  </files>
  <action>
All tools follow the `ServerPluginToolDefinition` pattern from `packages/mesh-plugin-workflows/server/tools/workflow-collection.ts`. Each tool:
- Has a Zod input schema and output schema
- Takes `connectionId` as a required input
- Uses `ctx.createMCPProxy(connectionId)` to get an MCP proxy
- Calls the proxy's tools (READ_FILE, PUT_FILE, LIST_FILES)
- ALWAYS wraps proxy usage in try/finally with `await proxy.close?.()` to prevent leaks

**Page JSON structure** (stored in `.deco/pages/{id}.json`):
```json
{
  "id": "page_abc123",
  "path": "/",
  "title": "Home",
  "blocks": [],
  "metadata": {
    "description": "",
    "createdAt": "2026-02-14T00:00:00Z",
    "updatedAt": "2026-02-14T00:00:00Z"
  }
}
```

**CMS_PAGE_LIST** (`page-list.ts`):
- Input: `{ connectionId: string }`
- Output: `{ pages: Array<{ id: string, path: string, title: string, updatedAt: string }> }`
- Implementation: Call `LIST_FILES` with prefix `.deco/pages/`. For each `.json` file, call `READ_FILE` to get the page content, parse the JSON, extract id/path/title/updatedAt. Return the array sorted by updatedAt descending.
- NOTE: For large numbers of pages, reading every file is expensive. For Phase 1 this is acceptable. Optimization can come later.

**CMS_PAGE_GET** (`page-get.ts`):
- Input: `{ connectionId: string, pageId: string }`
- Output: `{ page: { id, path, title, blocks, metadata } | null }`
- Implementation: Call `READ_FILE` with path `.deco/pages/${pageId}.json`. Parse JSON. Return page object or null if file doesn't exist (handle error gracefully).

**CMS_PAGE_CREATE** (`page-create.ts`):
- Input: `{ connectionId: string, title: string, path: string }`
- Output: `{ page: { id, path, title, blocks, metadata } }`
- Implementation: Generate a unique ID with `nanoid()` prefixed by `page_` (e.g., `page_V1StGXR8`). Create page JSON with empty blocks array, current timestamp for createdAt/updatedAt. Call `PUT_FILE` with path `.deco/pages/${id}.json` and the JSON stringified content (pretty-printed with 2-space indent).

**CMS_PAGE_UPDATE** (`page-update.ts`):
- Input: `{ connectionId: string, pageId: string, title?: string, path?: string, blocks?: Array<ContentBlock> }`
- Output: `{ page: { id, path, title, blocks, metadata } }`
- Implementation: Call `READ_FILE` to get current page. Merge provided fields (only overwrite fields that are present in input). Update `metadata.updatedAt` to current timestamp. Call `PUT_FILE` to write back. Return updated page.

**CMS_PAGE_DELETE** (`page-delete.ts`):
- Input: `{ connectionId: string, pageId: string }`
- Output: `{ success: boolean }`
- Implementation: The SITE_BINDING doesn't have a DELETE_FILE tool. Two options:
  1. If the MCP server supports a DELETE_FILE tool beyond the binding, use it
  2. Otherwise, write an empty/tombstone file or handle at the application level
  - For Phase 1: Try calling a `DELETE_FILE` tool on the proxy. If it fails, write an empty JSON `{"deleted": true}` as a tombstone. Document this limitation.
  - BETTER: Check if the MCP proxy exposes a generic `callTool` that can call any tool the MCP server supports, not just the binding tools. If so, call `DELETE_FILE` directly even though it's not in the binding.

**Update tools/index.ts** to import and export all 5 tools in an array:
```typescript
import { PAGE_LIST } from "./page-list";
import { PAGE_GET } from "./page-get";
import { PAGE_CREATE } from "./page-create";
import { PAGE_UPDATE } from "./page-update";
import { PAGE_DELETE } from "./page-delete";

export const tools = [PAGE_LIST, PAGE_GET, PAGE_CREATE, PAGE_UPDATE, PAGE_DELETE];
```

IMPORTANT:
- File content over MCP may be base64-encoded. Check what READ_FILE returns in the research and existing deconfig CLI code. If base64, decode with `Buffer.from(content, "base64").toString("utf-8")` for reads and `Buffer.from(json).toString("base64")` for writes. If UTF-8 string, use directly.
- Handle the case where `.deco/pages/` directory doesn't exist yet (LIST_FILES may return empty or error)
- Use `import { nanoid } from "nanoid"` for ID generation
  </action>
  <verify>
    - All 5 tool files exist in `packages/mesh-plugin-site-editor/server/tools/`
    - `tools/index.ts` exports array of 5 tools
    - Each tool has name, description, inputSchema, outputSchema, handler
    - Each handler uses try/finally with proxy.close?.()
    - Page paths follow `.deco/pages/{id}.json` convention
  </verify>
  <done>Five server tools (CMS_PAGE_LIST, CMS_PAGE_GET, CMS_PAGE_CREATE, CMS_PAGE_UPDATE, CMS_PAGE_DELETE) are implemented. Each proxies file operations through the MCP connection. Pages are stored as pretty-printed JSON in .deco/pages/.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Pages list and page editor UI components</name>
  <files>
    packages/mesh-plugin-site-editor/client/components/pages-list.tsx
    packages/mesh-plugin-site-editor/client/components/page-editor.tsx
    packages/mesh-plugin-site-editor/client/lib/query-keys.ts
  </files>
  <action>
**Step 1: Create query keys** at `packages/mesh-plugin-site-editor/client/lib/query-keys.ts`:
```typescript
export const queryKeys = {
  pages: {
    all: ["site-editor", "pages"] as const,
    detail: (pageId: string) => ["site-editor", "pages", pageId] as const,
  },
} as const;
```

**Step 2: Replace pages-list.tsx stub** with full implementation:

Use `usePluginContext` to get `toolCaller` and `connection`. Use `@tanstack/react-query` for data fetching.

```tsx
// Key patterns to follow:
// - useQuery for fetching page list via toolCaller("CMS_PAGE_LIST", { connectionId })
// - useMutation for create/delete with queryClient.invalidateQueries
// - Navigate to /pages/$pageId on row click using the plugin router's navigate

// UI structure:
// - Header: "Pages" title + "New Page" button (top-right)
// - Table/list of pages showing: title, path, last updated
// - Each row clickable -> navigates to page editor
// - Each row has a delete button (with confirmation)
// - Empty state when no pages exist

// "New Page" flow:
// - Click button -> simple dialog/modal with Title and Path inputs
// - On submit: call toolCaller("CMS_PAGE_CREATE", { connectionId, title, path })
// - On success: invalidate pages query, navigate to new page editor
```

Check how the object-storage plugin renders its file list for UI patterns:
- Table component from `@deco/ui` (check if shadcn Table is available)
- Button, Input, Dialog components from `@deco/ui`
- Loading and error states

For navigation, use the router from plan 01-01. Check how `createPluginRouter` provides `useNavigate` or similar. The page editor route is `/pages/$pageId`.

**Step 3: Create page-editor.tsx** (replace stub if it exists):

A form to edit page metadata (title, path). For Phase 1, blocks editing is not needed (that's Phase 3).

```tsx
// Key patterns:
// - useParams to get pageId from route
// - useQuery to fetch page via toolCaller("CMS_PAGE_GET", { connectionId, pageId })
// - Form with title and path fields
// - Save button calls toolCaller("CMS_PAGE_UPDATE", { connectionId, pageId, title, path })
// - Back button/link to return to pages list
// - Show page ID and timestamps in a metadata section

// UI structure:
// - Breadcrumb: Pages > {page title}
// - Form: Title input, Path input
// - Metadata: ID (read-only), Created at, Updated at
// - Actions: Save button, Back to list link
```

Use `@deco/ui` components (Input, Button, Label). Check what's available by looking at imports in existing plugin components.

IMPORTANT:
- The `toolCaller` from `usePluginContext` is the typed tool caller. Check its actual API -- it might be `toolCaller(toolName, args)` or `toolCaller({ name, arguments })`. Read the plugin context provider source to confirm.
- React Query mutations should invalidate the page list query on success
- Handle loading, error, and not-found states
- Page editor form should be controlled (React state) with save on explicit button click (not auto-save for Phase 1)
- All navigation must use the plugin router, not `window.location` or raw tanstack router
  </action>
  <verify>
    - `pages-list.tsx` renders a list of pages fetched via CMS_PAGE_LIST tool
    - `pages-list.tsx` has "New Page" button that creates via CMS_PAGE_CREATE
    - `pages-list.tsx` has delete action per page via CMS_PAGE_DELETE
    - `page-editor.tsx` loads a page via CMS_PAGE_GET and renders an edit form
    - `page-editor.tsx` saves via CMS_PAGE_UPDATE
    - `query-keys.ts` exports structured query keys
    - Components use @deco/ui components for consistent styling
  </verify>
  <done>Pages list view shows all pages with create/delete actions. Page editor allows editing title and path with save functionality. All operations go through server tools via toolCaller. React Query handles caching and invalidation.</done>
</task>

</tasks>

<verification>
1. Creating a page via the UI calls CMS_PAGE_CREATE which writes JSON to `.deco/pages/`
2. Pages list fetches via CMS_PAGE_LIST which reads from `.deco/pages/`
3. Editing a page calls CMS_PAGE_UPDATE which reads then writes to `.deco/pages/`
4. Deleting a page calls CMS_PAGE_DELETE
5. All MCP proxy connections are properly closed after use
6. Page JSON follows the schema: `{ id, path, title, blocks, metadata }`
</verification>

<success_criteria>
- Five server tools exist and implement page CRUD via MCP proxy
- Pages list UI shows pages with create, navigate, and delete functionality
- Page editor UI allows editing title and path
- All file operations flow through MCP connection (no direct filesystem access)
- Page configs stored as JSON in `.deco/pages/{id}.json`
</success_criteria>

<output>
After completion, create `.planning/phases/01-plugin-shell/01-03-SUMMARY.md`
</output>
