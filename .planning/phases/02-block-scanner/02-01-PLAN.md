---
phase: 02-block-scanner
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mesh-plugin-site-editor/server/scanner/types.ts
  - packages/mesh-plugin-site-editor/server/scanner/discover.ts
  - packages/mesh-plugin-site-editor/server/scanner/extract.ts
  - packages/mesh-plugin-site-editor/server/scanner/schema.ts
  - packages/mesh-plugin-site-editor/server/tools/block-scan.ts
  - packages/mesh-plugin-site-editor/server/tools/block-list.ts
  - packages/mesh-plugin-site-editor/server/tools/block-get.ts
  - packages/mesh-plugin-site-editor/server/tools/block-register.ts
  - packages/mesh-plugin-site-editor/server/tools/index.ts
  - packages/mesh-plugin-site-editor/client/lib/block-api.ts
  - packages/mesh-plugin-site-editor/client/lib/query-keys.ts
  - packages/mesh-plugin-site-editor/package.json
autonomous: true

must_haves:
  truths:
    - "Running CMS_BLOCK_SCAN with a connectionId and scan patterns produces block definitions written to .deco/blocks/ as JSON files"
    - "CMS_BLOCK_LIST returns all block definitions from .deco/blocks/ with id, component, label, and prop count"
    - "CMS_BLOCK_GET returns a single block definition including its full JSON Schema"
    - "CMS_BLOCK_REGISTER accepts a manually-written block definition and writes it to .deco/blocks/"
    - "Client block-api helpers can list and get blocks through SITE_BINDING tools"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/server/scanner/types.ts"
      provides: "BlockDefinition interface and scan config types"
      contains: "BlockDefinition"
    - path: "packages/mesh-plugin-site-editor/server/scanner/discover.ts"
      provides: "Component discovery from in-memory ts-morph project"
      contains: "discoverComponents"
    - path: "packages/mesh-plugin-site-editor/server/scanner/extract.ts"
      provides: "In-memory ts-morph project creation from MCP files"
      contains: "createProjectFromMCP"
    - path: "packages/mesh-plugin-site-editor/server/scanner/schema.ts"
      provides: "JSON Schema generation from ts-morph types"
      contains: "generateSchema"
    - path: "packages/mesh-plugin-site-editor/server/tools/block-scan.ts"
      provides: "CMS_BLOCK_SCAN server tool"
      exports: ["BLOCK_SCAN"]
    - path: "packages/mesh-plugin-site-editor/server/tools/block-list.ts"
      provides: "CMS_BLOCK_LIST server tool"
      exports: ["BLOCK_LIST"]
    - path: "packages/mesh-plugin-site-editor/server/tools/block-get.ts"
      provides: "CMS_BLOCK_GET server tool"
      exports: ["BLOCK_GET"]
    - path: "packages/mesh-plugin-site-editor/server/tools/block-register.ts"
      provides: "CMS_BLOCK_REGISTER server tool"
      exports: ["BLOCK_REGISTER"]
    - path: "packages/mesh-plugin-site-editor/client/lib/block-api.ts"
      provides: "Client-side block CRUD using SITE_BINDING tools"
      exports: ["listBlocks", "getBlock"]
  key_links:
    - from: "server/scanner/extract.ts"
      to: "MCP proxy (LIST_FILES, READ_FILE)"
      via: "proxy.callTool for each source file"
      pattern: "proxy\\.callTool.*LIST_FILES|READ_FILE"
    - from: "server/scanner/discover.ts"
      to: "server/scanner/extract.ts"
      via: "receives ts-morph Project, finds component exports"
      pattern: "getExportedDeclarations|getDefaultExportSymbol"
    - from: "server/scanner/schema.ts"
      to: "ts-json-schema-generator"
      via: "createParser + SchemaGenerator from ts.Program"
      pattern: "SchemaGenerator|createParser"
    - from: "server/tools/block-scan.ts"
      to: "server/scanner/*"
      via: "imports and orchestrates discover + extract + schema pipeline"
      pattern: "createProjectFromMCP.*discoverComponents.*generateSchema"
    - from: "client/lib/block-api.ts"
      to: "SITE_BINDING tools"
      via: "toolCaller for LIST_FILES + READ_FILE on .deco/blocks/"
      pattern: "toolCaller.*LIST_FILES|READ_FILE.*\\.deco/blocks/"
---

<objective>
Build the ts-morph scanner pipeline that reads TypeScript source files through MCP, discovers React components, generates JSON Schema for their props, and writes block definitions to `.deco/blocks/`. Also create the four block server tools (scan, list, get, register) and client-side block API helpers.

Purpose: This is the data backbone of Phase 2 -- all block operations (automated scanning, manual registration, listing, fetching) flow through these tools and helpers. The UI (plan 02-02) consumes these.
Output: Scanner pipeline in `server/scanner/`, four server tools in `server/tools/block-*.ts`, client `block-api.ts`
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-block-scanner/02-RESEARCH.md
@.planning/phases/01-plugin-shell/01-01-SUMMARY.md
@.planning/phases/01-plugin-shell/01-03-SUMMARY.md

# Key reference files
@packages/mesh-plugin-site-editor/server/tools/page-list.ts  (pattern for server tool with MCP proxy)
@packages/mesh-plugin-site-editor/server/tools/index.ts  (tool registry to extend)
@packages/mesh-plugin-site-editor/client/lib/page-api.ts  (pattern for client API with SITE_BINDING)
@packages/mesh-plugin-site-editor/client/lib/query-keys.ts  (extend with block keys)
@packages/mesh-plugin-site-editor/package.json  (add ts-morph dependency)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scanner pipeline -- types, extract, discover, schema</name>
  <files>
    packages/mesh-plugin-site-editor/server/scanner/types.ts
    packages/mesh-plugin-site-editor/server/scanner/extract.ts
    packages/mesh-plugin-site-editor/server/scanner/discover.ts
    packages/mesh-plugin-site-editor/server/scanner/schema.ts
    packages/mesh-plugin-site-editor/package.json
  </files>
  <action>
    **First**, add `ts-morph` as a dependency in `packages/mesh-plugin-site-editor/package.json`:
    ```
    "ts-morph": "^27.0.2"
    ```
    ts-json-schema-generator is already in the Mesh monorepo (used by packages/runtime). Add it as a dependency too if not already present. Run `bun install` in the monorepo root.

    **Create `server/scanner/types.ts`:**
    Define the core types used throughout the scanner pipeline:
    ```typescript
    interface BlockDefinition {
      id: string;              // e.g., "sections--Hero" (component path with / replaced by --)
      component: string;       // e.g., "sections/Hero.tsx"
      label: string;           // Human-readable: derived from component name ("Hero" -> "Hero")
      category: string;        // Derived from directory name ("sections" -> "Sections")
      description: string;     // From JSDoc comment on the component, or empty string
      schema: JSONSchema7;     // Props JSON Schema from ts-json-schema-generator
      defaults: Record<string, unknown>; // Empty object initially
      metadata: {
        scannedAt: string;     // ISO timestamp
        scanMethod: "ts-morph" | "manual" | "ai-agent";
        propsTypeName: string | null; // Original TypeScript type name
        customized: string[];  // Fields manually edited by user (for merge strategy)
      };
    }

    interface ComponentInfo {
      name: string;
      filePath: string;
      propsTypeName: string | null;
      jsDocDescription: string;
    }

    interface ScanResult {
      blocks: BlockSummary[];
      errors: string[];
    }

    interface BlockSummary {
      id: string;
      component: string;
      label: string;
      propsCount: number;
    }
    ```
    Use `JSONSchema7` type from a type import (declare it locally or import from ts-json-schema-generator types). Export all types.

    **Create `server/scanner/extract.ts`:**
    The `createProjectFromMCP` function that reads source files via MCP proxy and builds an in-memory ts-morph Project.

    Key implementation details:
    - `useInMemoryFileSystem: true` on the ts-morph Project
    - CompilerOptions: `target: ES2020`, `jsx: ReactJSX`, `module: ESNext`, `moduleResolution: Bundler`, `strict: true`, `skipLibCheck: true`, `skipDefaultLibCheck: true`
    - Takes an MCP proxy object and an array of directory prefixes (e.g., `["sections/", "components/"]`)
    - For each prefix, calls `LIST_FILES` to get file paths, then `READ_FILE` for each `.ts`/`.tsx` file
    - Creates source files in the project with `project.createSourceFile(path, content)`
    - Returns the populated `Project`
    - Handle errors per-file gracefully (log and skip unreadable files)
    - The proxy interface should match what page-list.ts uses: `proxy.callTool({ name, arguments })` returning `{ content: [{ text }] }`

    **Create `server/scanner/discover.ts`:**
    The `discoverComponents` function that finds exported React components in the ts-morph Project.

    Key implementation details:
    - Iterate `project.getSourceFiles()` filtered to `.tsx` files only
    - For each file, check for default export via `sourceFile.getDefaultExportSymbol()`
    - For default exports that are function declarations: get the first parameter's type (the props type)
    - For default exports that are arrow functions (variable declarations with arrow initializer): same approach
    - Also check named exports: look for exported functions whose return type text includes `JSX.Element`, `ReactNode`, `ReactElement`, or `React.FC`/`React.FunctionComponent` in the type declaration
    - For each discovered component, extract:
      - `name`: function name or file basename without extension
      - `filePath`: the source file path
      - `propsTypeName`: `propsType.getSymbol()?.getName()` or `propsType.getAliasSymbol()?.getName()` or null
      - `jsDocDescription`: from JSDoc `@description` tag or the first JSDoc comment block
    - Return `ComponentInfo[]`
    - Skip components with zero props parameters (they have no editable props)

    **Create `server/scanner/schema.ts`:**
    The `generateSchema` function that converts a TypeScript type to JSON Schema.

    Key implementation details:
    - Import `createParser`, `createFormatter`, `SchemaGenerator` from `ts-json-schema-generator`
    - Accept the ts-morph `Project`, a type name string, and a file path
    - Get the raw `ts.Program` via `project.getProgram().compilerObject`
    - Create a `Config` with: `path: filePath`, `type: typeName`, `expose: "none"`, `jsDoc: "extended"`, `skipTypeCheck: true`, `topRef: false`, `additionalProperties: false`
    - Create parser, formatter, generator and call `generator.createSchema(typeName)`
    - **CRITICAL**: Wrap in try/catch. If schema generation fails (complex types, conditional types, etc.), return a fallback permissive schema: `{ type: "object", additionalProperties: true, description: "Schema could not be auto-generated" }` and log the error as a warning
    - Post-process the schema: if it has `$defs` or `definitions`, inline them (resolve `$ref` pointers) so @rjsf can render without issues. A simple recursive `$ref` inliner is sufficient.
    - Return `JSONSchema7`

    **IMPORTANT**: If `ts-json-schema-generator`'s `createParser` does not accept a `ts.Program` from the in-memory file system correctly (the research flagged this as an open question), fall back to creating a separate program via ts-json-schema-generator's own `createProgram` with the source file contents. The key is: try the integration, handle the failure, don't let it block the pipeline.
  </action>
  <verify>
    - `bun install` completes without errors in monorepo root
    - `bun run check` (tsc --noEmit) in mesh-plugin-site-editor passes or only shows pre-existing errors
    - All four scanner files export the expected functions/types
    - `import { BlockDefinition } from "./scanner/types"` resolves
  </verify>
  <done>
    Scanner pipeline exists with four modules: types.ts exports BlockDefinition/ComponentInfo/ScanResult, extract.ts exports createProjectFromMCP, discover.ts exports discoverComponents, schema.ts exports generateSchema. ts-morph is installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Block server tools and client API helpers</name>
  <files>
    packages/mesh-plugin-site-editor/server/tools/block-scan.ts
    packages/mesh-plugin-site-editor/server/tools/block-list.ts
    packages/mesh-plugin-site-editor/server/tools/block-get.ts
    packages/mesh-plugin-site-editor/server/tools/block-register.ts
    packages/mesh-plugin-site-editor/server/tools/index.ts
    packages/mesh-plugin-site-editor/client/lib/block-api.ts
    packages/mesh-plugin-site-editor/client/lib/query-keys.ts
  </files>
  <action>
    **Create `server/tools/block-scan.ts` (CMS_BLOCK_SCAN):**
    Follow the exact same pattern as `page-list.ts` for the server tool structure.
    - Input: `{ connectionId: string, patterns?: string[] }` (default patterns: `["sections/", "components/"]`)
    - Output: `{ blocks: BlockSummary[], errors: string[] }`
    - Handler:
      1. Create MCP proxy via `ctx.createMCPProxy(connectionId)`
      2. Call `createProjectFromMCP(proxy, patterns)` to build in-memory project
      3. Call `discoverComponents(project)` to find components
      4. For each component with a `propsTypeName`, call `generateSchema(project, propsTypeName, filePath)`
      5. Build a `BlockDefinition` for each:
         - `id`: component path with `/` replaced by `--` and extension stripped (e.g., `sections/Hero.tsx` -> `sections--Hero`)
         - `label`: component name with spaces added before capitals ("HeroBanner" -> "Hero Banner")
         - `category`: capitalize the first directory segment ("sections" -> "Sections")
         - `schema`: the generated JSON Schema
         - `defaults`: `{}`
         - `metadata.scanMethod`: `"ts-morph"`
         - `metadata.scannedAt`: `new Date().toISOString()`
      6. For each block, check if `.deco/blocks/{id}.json` already exists via `READ_FILE`. If it exists and has `metadata.customized` fields, preserve those fields (label, description, category, defaults) during merge. Otherwise overwrite.
      7. Write each block definition to `.deco/blocks/{id}.json` via `PUT_FILE` with pretty-printed JSON
      8. Return the list of blocks and any errors encountered
    - Always close proxy in `finally` block

    **Create `server/tools/block-list.ts` (CMS_BLOCK_LIST):**
    Same pattern as `page-list.ts`.
    - Input: `{ connectionId: string }`
    - Output: `{ blocks: Array<{ id, component, label, category, propsCount }> }`
    - Handler: LIST_FILES on `.deco/blocks/`, READ_FILE each `.json`, skip tombstoned, return summaries
    - `propsCount`: count `Object.keys(schema.properties ?? {}).length`

    **Create `server/tools/block-get.ts` (CMS_BLOCK_GET):**
    Same pattern as `page-get.ts`.
    - Input: `{ connectionId: string, blockId: string }`
    - Output: the full `BlockDefinition` (including schema)
    - Handler: READ_FILE `.deco/blocks/{blockId}.json`, parse and return

    **Create `server/tools/block-register.ts` (CMS_BLOCK_REGISTER):**
    Manual block registration fallback.
    - Input: `{ connectionId: string, block: { component: string, label: string, category?: string, description?: string, schema: object, defaults?: object } }`
    - Output: `{ block: BlockSummary }`
    - Handler:
      1. Generate `id` from component path (same logic as scan)
      2. Build full `BlockDefinition` with `metadata.scanMethod: "manual"`
      3. Write to `.deco/blocks/{id}.json` via PUT_FILE
      4. Return summary

    **Update `server/tools/index.ts`:**
    Add the four new tools to the exported `tools` array alongside the existing page tools.

    **Create `client/lib/block-api.ts`:**
    Follow the exact pattern of `page-api.ts` (uses SITE_BINDING `TypedToolCaller`).
    - `listBlocks(toolCaller)`: LIST_FILES on `.deco/blocks/`, READ_FILE each, return `BlockSummary[]` sorted by label
    - `getBlock(toolCaller, blockId)`: READ_FILE `.deco/blocks/{blockId}.json`, parse and return full `BlockDefinition` or null
    - Export the `BlockDefinition` and `BlockSummary` types (re-export from scanner/types or define compatible client-side versions)

    **Update `client/lib/query-keys.ts`:**
    Add block-related query keys following the existing pattern:
    - `blockKeys.all` - all block queries
    - `blockKeys.list(connectionId)` - block list
    - `blockKeys.detail(connectionId, blockId)` - single block
  </action>
  <verify>
    - `bun run check` passes in the plugin package
    - `server/tools/index.ts` exports an array containing all 9 tools (5 page + 4 block)
    - `client/lib/block-api.ts` exports `listBlocks` and `getBlock`
    - `client/lib/query-keys.ts` exports `blockKeys`
  </verify>
  <done>
    Four block server tools (CMS_BLOCK_SCAN, CMS_BLOCK_LIST, CMS_BLOCK_GET, CMS_BLOCK_REGISTER) registered in the tool index. Client block-api provides listBlocks and getBlock through SITE_BINDING. Query keys include block cache keys. The scanner is fully wired: scan tool orchestrates extract -> discover -> schema -> write pipeline.
  </done>
</task>

</tasks>

<verification>
1. The server tools index exports 9 tools (5 page + 4 block)
2. `BlockDefinition` type includes id, component, label, category, description, schema, defaults, metadata
3. Scanner pipeline: extract.ts creates in-memory ts-morph project from MCP files, discover.ts finds components, schema.ts generates JSON Schema
4. Client block-api follows the same SITE_BINDING toolCaller pattern as page-api
5. Block definitions are stored as JSON in `.deco/blocks/{id}.json`
6. Manual registration (BLOCK_REGISTER) works independently of the ts-morph scanner
</verification>

<success_criteria>
- ts-morph and ts-json-schema-generator are available as dependencies
- CMS_BLOCK_SCAN tool can read source files via MCP, discover components, generate schemas, and write block definitions
- CMS_BLOCK_LIST and CMS_BLOCK_GET can read block definitions from .deco/blocks/
- CMS_BLOCK_REGISTER can create block definitions without running the scanner
- Client can list and fetch blocks through SITE_BINDING tools
</success_criteria>

<output>
After completion, create `.planning/phases/02-block-scanner/02-01-SUMMARY.md`
</output>
