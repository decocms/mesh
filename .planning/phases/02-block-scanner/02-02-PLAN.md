---
phase: 02-block-scanner
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/mesh-plugin-site-editor/client/components/sections-list.tsx
  - packages/mesh-plugin-site-editor/client/components/block-detail.tsx
  - packages/mesh-plugin-site-editor/client/components/prop-editor.tsx
  - packages/mesh-plugin-site-editor/client/components/rjsf/templates.tsx
  - packages/mesh-plugin-site-editor/client/components/rjsf/widgets.tsx
  - packages/mesh-plugin-site-editor/client/lib/router.ts
autonomous: true

must_haves:
  truths:
    - "User sees a list of scanned blocks in the Sections sidebar view with name, category, and prop count"
    - "Clicking a block in the list opens its detail view showing an editable @rjsf form for its props"
    - "The @rjsf form renders all JSON Schema property types: strings, numbers, booleans, objects, arrays"
    - "Changing form values updates the formData state (no save to disk yet -- that is Phase 3 visual editing)"
    - "If no blocks exist, the sections list shows an empty state prompting the user to scan or register blocks"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/components/sections-list.tsx"
      provides: "Block list view with scan trigger and block navigation"
      contains: "listBlocks"
    - path: "packages/mesh-plugin-site-editor/client/components/block-detail.tsx"
      provides: "Block detail view with schema info and prop editor"
      contains: "PropEditor"
    - path: "packages/mesh-plugin-site-editor/client/components/prop-editor.tsx"
      provides: "@rjsf Form wrapper for block prop editing"
      contains: "Form.*schema.*formData.*onChange"
    - path: "packages/mesh-plugin-site-editor/client/components/rjsf/templates.tsx"
      provides: "Custom RJSF FieldTemplate, ObjectFieldTemplate, ArrayFieldTemplate"
      exports: ["customTemplates"]
    - path: "packages/mesh-plugin-site-editor/client/components/rjsf/widgets.tsx"
      provides: "Custom RJSF TextWidget, NumberWidget, CheckboxWidget, SelectWidget"
      exports: ["customWidgets"]
    - path: "packages/mesh-plugin-site-editor/client/lib/router.ts"
      provides: "Updated router with /sections/$blockId route"
      contains: "blockDetailRoute"
  key_links:
    - from: "client/components/sections-list.tsx"
      to: "client/lib/block-api.ts"
      via: "useQuery calling listBlocks"
      pattern: "useQuery.*listBlocks"
    - from: "client/components/block-detail.tsx"
      to: "client/lib/block-api.ts"
      via: "useQuery calling getBlock"
      pattern: "useQuery.*getBlock"
    - from: "client/components/block-detail.tsx"
      to: "client/components/prop-editor.tsx"
      via: "renders PropEditor with block.schema and formData"
      pattern: "PropEditor.*schema.*formData"
    - from: "client/components/prop-editor.tsx"
      to: "@rjsf/core Form"
      via: "renders Form with custom templates and widgets"
      pattern: "Form.*validator.*customTemplates.*customWidgets"
    - from: "client/lib/router.ts"
      to: "client/components/block-detail.tsx"
      via: "blockDetailRoute loads block-detail component"
      pattern: "createRoute.*sections/\\$blockId.*block-detail"
---

<objective>
Build the block list UI (replacing the sections-list stub), block detail view with @rjsf property editor forms, and custom RJSF templates/widgets adapted from the existing workflow form pattern. The user can browse scanned blocks and see auto-generated editable forms for each component's props.

Purpose: This makes the scanner output visible and interactive -- the user can see what was discovered and preview how each component's props will be edited. This is the UI half of Phase 2 that consumes the data pipeline from plan 02-01.
Output: Sections list with block data, block detail page, @rjsf prop editor with CMS-specific templates/widgets
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-block-scanner/02-RESEARCH.md
@.planning/phases/02-block-scanner/02-01-SUMMARY.md

# Key reference files
@packages/mesh-plugin-site-editor/client/components/sections-list.tsx  (stub to replace)
@packages/mesh-plugin-site-editor/client/components/pages-list.tsx  (pattern for list component with React Query)
@packages/mesh-plugin-site-editor/client/components/page-editor.tsx  (pattern for detail/editor view)
@packages/mesh-plugin-site-editor/client/lib/router.ts  (add block detail route)
@packages/mesh-plugin-site-editor/client/lib/block-api.ts  (from plan 02-01)
@packages/mesh-plugin-site-editor/client/lib/query-keys.ts  (from plan 02-01)

# @rjsf reference (existing Mesh patterns)
@apps/mesh/src/web/components/details/workflow/components/tool-selection/components/tool-input.tsx
@apps/mesh/src/web/components/details/workflow/components/tool-selection/rjsf/rjsf-templates.tsx
@apps/mesh/src/web/components/details/workflow/components/tool-selection/rjsf/rjsf-widgets.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: RJSF templates, widgets, and PropEditor component</name>
  <files>
    packages/mesh-plugin-site-editor/client/components/rjsf/templates.tsx
    packages/mesh-plugin-site-editor/client/components/rjsf/widgets.tsx
    packages/mesh-plugin-site-editor/client/components/prop-editor.tsx
  </files>
  <action>
    **Create `client/components/rjsf/templates.tsx`:**
    Adapt from the existing workflow RJSF templates at `apps/mesh/src/web/components/details/workflow/components/tool-selection/rjsf/rjsf-templates.tsx`. The CMS version should be simpler (no mentions context, no workflow-specific features).

    Implement three custom templates:
    - **CustomFieldTemplate**: Wraps each field with label, required indicator, description, and a type icon. Use icons from `lucide-react` (Type for string, Hash for number, CheckSquare for boolean, Braces for array, Box for object). For root id, render children only (no label wrapper). Show JSDoc-derived descriptions from the schema `description` field.
    - **CustomObjectFieldTemplate**: Renders nested objects with a subtle left border indent (`border-l-2 border-muted pl-3`). Shows object title if present. Maps over `properties` and renders each.
    - **CustomArrayFieldTemplate**: Renders array items with add/remove buttons. Each item gets a remove button (X icon). Add button at the bottom. Use `@deco/ui` Button component. Handle `canAdd` and items' `hasRemove` props.

    Export as `customTemplates` object matching `TemplatesType` from `@rjsf/utils`:
    ```typescript
    export const customTemplates: Partial<TemplatesType> = {
      FieldTemplate: CustomFieldTemplate,
      ObjectFieldTemplate: CustomObjectFieldTemplate,
      ArrayFieldTemplate: CustomArrayFieldTemplate,
    };
    ```

    **Create `client/components/rjsf/widgets.tsx`:**
    Adapt from the existing workflow RJSF widgets at `apps/mesh/src/web/components/details/workflow/components/tool-selection/rjsf/rjsf-widgets.tsx`. Use `@deco/ui` components (Input, Textarea, Checkbox, Select).

    Implement four custom widgets:
    - **TextWidget**: Uses `@deco/ui` Input. If schema has `format: "uri"`, adds URL-specific input type. If schema has `ui:widget: "textarea"` or description mentions multiline, use Textarea. Handle `onChange` via `props.onChange(value || undefined)`.
    - **NumberWidget**: Uses `@deco/ui` Input with `type="number"`. Handles `min`/`max` from schema.
    - **CheckboxWidget**: Uses `@deco/ui` Checkbox with label.
    - **SelectWidget**: Uses `@deco/ui` Select for enum values. Maps `schema.enum` or `schema.oneOf` to select options.

    Export as `customWidgets` object matching `RegistryWidgetsType` from `@rjsf/utils`:
    ```typescript
    export const customWidgets: RegistryWidgetsType = {
      TextWidget: CustomTextWidget,
      NumberWidget: CustomNumberWidget,
      CheckboxWidget: CustomCheckboxWidget,
      SelectWidget: CustomSelectWidget,
    };
    ```

    **Create `client/components/prop-editor.tsx`:**
    The main form wrapper component. Follow the ToolInput pattern exactly:
    ```tsx
    import Form from "@rjsf/core";
    import type { RJSFSchema } from "@rjsf/utils";
    import validator from "@rjsf/validator-ajv8";
    import { customTemplates } from "./rjsf/templates";
    import { customWidgets } from "./rjsf/widgets";

    interface PropEditorProps {
      schema: RJSFSchema;
      formData: Record<string, unknown>;
      onChange: (data: Record<string, unknown>) => void;
      readonly?: boolean;
    }

    export function PropEditor({ schema, formData, onChange, readonly }: PropEditorProps) {
      return (
        <Form
          schema={schema}
          formData={formData}
          onChange={(data) => onChange(data.formData ?? {})}
          validator={validator}
          widgets={customWidgets}
          templates={customTemplates}
          readonly={readonly}
          uiSchema={{ "ui:submitButtonOptions": { norender: true } }}
          liveValidate={false}
          className="rjsf-form"
          omitExtraData
          liveOmit
        >
          <></>
        </Form>
      );
    }
    ```

    **IMPORTANT**: The @rjsf packages are already in the Mesh monorepo. Check that `@rjsf/core`, `@rjsf/utils`, and `@rjsf/validator-ajv8` are accessible as peer deps or add them to the plugin's package.json if needed. Reference how `apps/mesh` imports them.
  </action>
  <verify>
    - `bun run check` passes (no type errors in the three new files)
    - `customTemplates` exports FieldTemplate, ObjectFieldTemplate, ArrayFieldTemplate
    - `customWidgets` exports TextWidget, NumberWidget, CheckboxWidget, SelectWidget
    - PropEditor component accepts schema, formData, onChange props
  </verify>
  <done>
    RJSF templates, widgets, and PropEditor wrapper component exist and type-check. The PropEditor renders any JSON Schema as an editable form using @rjsf/core with custom CMS-styled templates and widgets.
  </done>
</task>

<task type="auto">
  <name>Task 2: Sections list (block browser), block detail view, and routing</name>
  <files>
    packages/mesh-plugin-site-editor/client/components/sections-list.tsx
    packages/mesh-plugin-site-editor/client/components/block-detail.tsx
    packages/mesh-plugin-site-editor/client/lib/router.ts
  </files>
  <action>
    **Replace `client/components/sections-list.tsx`:**
    Replace the stub with a full block list view. Follow the `pages-list.tsx` pattern for data fetching and UI structure.

    Implementation:
    - Use `useQuery` with `blockKeys.list(connectionId)` to fetch blocks via `listBlocks(toolCaller)`
    - Get `toolCaller` and `connectionId` from `usePluginContext()` (same pattern as pages-list)
    - **Loading state**: Show skeleton/spinner while loading
    - **Empty state**: Show a message "No blocks found" with a description explaining the user can scan their codebase. Include a "Scan Codebase" button that is a placeholder for now (logs to console or shows a toast -- the actual scan trigger will come when Phase 3 wires up the AI agent or the user runs the scan tool manually)
    - **Block list**: Render blocks grouped by category. Each block shows:
      - Block label (e.g., "Hero Banner")
      - Component path in muted text (e.g., "sections/Hero.tsx")
      - Prop count badge (e.g., "5 props")
      - Click navigates to `/sections/{blockId}` using the plugin router
    - Sort blocks alphabetically within each category group
    - Use standard Mesh UI patterns: `@deco/ui` components for layout

    **Create `client/components/block-detail.tsx`:**
    Block detail view showing metadata and the prop editor form. Follow the `page-editor.tsx` pattern.

    Implementation:
    - Extract `blockId` from route params via `useParams()` (from `@tanstack/react-router`)
    - Use `useQuery` with `blockKeys.detail(connectionId, blockId)` to fetch the full block via `getBlock(toolCaller, blockId)`
    - **Header**: Back button to `/sections`, block label as title, component path as subtitle
    - **Metadata section**: Show scan method (badge: "ts-morph", "manual", or "ai-agent"), scanned timestamp, props type name
    - **Schema section**: Show a collapsible raw JSON Schema view (for debugging). Use `<pre>` with `JSON.stringify(block.schema, null, 2)`
    - **Props editor section**: Render `<PropEditor schema={block.schema} formData={formData} onChange={setFormData} />` where `formData` is local state initialized from `block.defaults`
    - Use `useState` for `formData` (local state only -- Phase 3 will wire saves to page block instances)
    - Use ref-based sync pattern (NOT useEffect) to initialize formData when block data loads, following the page-editor pattern from 01-03

    **Update `client/lib/router.ts`:**
    Add a new route for the block detail view:
    ```typescript
    const blockDetailRoute = createRoute({
      getParentRoute: () => ctx.parentRoute,
      path: "/sections/$blockId",
      component: lazyRouteComponent(() => import("../components/block-detail")),
    });
    ```
    Add `blockDetailRoute` to the returned routes array. Keep all existing routes unchanged.
  </action>
  <verify>
    - `bun run check` passes
    - Router exports 5 routes (4 existing + 1 new blockDetailRoute)
    - sections-list.tsx imports and uses `listBlocks` from block-api
    - block-detail.tsx imports and renders `PropEditor` with the block's schema
    - Navigating to `/sections` shows the block list (or empty state)
    - Navigating to `/sections/{blockId}` shows block detail with prop editor form
  </verify>
  <done>
    Sections sidebar view shows scanned blocks grouped by category. Clicking a block navigates to its detail page which displays metadata and an auto-generated @rjsf prop editor form. The form renders all JSON Schema types and maintains local state. Empty state prompts scanning when no blocks exist.
  </done>
</task>

</tasks>

<verification>
1. Sections list replaces the stub with real block data from .deco/blocks/
2. Block detail page shows metadata and renders @rjsf prop editor form
3. PropEditor uses custom templates (FieldTemplate, ObjectFieldTemplate, ArrayFieldTemplate) and custom widgets (Text, Number, Checkbox, Select)
4. Router includes /sections/$blockId route for block detail
5. Forms handle all basic JSON Schema types: string, number, boolean, object, array, enum
6. Empty state shows when no blocks are found
</verification>

<success_criteria>
- Sections view shows blocks with name, component path, category grouping, and prop count
- Clicking a block opens a detail view with an auto-generated form from its JSON Schema
- Form fields are styled with CMS-appropriate templates matching the Mesh design system
- Changing form values updates local state (visible in React DevTools or console)
- Empty state is handled gracefully with guidance for the user
</success_criteria>

<output>
After completion, create `.planning/phases/02-block-scanner/02-02-SUMMARY.md`
</output>
