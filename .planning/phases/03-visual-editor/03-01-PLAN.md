---
phase: 03-visual-editor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mesh-plugin-site-editor/client/lib/editor-protocol.ts
  - packages/mesh-plugin-site-editor/client/lib/use-editor-messages.ts
  - packages/mesh-plugin-site-editor/client/lib/page-api.ts
  - packages/mesh-plugin-site-editor/client/components/page-composer.tsx
  - packages/mesh-plugin-site-editor/client/components/viewport-toggle.tsx
  - packages/mesh-plugin-site-editor/client/components/preview-panel.tsx

autonomous: true

must_haves:
  truths:
    - "Editor sends typed postMessage to iframe and receives typed responses"
    - "Page data uses BlockInstance[] with id, blockType, and props instead of unknown[]"
    - "Preview panel waits for deco:ready handshake before sending page config"
    - "Viewport toggle switches iframe between 375px, 768px, and 1440px widths"
    - "Three-panel composer layout renders section list (left), preview (center), prop editor (right)"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/lib/editor-protocol.ts"
      provides: "Typed EditorMessage and SiteMessage discriminated unions"
      contains: "type EditorMessage"
    - path: "packages/mesh-plugin-site-editor/client/lib/use-editor-messages.ts"
      provides: "useEditorMessages hook with send/subscribe"
      exports: ["useEditorMessages"]
    - path: "packages/mesh-plugin-site-editor/client/lib/page-api.ts"
      provides: "BlockInstance interface replacing blocks: unknown[]"
      contains: "interface BlockInstance"
    - path: "packages/mesh-plugin-site-editor/client/components/page-composer.tsx"
      provides: "Three-panel visual editor layout"
      exports: ["PageComposer"]
    - path: "packages/mesh-plugin-site-editor/client/components/viewport-toggle.tsx"
      provides: "Mobile/tablet/desktop viewport buttons"
      exports: ["ViewportToggle", "VIEWPORTS"]
    - path: "packages/mesh-plugin-site-editor/client/components/preview-panel.tsx"
      provides: "Enhanced iframe with postMessage + viewport width"
      contains: "useEditorMessages"
  key_links:
    - from: "preview-panel.tsx"
      to: "use-editor-messages.ts"
      via: "useEditorMessages hook call"
      pattern: "useEditorMessages\\(iframeRef\\)"
    - from: "preview-panel.tsx"
      to: "editor-protocol.ts"
      via: "sends EditorMessage, receives SiteMessage"
      pattern: "deco:page-config|deco:ready"
    - from: "page-composer.tsx"
      to: "preview-panel.tsx"
      via: "renders PreviewPanel with page, viewport, selectedBlockId props"
      pattern: "<PreviewPanel"
---

<objective>
Build the postMessage protocol, BlockInstance type, three-panel composer layout, viewport toggle, and enhanced preview panel with ready handshake.

Purpose: Establishes the communication foundation between the Mesh editor and the site iframe, plus the visual editor's three-panel layout that all subsequent plans build upon.
Output: editor-protocol.ts, use-editor-messages.ts, updated page-api.ts, page-composer.tsx, viewport-toggle.tsx, enhanced preview-panel.tsx
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-visual-editor/03-RESEARCH.md

@packages/mesh-plugin-site-editor/client/lib/page-api.ts
@packages/mesh-plugin-site-editor/client/lib/use-tunnel-url.ts
@packages/mesh-plugin-site-editor/client/components/preview-panel.tsx
@packages/mesh-plugin-site-editor/client/components/page-editor.tsx
@packages/mesh-plugin-site-editor/client/lib/router.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create typed postMessage protocol and BlockInstance type</name>
  <files>
    packages/mesh-plugin-site-editor/client/lib/editor-protocol.ts
    packages/mesh-plugin-site-editor/client/lib/use-editor-messages.ts
    packages/mesh-plugin-site-editor/client/lib/page-api.ts
  </files>
  <action>
    **Create `editor-protocol.ts`** with typed discriminated unions for editor-to-iframe and iframe-to-editor messages:

    EditorMessage (sent by Mesh editor to iframe):
    - `{ type: "deco:page-config"; page: Page }` -- send full page config after ready
    - `{ type: "deco:update-block"; blockId: string; props: Record<string, unknown> }` -- live prop update
    - `{ type: "deco:select-block"; blockId: string }` -- highlight a block in preview
    - `{ type: "deco:set-viewport"; width: number }` -- inform iframe of viewport change (optional, for CSS media query hints)

    SiteMessage (sent by iframe to Mesh editor):
    - `{ type: "deco:ready"; version: number }` -- iframe is ready, handshake
    - `{ type: "deco:block-clicked"; blockId: string; rect: DOMRect }` -- user clicked a section in preview
    - `{ type: "deco:blocks-rendered"; blocks: Array<{ id: string; rect: DOMRect }> }` -- blocks with positions after render

    Export both types and a `DECO_MSG_PREFIX = "deco:"` constant for message filtering.

    **Create `use-editor-messages.ts`** hook:
    - Takes `iframeRef: React.RefObject<HTMLIFrameElement | null>`
    - Returns `{ send: (msg: EditorMessage) => void, subscribe: (handler: (msg: SiteMessage) => void) => () => void }`
    - `send` calls `iframeRef.current?.contentWindow?.postMessage(msg, "*")` (use "*" per research -- cross-origin tunnels)
    - `subscribe` adds a `message` event listener that:
      1. Checks `e.source === iframeRef.current?.contentWindow` (ignore messages from other sources)
      2. Checks `e.data?.type?.startsWith(DECO_MSG_PREFIX)` (ignore non-deco messages)
      3. Calls handler with `e.data as SiteMessage`
      4. Returns cleanup function that removes the listener
    - Use `useCallback` for both `send` and `subscribe` to maintain stable references

    **Update `page-api.ts`**:
    - Add `BlockInstance` interface: `{ id: string; blockType: string; props: Record<string, unknown> }`
    - Change the `Page` interface `blocks` field from `unknown[]` to `BlockInstance[]`
    - Change the `updatePage` function `updates` parameter blocks field from `unknown[]` to `BlockInstance[]`
    - Export `BlockInstance` alongside `Page` and `PageSummary`
  </action>
  <verify>
    Run `npx tsc --noEmit` from the mesh-plugin-site-editor package (or check that the containing project type-checks). Verify:
    - editor-protocol.ts exports EditorMessage, SiteMessage, DECO_MSG_PREFIX
    - use-editor-messages.ts exports useEditorMessages
    - page-api.ts exports BlockInstance and Page.blocks is BlockInstance[]
  </verify>
  <done>
    EditorMessage and SiteMessage types define the full postMessage protocol. useEditorMessages hook provides send/subscribe with source filtering. BlockInstance replaces unknown[] in Page.blocks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build page composer layout, viewport toggle, and enhanced preview panel</name>
  <files>
    packages/mesh-plugin-site-editor/client/components/page-composer.tsx
    packages/mesh-plugin-site-editor/client/components/viewport-toggle.tsx
    packages/mesh-plugin-site-editor/client/components/preview-panel.tsx
  </files>
  <action>
    **Create `viewport-toggle.tsx`**:
    - Export a `VIEWPORTS` constant: `{ mobile: { width: 375, label: "Mobile" }, tablet: { width: 768, label: "Tablet" }, desktop: { width: 1440, label: "Desktop" } } as const`
    - Export `ViewportKey` type: `keyof typeof VIEWPORTS`
    - Export `ViewportToggle` component with props `{ value: ViewportKey; onChange: (v: ViewportKey) => void }`
    - Renders 3 buttons (use `@deco/ui/components/button.tsx` Button) with `variant="default"` for active, `variant="outline"` for inactive
    - Use `Smartphone`, `Tablet`, `Monitor` icons from `lucide-react` (already a dependency from Phase 2) inside buttons, with the label text as tooltip or sr-only text
    - Wrap in a flex container with `gap-1`

    **Rewrite `preview-panel.tsx`** to add postMessage integration and viewport support:
    - Props: `{ path?: string; page: Page | null; selectedBlockId: string | null; viewport: ViewportKey; onBlockClicked: (blockId: string) => void }`
    - Create an `iframeRef = useRef<HTMLIFrameElement>(null)`
    - Call `useEditorMessages(iframeRef)` to get `{ send, subscribe }`
    - Track `ready` state (boolean, initially false)
    - useEffect with subscribe: on `deco:ready`, set ready=true and send `{ type: "deco:page-config", page }`. On `deco:block-clicked`, call `onBlockClicked(msg.blockId)`.
    - useEffect to re-send `deco:page-config` whenever `page` changes and `ready` is true
    - useEffect to send `deco:select-block` whenever `selectedBlockId` changes and `ready` is true
    - Listen for iframe `load` event to reset `ready` to false (handles HMR/navigation re-inject)
    - Build `previewUrl` from `useTunnelUrl()` + path (same as before)
    - Set iframe `style={{ width: VIEWPORTS[viewport]?.width ? \`${VIEWPORTS[viewport].width}px\` : "100%" }}`
    - Add `transition-[width] duration-300` class for smooth viewport animation
    - Wrap iframe in a centered flex container with `bg-muted/30` background
    - Keep existing loading and empty states for when url is null/loading
    - Export as named export `PreviewPanel` (keep default export too for backward compat)

    **Create `page-composer.tsx`**:
    - This is the three-panel visual editor layout (left: section list, center: preview, right: prop editor)
    - Props: `{ pageId: string }` (fetches page data internally)
    - Uses `usePluginContext` and `useQuery` to fetch page via `getPage(toolCaller, pageId)`
    - State: `selectedBlockId: string | null`, `viewport: ViewportKey` (default "desktop")
    - Layout: Flexbox row, full height
      - Left panel: 260px wide, border-right, overflow-y-auto. For now render a placeholder `<div>` with text "Sections" -- Plan 03-02 will add the real section list sidebar
      - Center panel: flex-1, with viewport toggle bar at top and PreviewPanel below
      - Right panel: 320px wide, border-left, overflow-y-auto. When a block is selected, show PropEditor with that block's schema/formData. When no block selected, show "Select a section to edit" placeholder.
    - Top bar above the three panels: breadcrumb (Pages / {title}), save button, viewport toggle
    - The `onBlockClicked` callback sets `selectedBlockId`
    - When PropEditor `onChange` fires, update the block's props in a local copy of the page (useState), and immediately send `deco:update-block` via postMessage for live preview. Debounce the save-to-git (PUT_FILE) via a 2-second debounce timer.
    - For the prop editor: find the selected block in page.blocks, look up its block definition via `getBlock(toolCaller, block.blockType)` to get the schema. Use React Query for this lookup (blockKeys.detail).
    - Export as default (for lazy route loading)

    Follow codebase conventions: kebab-case file names, double quotes, @deco/ui components, lucide-react icons.
  </action>
  <verify>
    Run type-check. Verify:
    - page-composer.tsx imports and uses PreviewPanel, ViewportToggle, PropEditor
    - preview-panel.tsx uses useEditorMessages and handles deco:ready handshake
    - viewport-toggle.tsx renders 3 viewport buttons with icons
    - All files follow existing import patterns (relative imports within plugin, @deco/ui for components)
  </verify>
  <done>
    Three-panel page composer layout renders with a preview center panel that communicates via postMessage, a viewport toggle bar switching between 375/768/1440px widths, and placeholder panels for section list and prop editor. PropEditor wired to show selected block's form when a block is clicked.
  </done>
</task>

</tasks>

<verification>
1. Type-check passes: all new files compile without errors
2. PreviewPanel sends deco:page-config only after receiving deco:ready
3. ViewportToggle renders 3 buttons; clicking changes iframe width
4. PageComposer renders three-panel layout with preview in center
5. BlockInstance type is used in Page.blocks (not unknown[])
</verification>

<success_criteria>
- editor-protocol.ts defines EditorMessage (4 variants) and SiteMessage (3 variants) as discriminated unions
- use-editor-messages.ts provides send/subscribe with source/prefix filtering
- page-api.ts has BlockInstance interface with id, blockType, props fields
- preview-panel.tsx uses postMessage protocol with ready handshake
- viewport-toggle.tsx offers mobile/tablet/desktop at 375/768/1440px
- page-composer.tsx renders three-panel layout with preview, section list placeholder, and prop editor for selected block
</success_criteria>

<output>
After completion, create `.planning/phases/03-visual-editor/03-01-SUMMARY.md`
</output>
