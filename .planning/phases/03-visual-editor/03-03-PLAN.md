---
phase: 03-visual-editor
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - packages/mesh-plugin-site-editor/client/lib/use-undo-redo.ts
  - packages/mesh-plugin-site-editor/client/components/page-composer.tsx

autonomous: true

must_haves:
  truths:
    - "User can undo a prop edit and the preview reverts to the previous state"
    - "User can undo a section reorder and the section list reverts to the previous order"
    - "User can undo a section add or remove"
    - "User can redo after undoing"
    - "Cmd+Z triggers undo, Cmd+Shift+Z or Cmd+Y triggers redo"
    - "Redo stack is cleared when a new edit is made after undoing"
    - "Redo stack is cleared on save to prevent divergence from persisted state"
    - "Undo/redo buttons in the toolbar show disabled state when stack is empty"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/lib/use-undo-redo.ts"
      provides: "Snapshot-based undo/redo hook"
      exports: ["useUndoRedo"]
    - path: "packages/mesh-plugin-site-editor/client/components/page-composer.tsx"
      provides: "Undo/redo integration with keyboard shortcuts and toolbar buttons"
      contains: "useUndoRedo"
  key_links:
    - from: "page-composer.tsx"
      to: "use-undo-redo.ts"
      via: "useUndoRedo hook managing page blocks state"
      pattern: "useUndoRedo"
    - from: "page-composer.tsx"
      to: "editor-protocol.ts"
      via: "sends deco:page-config on undo/redo to update preview"
      pattern: "deco:page-config"
---

<objective>
Implement snapshot-based undo/redo for all page editing operations (prop edits, section reordering, section add/remove) with keyboard shortcuts and toolbar buttons.

Purpose: Gives users confidence to experiment with changes -- they can always undo. Covers EDIT-07 requirement across all edit types.
Output: use-undo-redo.ts hook, updated page-composer.tsx with undo/redo integration
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-visual-editor/03-RESEARCH.md
@.planning/phases/03-visual-editor/03-02-SUMMARY.md

@packages/mesh-plugin-site-editor/client/components/page-composer.tsx
@packages/mesh-plugin-site-editor/client/lib/page-api.ts
@packages/mesh-plugin-site-editor/client/lib/editor-protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create snapshot-based undo/redo hook</name>
  <files>
    packages/mesh-plugin-site-editor/client/lib/use-undo-redo.ts
  </files>
  <action>
    Create `use-undo-redo.ts` with a generic `useUndoRedo<T>` hook:

    - Generic type parameter `T` for the state being tracked
    - Takes `initial: T` as parameter
    - Internal state:
      - `past: T[]` (undo stack)
      - `present: T` (current value)
      - `future: T[]` (redo stack)
    - Use `useState` for all three (not useReducer -- keeps it simple and matches existing patterns)
    - Returns: `{ value: T, push: (next: T) => void, undo: () => void, redo: () => void, canUndo: boolean, canRedo: boolean, reset: (newInitial: T) => void }`

    **push(next: T):**
    - Append current `present` to `past`
    - Set `present` to `next`
    - Clear `future` (new edit invalidates redo stack)

    **undo():**
    - If `past.length === 0`, return (no-op)
    - Prepend current `present` to `future`
    - Set `present` to `past[past.length - 1]`
    - Remove last element from `past`

    **redo():**
    - If `future.length === 0`, return (no-op)
    - Append current `present` to `past`
    - Set `present` to `future[0]`
    - Remove first element from `future`

    **reset(newInitial: T):**
    - Set `present` to `newInitial`
    - Clear both `past` and `future`
    - Used after save to prevent redo from diverging from persisted state

    **canUndo:** `past.length > 0`
    **canRedo:** `future.length > 0`

    Implementation notes:
    - Use `useCallback` for push, undo, redo, reset to maintain stable references
    - The state updates need to be coordinated -- use functional updaters to avoid stale closures:
      ```typescript
      const undo = useCallback(() => {
        setPast(prev => {
          if (prev.length === 0) return prev;
          // Move present to future, last past to present
          setFuture(f => [present, ...f]);  // BAD: stale present
        });
      ```
      Instead, use a single `useReducer` internally with action types `PUSH`, `UNDO`, `REDO`, `RESET` to keep all three state values in sync atomically. This is the one case where useReducer is justified -- three interdependent state values.

    Correct implementation with useReducer:
    ```typescript
    type Action<T> =
      | { type: "PUSH"; value: T }
      | { type: "UNDO" }
      | { type: "REDO" }
      | { type: "RESET"; value: T };

    interface State<T> { past: T[]; present: T; future: T[] }

    function reducer<T>(state: State<T>, action: Action<T>): State<T> {
      switch (action.type) {
        case "PUSH": return { past: [...state.past, state.present], present: action.value, future: [] };
        case "UNDO": { if (state.past.length === 0) return state; return { past: state.past.slice(0, -1), present: state.past[state.past.length - 1], future: [state.present, ...state.future] }; }
        case "REDO": { if (state.future.length === 0) return state; return { past: [...state.past, state.present], present: state.future[0], future: state.future.slice(1) }; }
        case "RESET": return { past: [], present: action.value, future: [] };
      }
    }
    ```

    - Cap the past stack at 100 entries (drop oldest when exceeded) to prevent unbounded memory growth
    - The value comparison uses reference equality (not deep equal) -- callers must provide new objects on push
  </action>
  <verify>
    Run type-check. Verify use-undo-redo.ts exports useUndoRedo with correct return type.
  </verify>
  <done>
    useUndoRedo hook provides snapshot-based undo/redo with push/undo/redo/reset operations, 100-entry cap, and useReducer for atomic state transitions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate undo/redo into page composer with keyboard shortcuts and toolbar</name>
  <files>
    packages/mesh-plugin-site-editor/client/components/page-composer.tsx
  </files>
  <action>
    **Replace the local pageData state management** in page-composer.tsx with `useUndoRedo`:

    - Instead of `useState<BlockInstance[]>` for the local blocks, use `useUndoRedo<BlockInstance[]>(page?.blocks ?? [])`
    - The hook returns `{ value: blocks, push, undo, redo, canUndo, canRedo, reset }`
    - `blocks` is the current state (replaces `pageData.blocks` from the previous implementation)

    **Update all edit operations to push snapshots:**
    - **Prop change:** When PropEditor fires onChange, create a new blocks array with the updated block props, call `push(newBlocks)`, and send `deco:update-block` postMessage
    - **Reorder:** When DnD onReorder fires, call `arrayMove` on blocks, call `push(reorderedBlocks)`
    - **Add section:** When BlockPicker onSelect fires, create new BlockInstance, call `push([...blocks, newBlock])`
    - **Delete section:** When onDelete fires, call `push(blocks.filter(b => b.id !== id))`

    **Update the debounced save:**
    - The debounced save now saves `blocks` (the current value from the undo/redo hook)
    - After a successful save, call `reset(blocks)` to clear redo stack (prevents divergence from persisted state, per research pitfall #3). Actually, don't reset the full stack on save -- just clear the future stack. Implement by: on save success, clear only the future stack. Add a `clearFuture` method to the hook, OR simply accept that saving doesn't reset undo. The research says "clear redo on save" to prevent the "undo past save point" confusion. To implement: after save success, dispatch a new action type `SAVE` that clears future but keeps past. Add `{ type: "SAVE" }` to the reducer: `case "SAVE": return { ...state, future: [] }`.
    - Export `save` from the hook as well (dispatches SAVE action)

    **Add keyboard shortcuts** via a useEffect in page-composer.tsx:
    - Listen for `keydown` on `window`
    - `Cmd+Z` (metaKey+z, no shiftKey) or `Ctrl+Z` (ctrlKey+z, no shiftKey): call `e.preventDefault()`, call `undo()`
    - `Cmd+Shift+Z` or `Cmd+Y` or `Ctrl+Shift+Z` or `Ctrl+Y`: call `e.preventDefault()`, call `redo()`
    - Cleanup: remove listener on unmount
    - Dependencies: [undo, redo]

    **When undo/redo fires, update the preview:**
    - Add a useEffect that watches `blocks` (the present value from the hook) and sends `deco:page-config` with the full updated page to the iframe. This ensures the preview always reflects the current state, whether changed by direct edit, undo, or redo.

    **Add undo/redo buttons to the top toolbar:**
    - Next to the viewport toggle, add two icon buttons: Undo2 and Redo2 from lucide-react
    - Undo button: `disabled={!canUndo}`, onClick calls `undo()`
    - Redo button: `disabled={!canRedo}`, onClick calls `redo()`
    - Add tooltips or title attributes: "Undo (Cmd+Z)" and "Redo (Cmd+Shift+Z)"
    - Use `@deco/ui/components/button.tsx` Button with `variant="ghost"` and `size="icon"`
  </action>
  <verify>
    Run type-check. Verify:
    - page-composer.tsx imports and uses useUndoRedo
    - Keyboard event listener is set up for Cmd+Z / Cmd+Shift+Z
    - Undo/redo buttons render with correct disabled states
    - All edit operations (prop change, reorder, add, delete) call push()
    - Preview updates via deco:page-config when blocks change (including undo/redo)
  </verify>
  <done>
    All page editing operations (prop change, reorder, add, delete) push snapshots to the undo/redo stack. Cmd+Z undoes, Cmd+Shift+Z redoes. Toolbar shows undo/redo buttons with disabled state. Preview updates on undo/redo. Redo stack clears on save to prevent divergence.
  </done>
</task>

</tasks>

<verification>
1. Type-check passes
2. useUndoRedo hook correctly manages past/present/future with useReducer
3. Undo reverts to previous state, redo re-applies
4. Keyboard shortcuts work (Cmd+Z, Cmd+Shift+Z)
5. Toolbar undo/redo buttons show correct disabled state
6. Preview iframe updates on undo/redo via deco:page-config
7. Redo stack clears after save
</verification>

<success_criteria>
- useUndoRedo hook provides push/undo/redo/reset/save with 100-entry cap
- All edit types push snapshots: prop edit, reorder, add section, remove section
- Cmd+Z undoes, Cmd+Shift+Z/Cmd+Y redoes (both Mac and PC modifiers)
- Undo/redo buttons in toolbar with disabled state when stack empty
- Preview reflects undo/redo state within 1 second
- Redo stack cleared on save to prevent state divergence
</success_criteria>

<output>
After completion, create `.planning/phases/03-visual-editor/03-03-SUMMARY.md`
</output>
