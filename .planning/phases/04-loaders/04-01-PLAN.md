---
phase: 04-loaders
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mesh-plugin-site-editor/server/scanner/types.ts
  - packages/mesh-plugin-site-editor/server/scanner/discover.ts
  - packages/mesh-plugin-site-editor/server/scanner/schema.ts
  - packages/mesh-plugin-site-editor/server/tools/loader-scan.ts
  - packages/mesh-plugin-site-editor/server/tools/loader-list.ts
  - packages/mesh-plugin-site-editor/server/tools/loader-get.ts
  - packages/mesh-plugin-site-editor/server/tools/index.ts
  - packages/mesh-plugin-site-editor/client/lib/loader-api.ts
  - packages/mesh-plugin-site-editor/client/lib/query-keys.ts
autonomous: true

must_haves:
  truths:
    - "Loader definitions are stored in .deco/loaders/ as JSON files following the same convention as .deco/blocks/"
    - "Scanner discovers default-exported async functions in .ts files under loaders/ prefix and generates both input and output JSON schemas"
    - "Client can list and fetch loader definitions via SITE_BINDING tools (LIST_FILES, READ_FILE)"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/server/scanner/types.ts"
      provides: "LoaderDefinition and LoaderInfo types"
      contains: "LoaderDefinition"
    - path: "packages/mesh-plugin-site-editor/server/scanner/discover.ts"
      provides: "discoverLoaders function for .ts files"
      contains: "discoverLoaders"
    - path: "packages/mesh-plugin-site-editor/server/tools/loader-scan.ts"
      provides: "CMS_LOADER_SCAN server tool"
      contains: "CMS_LOADER_SCAN"
    - path: "packages/mesh-plugin-site-editor/server/tools/loader-list.ts"
      provides: "CMS_LOADER_LIST server tool"
      contains: "CMS_LOADER_LIST"
    - path: "packages/mesh-plugin-site-editor/server/tools/loader-get.ts"
      provides: "CMS_LOADER_GET server tool"
      contains: "CMS_LOADER_GET"
    - path: "packages/mesh-plugin-site-editor/client/lib/loader-api.ts"
      provides: "listLoaders and getLoader client helpers"
      exports: ["listLoaders", "getLoader"]
    - path: "packages/mesh-plugin-site-editor/client/lib/query-keys.ts"
      provides: "Loader query keys for React Query"
      contains: "loaders"
  key_links:
    - from: "server/tools/loader-scan.ts"
      to: "server/scanner/discover.ts"
      via: "discoverLoaders function call"
      pattern: "discoverLoaders"
    - from: "server/tools/loader-scan.ts"
      to: "server/scanner/schema.ts"
      via: "generateSchema for both input and output types"
      pattern: "generateSchema"
    - from: "client/lib/loader-api.ts"
      to: "SITE_BINDING tools"
      via: "toolCaller LIST_FILES/READ_FILE"
      pattern: "toolCaller.*LIST_FILES|READ_FILE"
---

<objective>
Build the server-side loader infrastructure: types, scanner extension, server tools, client API helpers, and query keys.

Purpose: Loaders need the same CRUD data layer that blocks have. This plan creates the full backend pipeline -- from scanning TypeScript loader files to storing LoaderDefinition JSON, to listing/fetching them from the client.

Output: LoaderDefinition type, discoverLoaders scanner, CMS_LOADER_SCAN/LIST/GET tools, client loader-api helpers, loader query keys.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-loaders/04-RESEARCH.md

Key codebase files to reference (read these before implementing):
@packages/mesh-plugin-site-editor/server/scanner/types.ts
@packages/mesh-plugin-site-editor/server/scanner/discover.ts
@packages/mesh-plugin-site-editor/server/scanner/schema.ts
@packages/mesh-plugin-site-editor/server/tools/block-scan.ts
@packages/mesh-plugin-site-editor/server/tools/block-list.ts
@packages/mesh-plugin-site-editor/server/tools/block-get.ts
@packages/mesh-plugin-site-editor/server/tools/index.ts
@packages/mesh-plugin-site-editor/client/lib/block-api.ts
@packages/mesh-plugin-site-editor/client/lib/query-keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: LoaderDefinition types and discoverLoaders scanner</name>
  <files>
    packages/mesh-plugin-site-editor/server/scanner/types.ts
    packages/mesh-plugin-site-editor/server/scanner/discover.ts
    packages/mesh-plugin-site-editor/server/scanner/schema.ts
  </files>
  <action>
**types.ts** -- Add LoaderDefinition and LoaderInfo types alongside existing BlockDefinition:

```typescript
/** Loader function info extracted during discovery (analogous to ComponentInfo) */
export interface LoaderInfo {
  /** Loader function name */
  name: string;
  /** Source file path within the project */
  filePath: string;
  /** TypeScript type name for the input Props parameter, or null */
  propsTypeName: string | null;
  /** TypeScript type name for the return type (unwrapped from Promise), or null */
  returnTypeName: string | null;
  /** JSDoc description */
  jsDocDescription: string;
}

/** Full loader definition stored in .deco/loaders/{id}.json */
export interface LoaderDefinition {
  /** Unique ID derived from loader path, e.g., "loaders--productList" */
  id: string;
  /** Source file path, e.g., "loaders/productList.ts" */
  source: string;
  /** Human-readable label, e.g., "Product List" */
  label: string;
  /** Category derived from directory, e.g., "Loaders" */
  category: string;
  /** Description from JSDoc */
  description: string;
  /** JSON Schema for loader INPUT parameters (Props type) */
  inputSchema: JSONSchema7;
  /** JSON Schema for loader OUTPUT (return type) */
  outputSchema: JSONSchema7;
  /** Default input parameter values */
  defaults: Record<string, unknown>;
  /** Scan metadata */
  metadata: {
    scannedAt: string;
    scanMethod: "ts-morph" | "manual" | "ai-agent";
    propsTypeName: string | null;
    returnTypeName: string | null;
    customized: string[];
  };
}

/** Lightweight loader summary for list operations */
export interface LoaderSummary {
  id: string;
  source: string;
  label: string;
  category: string;
  inputParamsCount: number;
}
```

Also add a `LoaderRef` type for use in BlockInstance props (used in plan 04-02):
```typescript
/** Reference to a loader definition from a block instance prop value */
export interface LoaderRef {
  __loaderRef: string;  // LoaderDefinition.id
  field?: string;       // Optional: pick a specific field from loader output
  params?: Record<string, unknown>;  // Configured input parameter values
}
```

**discover.ts** -- Add `discoverLoaders()` function. This is separate from `discoverComponents()` because loaders:
- Scan `.ts` files (not `.tsx`)
- Look for default-exported async functions that do NOT return JSX
- Extract both the Props input type AND the return type

The function should:
1. Iterate project source files, filtering to `.ts` files only (not `.tsx`)
2. For each file, find the default export
3. Check it's a function (FunctionDeclaration, ArrowFunction, or FunctionExpression)
4. Extract the first parameter's type name as `propsTypeName` (same logic as extractFromFunction)
5. Extract the return type, unwrapping `Promise<T>` -- use `getType().getText()` and regex to strip `Promise<>` wrapper. For the `returnTypeName`, get the unwrapped type's alias symbol name or symbol name
6. Skip functions whose return type looks like JSX (reuse `looksLikeJSX` -- extract it to a shared helper if needed, or just check the existing JSX_RETURN_PATTERNS)
7. Return `LoaderInfo[]`

Important: Allow loaders to have zero parameters (no Props type). Unlike components which need props to be useful in the editor, a loader like `getWeather()` with no params is valid. Set `propsTypeName: null` for these.

For unwrapping Promise: the return type text from ts-morph will be something like `Promise<Temperature | null>`. Parse this:
- If starts with `Promise<`, extract inner type text
- Strip `| null` and `| undefined` for the type name lookup
- Use the inner type for returnTypeName (the alias or symbol name)
- If unwrapping fails, set returnTypeName to null

**schema.ts** -- Add a `generateOutputSchema()` function that generates JSON Schema from a return type. This is nearly identical to `generateSchema()` but:
- Takes a `returnTypeName` instead of a props type name
- If the returnTypeName is null, return `{ type: "object", additionalProperties: true }`
- Same fallback behavior as existing generateSchema on failure
- Uses the same `inlineRefs` post-processing

To avoid duplication, consider extracting the common schema generation logic into a shared helper, or simply call `generateSchema` with the returnTypeName and filePath (it already takes any type name, not just props types).
  </action>
  <verify>
Read the modified files and verify:
1. `LoaderDefinition` type has `inputSchema` and `outputSchema` fields (both JSONSchema7)
2. `LoaderInfo` type has both `propsTypeName` and `returnTypeName`
3. `discoverLoaders()` function exists, filters to `.ts` files, skips JSX return types
4. `generateSchema()` can be called for both input and output types (or a new `generateOutputSchema` exists)
5. TypeScript compiles: `npx tsc --noEmit` in the package directory (or at minimum verify no obvious type errors by reading the code)
  </verify>
  <done>
LoaderDefinition and LoaderInfo types defined in types.ts. discoverLoaders function in discover.ts scans .ts files for default-exported async functions, extracts input Props type and unwrapped return type. Schema generation works for both input (props) and output (return) types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Loader server tools and client API</name>
  <files>
    packages/mesh-plugin-site-editor/server/tools/loader-scan.ts
    packages/mesh-plugin-site-editor/server/tools/loader-list.ts
    packages/mesh-plugin-site-editor/server/tools/loader-get.ts
    packages/mesh-plugin-site-editor/server/tools/index.ts
    packages/mesh-plugin-site-editor/client/lib/loader-api.ts
    packages/mesh-plugin-site-editor/client/lib/query-keys.ts
  </files>
  <action>
**loader-scan.ts** -- Create CMS_LOADER_SCAN tool following the exact pattern of block-scan.ts:
- Input: `connectionId: string`, `patterns?: string[]` (default: `["loaders/"]`)
- Output: `{ loaders: LoaderSummary[], errors: string[] }`
- Pipeline: `createProjectFromMCP(proxy, patterns)` -> `discoverLoaders(project)` -> for each loader, generate inputSchema via `generateSchema(project, propsTypeName, filePath)` and outputSchema via `generateSchema(project, returnTypeName, filePath)` -> write to `.deco/loaders/{id}.json`
- ID derivation: same `componentToId` pattern from block-scan (e.g., `loaders/productList.ts` -> `loaders--productList`). Extract the helper functions (`componentToId`, `nameToLabel`, `componentToCategory`) or duplicate them.
- Merge strategy: same as block-scan -- read existing loader def, preserve `metadata.customized` fields
- For loaders with no propsTypeName, set inputSchema to `{ type: "object", properties: {}, additionalProperties: false }`
- For loaders with no returnTypeName, set outputSchema to `{ type: "object", additionalProperties: true }`

**loader-list.ts** -- Create CMS_LOADER_LIST tool following block-list.ts exactly:
- Input: `connectionId: string`
- Output: `{ loaders: LoaderSummary[] }` where LoaderSummary has `id, source, label, category, inputParamsCount`
- Lists `.deco/loaders/` directory, reads each JSON, skips tombstoned, returns sorted summaries
- `inputParamsCount` = `Object.keys(loader.inputSchema?.properties ?? {}).length`

**loader-get.ts** -- Create CMS_LOADER_GET tool following block-get.ts pattern:
- Input: `connectionId: string, loaderId: string`
- Output: full LoaderDefinition JSON
- Reads `.deco/loaders/{loaderId}.json`, returns null/error if tombstoned or not found

**index.ts** -- Add imports for LOADER_SCAN, LOADER_LIST, LOADER_GET and append them to the `tools` array.

**loader-api.ts** -- Create client-side loader API helpers following block-api.ts exactly:
- `listLoaders(toolCaller)` -> `LoaderSummary[]` -- LIST_FILES on `.deco/loaders/` prefix, read each JSON, skip tombstoned, return sorted
- `getLoader(toolCaller, loaderId)` -> `LoaderDefinition | null` -- READ_FILE on `.deco/loaders/{loaderId}.json`
- Export `LoaderSummary` interface matching the server type shape
- Export `LoaderDefinition` interface matching the server type (id, source, label, category, description, inputSchema, outputSchema, defaults, metadata)
- Use the same `TypedToolCaller<SiteBinding>` pattern as block-api.ts

**query-keys.ts** -- Add `loaders` namespace to the existing queryKeys object:
```typescript
loaders: {
  all: (connectionId: string) =>
    ["site-editor", "loaders", connectionId] as const,
  detail: (connectionId: string, loaderId: string) =>
    ["site-editor", "loaders", connectionId, loaderId] as const,
},
```
Add shorthand: `export const loaderKeys = queryKeys.loaders;`
  </action>
  <verify>
Read all created/modified files and verify:
1. loader-scan.ts uses `discoverLoaders` (not `discoverComponents`) and writes to `.deco/loaders/`
2. loader-list.ts reads from `.deco/loaders/` and returns `inputParamsCount`
3. loader-get.ts reads `.deco/loaders/{loaderId}.json`
4. index.ts exports all three new tools in the tools array
5. loader-api.ts uses SITE_BINDING toolCaller with `.deco/loaders/` prefix
6. query-keys.ts has loaders.all and loaders.detail keys
7. Zod schemas use `z.string()` explicit key for any z.record calls (per 02-01 decision)
  </verify>
  <done>
Three server tools (CMS_LOADER_SCAN, CMS_LOADER_LIST, CMS_LOADER_GET) registered in index.ts. Client loader-api.ts provides listLoaders and getLoader helpers using SITE_BINDING. Query keys include loaders namespace with all and detail keys.
  </done>
</task>

</tasks>

<verification>
1. All new files follow existing naming conventions (kebab-case filenames, camelCase functions)
2. Server tools follow the exact ServerPluginToolDefinition pattern with zod input/output schemas
3. Client API uses TypedToolCaller<SiteBinding> pattern, not direct MCP calls
4. LoaderDefinition has both inputSchema AND outputSchema (key difference from BlockDefinition)
5. Scanner extension handles .ts files and filters OUT .tsx/JSX returns
6. No new dependencies added -- all libraries already in the dependency tree
</verification>

<success_criteria>
- LoaderDefinition type exists with inputSchema and outputSchema
- discoverLoaders scans .ts files for default-exported async functions
- CMS_LOADER_SCAN writes loader definitions to .deco/loaders/
- CMS_LOADER_LIST and CMS_LOADER_GET read from .deco/loaders/
- Client loader-api provides listLoaders and getLoader helpers
- Query keys include loaders namespace
- All tools registered in server/tools/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/04-loaders/04-01-SUMMARY.md`
</output>
