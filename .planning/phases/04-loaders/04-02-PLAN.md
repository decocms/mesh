---
phase: 04-loaders
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - packages/mesh-plugin-site-editor/client/components/loaders-list.tsx
  - packages/mesh-plugin-site-editor/client/components/loader-detail.tsx
  - packages/mesh-plugin-site-editor/client/components/loader-picker.tsx
  - packages/mesh-plugin-site-editor/client/lib/router.ts
  - packages/mesh-plugin-site-editor/client/lib/page-api.ts
  - packages/mesh-plugin-site-editor/client/components/page-composer.tsx
autonomous: true

must_haves:
  truths:
    - "Loaders panel shows a categorized list of loader definitions with equal prominence to Sections in the sidebar"
    - "Clicking a loader navigates to a detail view with metadata and a PropEditor form for configuring input parameters"
    - "User can bind a loader to a section prop via a loader picker modal, and the binding is stored as a __loaderRef in BlockInstance.props"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/components/loaders-list.tsx"
      provides: "Full loaders list with category grouping"
      min_lines: 80
    - path: "packages/mesh-plugin-site-editor/client/components/loader-detail.tsx"
      provides: "Loader detail view with PropEditor for input params"
      contains: "PropEditor"
    - path: "packages/mesh-plugin-site-editor/client/components/loader-picker.tsx"
      provides: "Modal for binding a loader to a section prop"
      contains: "__loaderRef"
    - path: "packages/mesh-plugin-site-editor/client/lib/router.ts"
      provides: "Loader detail route"
      contains: "/loaders/$loaderId"
    - path: "packages/mesh-plugin-site-editor/client/lib/page-api.ts"
      provides: "LoaderRef type export"
      contains: "LoaderRef"
  key_links:
    - from: "client/components/loaders-list.tsx"
      to: "client/lib/loader-api.ts"
      via: "listLoaders query"
      pattern: "listLoaders"
    - from: "client/components/loader-detail.tsx"
      to: "client/lib/loader-api.ts"
      via: "getLoader query"
      pattern: "getLoader"
    - from: "client/components/loader-picker.tsx"
      to: "client/lib/page-api.ts"
      via: "LoaderRef in BlockInstance.props"
      pattern: "__loaderRef"
    - from: "client/components/loaders-list.tsx"
      to: "client/lib/router.ts"
      via: "navigate to /loaders/$loaderId"
      pattern: "navigate.*loaders"
---

<objective>
Build the loader UI: list view, detail view with prop editor, loader picker modal for binding to section props, and route wiring.

Purpose: This makes loaders a visible, configurable entity in the CMS sidebar -- equal in prominence to Sections. Users can browse loaders, configure their input parameters, and bind loader output to section props.

Output: Fully functional loaders panel with list, detail, and binding UI.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-loaders/04-RESEARCH.md
@.planning/phases/04-loaders/04-01-SUMMARY.md

Key codebase files to reference (read these before implementing):
@packages/mesh-plugin-site-editor/client/components/sections-list.tsx
@packages/mesh-plugin-site-editor/client/components/block-detail.tsx
@packages/mesh-plugin-site-editor/client/components/block-picker.tsx
@packages/mesh-plugin-site-editor/client/components/prop-editor.tsx
@packages/mesh-plugin-site-editor/client/components/page-composer.tsx
@packages/mesh-plugin-site-editor/client/lib/router.ts
@packages/mesh-plugin-site-editor/client/lib/page-api.ts
@packages/mesh-plugin-site-editor/client/lib/loader-api.ts
@packages/mesh-plugin-site-editor/client/lib/query-keys.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Loaders list and detail views</name>
  <files>
    packages/mesh-plugin-site-editor/client/components/loaders-list.tsx
    packages/mesh-plugin-site-editor/client/components/loader-detail.tsx
    packages/mesh-plugin-site-editor/client/lib/router.ts
  </files>
  <action>
**loaders-list.tsx** -- Replace the stub with a full implementation mirroring sections-list.tsx exactly:
- Use `usePluginContext<typeof SITE_BINDING>()` for toolCaller and connectionId
- Use `useQuery` with `loaderKeys.all(connectionId)` and `listLoaders(toolCaller)`
- Import `loaderKeys` from query-keys, `listLoaders` from loader-api, `siteEditorRouter` from router
- Show loading state with `Loading01` spinner (same as sections-list)
- Show error state with `AlertCircle` icon (same as sections-list)
- Show empty state with a message like "No loaders found. Scan your codebase to discover data loaders." and a "Scan Codebase" button (placeholder click handler like sections-list)
- Group loaders by category using the same `groupByCategory` helper pattern (copy from sections-list, adapted for LoaderSummary which has `source` instead of `component`)
- Each loader item navigates to `/loaders/$loaderId` on click
- Display: loader label, source path as subtitle, `{inputParamsCount} params` badge
- Use `Database` icon from lucide-react (not `Box` which is for sections) for each loader item
- Header: "Loaders" title with `{loaders.length} loaders` badge

**loader-detail.tsx** -- Create following the block-detail.tsx pattern exactly:
- Use `siteEditorRouter.useParams({ from: "/loaders/$loaderId" })` to get loaderId
- Use `useQuery` with `loaderKeys.detail(connectionId, loaderId)` and `getLoader(toolCaller, loaderId)`
- Ref-based formData sync (same `lastSyncedLoaderId` ref pattern from block-detail)
- Header: breadcrumb "Loaders / {loader.label}" with back navigation to `/loaders`
- Content sections:
  1. **Loader info**: label, source path, description
  2. **Metadata**: scan method badge, scanned timestamp, props type name, return type name, input params count
  3. **Output schema** (collapsible): raw JSON of outputSchema (same chevron toggle pattern as block-detail's raw schema)
  4. **Input Parameters editor**: Use `PropEditor` with `schema={loader.inputSchema}` -- this lets users configure default parameter values. `formData` state tracks the configured defaults. `onChange` updates local formData state.
  5. **Output Preview** (collapsible): raw JSON of outputSchema so users can see what data shape the loader returns

- Do NOT show a save button yet -- this view is for browsing/exploring loader definitions. The actual parameter configuration happens when binding a loader to a section prop (Task 2).

**router.ts** -- Add the loader detail route:
```typescript
const loaderDetailRoute = createRoute({
  getParentRoute: () => ctx.parentRoute,
  path: "/loaders/$loaderId",
  component: lazyRouteComponent(() => import("../components/loader-detail")),
});
```
Add `loaderDetailRoute` to the returned routes array (after `loadersRoute`).
  </action>
  <verify>
Read the created/modified files and verify:
1. loaders-list.tsx uses `listLoaders` from loader-api and `loaderKeys` from query-keys
2. loaders-list.tsx navigates to `/loaders/$loaderId` on item click
3. loader-detail.tsx uses `getLoader` and `PropEditor` component
4. loader-detail.tsx uses ref-based sync pattern (not useEffect -- banned by lint rule)
5. router.ts has `/loaders/$loaderId` route pointing to loader-detail component
6. All components use `usePluginContext<typeof SITE_BINDING>()` for toolCaller/connectionId
  </verify>
  <done>
Loaders list shows categorized loader definitions with navigation to detail view. Loader detail view displays metadata, output schema, and PropEditor for input parameters. Router wired with /loaders/$loaderId route.
  </done>
</task>

<task type="auto">
  <name>Task 2: Loader picker and prop binding</name>
  <files>
    packages/mesh-plugin-site-editor/client/components/loader-picker.tsx
    packages/mesh-plugin-site-editor/client/lib/page-api.ts
    packages/mesh-plugin-site-editor/client/components/page-composer.tsx
  </files>
  <action>
**page-api.ts** -- Add the LoaderRef type to the existing page-api module (this is where BlockInstance lives):

```typescript
/** Reference to a loader from a block instance prop value */
export interface LoaderRef {
  /** LoaderDefinition ID from .deco/loaders/ */
  __loaderRef: string;
  /** Optional: pick a specific field from loader output */
  field?: string;
  /** Configured input parameter values for this binding */
  params?: Record<string, unknown>;
}
```

Also add a type guard helper:
```typescript
/** Check if a prop value is a loader reference */
export function isLoaderRef(value: unknown): value is LoaderRef {
  return (
    value !== null &&
    typeof value === "object" &&
    "__loaderRef" in (value as Record<string, unknown>)
  );
}
```

**loader-picker.tsx** -- Create a modal dialog for selecting a loader to bind to a section prop. Follow block-picker.tsx pattern:
- Uses `@deco/ui Dialog` (Radix) -- same as block-picker.tsx and pages-list.tsx
- Props: `open: boolean`, `onOpenChange: (open: boolean) => void`, `onSelect: (loaderRef: LoaderRef) => void`, `propName: string` (the prop being bound)
- Content:
  1. Dialog header: "Bind Loader to {propName}"
  2. Loader list fetched via `useQuery` with `loaderKeys.all(connectionId)` and `listLoaders(toolCaller)`
  3. Group by category (same pattern as loaders-list)
  4. Each loader item shows: label, source, inputParamsCount badge
  5. Clicking a loader creates a `LoaderRef` object: `{ __loaderRef: loader.id, params: {} }` and calls `onSelect`
  6. Search/filter input at top (same pattern as block-picker: filter by label case-insensitive)
  7. Loading and empty states
- Do NOT include inline parameter configuration in the picker. Keep it simple: pick a loader, get a ref. Parameter configuration can be done in the loader detail view.

**page-composer.tsx** -- Add loader binding integration to the visual editor's prop editing flow. Read the current page-composer.tsx first to understand the existing structure, then make these minimal additions:

1. Import `LoaderRef`, `isLoaderRef` from page-api
2. Import `LoaderPicker` from loader-picker
3. Add state for the loader picker: `const [loaderPickerState, setLoaderPickerState] = useState<{ open: boolean; propName: string | null }>({ open: false, propName: null })`
4. In the prop editor panel (where PropEditor renders for the selected block), add a small "Bind Loader" button/link next to or below each prop field. Implementation approach:
   - Add a toolbar or link below the PropEditor that says "Bind loader to prop..." which opens the loader picker
   - When the picker returns a LoaderRef, set it as the prop value: `blockInstance.props[propName] = loaderRef`
   - Use `applyPageUpdate` to persist the change (same as existing prop edits)
5. For props that already have a `__loaderRef` binding, show an indicator: "Bound to: {loaderRef.__loaderRef}" with a "Remove binding" button that replaces the value with `undefined`

Keep the integration minimal. The key UX flow is:
- User selects a section in the composer
- User sees the prop editor on the right
- User clicks "Bind loader" for a specific prop
- Loader picker opens, user selects a loader
- Prop value becomes a LoaderRef object
- The binding is saved to the page JSON

Important caveats:
- The PropEditor (@rjsf) will see `__loaderRef` objects as form data. For now, this is acceptable -- the form will show them as nested objects. A custom @rjsf widget to detect and render loader bindings specially is a nice-to-have but NOT required for this phase. The success criteria says "map its output to section props" which is satisfied by the binding being stored.
- Use `useSyncExternalStore` pattern if any subscriptions are needed (ban-use-effect lint rule)
- Use `cn()` for conditional classNames
  </action>
  <verify>
Read the created/modified files and verify:
1. page-api.ts exports LoaderRef type and isLoaderRef guard
2. loader-picker.tsx uses Dialog from @deco/ui, fetches loaders via listLoaders, calls onSelect with LoaderRef
3. page-composer.tsx imports LoaderPicker and has state for opening it
4. page-composer.tsx can set a LoaderRef as a prop value via applyPageUpdate
5. No useEffect usage anywhere (use ref-based sync or useSyncExternalStore)
6. Dialog pattern matches existing block-picker.tsx usage
  </verify>
  <done>
LoaderRef type defined in page-api with isLoaderRef guard. Loader picker modal lets users select a loader to bind to a section prop. Page composer integrates loader binding into the prop editing flow. Selecting a loader creates a __loaderRef in BlockInstance.props, persisted via applyPageUpdate.
  </done>
</task>

</tasks>

<verification>
1. Navigate to /loaders in the plugin sidebar -- shows categorized loader list (DATA-01: equal prominence)
2. Click a loader -- navigates to detail view with metadata and PropEditor for input params
3. In page composer, select a section -- prop editor panel shows binding option
4. Open loader picker, select a loader -- prop value becomes a LoaderRef object
5. Page saves with __loaderRef in the block instance props JSON (DATA-02: configure and map)
6. All components follow established patterns: usePluginContext, useQuery, ref-based sync, no useEffect
</verification>

<success_criteria>
- Loaders list replaces the stub, shows categorized loader definitions
- Loader detail view shows metadata and PropEditor for input parameters
- Router has /loaders/$loaderId route
- Loader picker modal allows selecting a loader for prop binding
- LoaderRef stored in BlockInstance.props when loader is bound to a prop
- Page composer integrates loader binding into the existing prop editing workflow
</success_criteria>

<output>
After completion, create `.planning/phases/04-loaders/04-02-SUMMARY.md`
</output>
