---
phase: 06-connection-setup
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - apps/mesh/src/tools/filesystem/read-tunnel-config.ts
  - apps/mesh/src/tools/filesystem/index.ts
  - packages/mesh-plugin-site-editor/client/lib/use-tunnel-detection.ts
  - packages/mesh-plugin-site-editor/client/lib/query-keys.ts
  - packages/mesh-plugin-site-editor/client/components/tunnel-instructions.tsx
  - packages/mesh-plugin-site-editor/client/components/pages-list.tsx
autonomous: true

must_haves:
  truths:
    - "After connection is created, plugin auto-detects the tunnel URL from wrangler.toml without manual entry"
    - "When no tunnel is detected, actionable deco link instructions are shown to the user"
    - "Background polling continues until tunnel becomes reachable, then auto-configures preview"
    - "Detected tunnel URL persists in connection metadata for reuse across sessions"
    - "Projects without wrangler.toml gracefully show manual instructions instead of erroring"
  artifacts:
    - path: "apps/mesh/src/tools/filesystem/read-tunnel-config.ts"
      provides: "FILESYSTEM_READ_TUNNEL_CONFIG SELF MCP tool"
      exports: ["FILESYSTEM_READ_TUNNEL_CONFIG"]
    - path: "packages/mesh-plugin-site-editor/client/lib/use-tunnel-detection.ts"
      provides: "useTunnelDetection hook for auto-poll"
      exports: ["useTunnelDetection"]
    - path: "packages/mesh-plugin-site-editor/client/components/tunnel-instructions.tsx"
      provides: "Tunnel setup instructions UI component"
      exports: ["default"]
    - path: "packages/mesh-plugin-site-editor/client/lib/query-keys.ts"
      provides: "Tunnel detection query key"
      contains: "tunnel"
  key_links:
    - from: "packages/mesh-plugin-site-editor/client/lib/use-tunnel-detection.ts"
      to: "FILESYSTEM_READ_TUNNEL_CONFIG"
      via: "selfClient.callTool"
      pattern: "callTool.*FILESYSTEM_READ_TUNNEL_CONFIG"
    - from: "packages/mesh-plugin-site-editor/client/components/pages-list.tsx"
      to: "packages/mesh-plugin-site-editor/client/lib/use-tunnel-detection.ts"
      via: "useTunnelDetection hook"
      pattern: "useTunnelDetection"
    - from: "packages/mesh-plugin-site-editor/client/lib/use-tunnel-detection.ts"
      to: "COLLECTION_CONNECTIONS_UPDATE"
      via: "selfClient.callTool to persist tunnel URL"
      pattern: "COLLECTION_CONNECTIONS_UPDATE"
---

<objective>
Create the tunnel auto-detection system: a server tool to read wrangler.toml and compute the tunnel URL, a client hook that polls for tunnel reachability, and an instructions component for when the tunnel isn't running.

Purpose: After connecting a project, the preview URL auto-configures without manual entry — the primary UX goal of CONN-02. When the tunnel isn't running, users get clear guidance to start it.
Output: FILESYSTEM_READ_TUNNEL_CONFIG tool + useTunnelDetection hook + TunnelInstructions component + integration into pages list.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-connection-setup/06-01-SUMMARY.md
@packages/mesh-plugin-site-editor/client/lib/use-tunnel-url.ts
@packages/mesh-plugin-site-editor/client/components/pages-list.tsx
@packages/cli/src/lib/config.ts
@apps/mesh/src/tools/filesystem/pick-directory.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FILESYSTEM_READ_TUNNEL_CONFIG tool</name>
  <files>
    apps/mesh/src/tools/filesystem/read-tunnel-config.ts
    apps/mesh/src/tools/filesystem/index.ts
  </files>
  <action>
Create `apps/mesh/src/tools/filesystem/read-tunnel-config.ts`:

1. Import `readFile` from `node:fs/promises`, `join` from `node:path`, `createHash` from `node:crypto`, `z` from `zod`, `defineTool` from `../../core/define-tool`, `requireAuth` from `../../core/mesh-context`.

2. Create helper function to compute tunnel URL (ported from `packages/cli/src/lib/config.ts`):
   ```typescript
   function computeTunnelDomain(workspace: string, app: string): string {
     const hash = createHash("sha1").update(`${workspace}-${app}`).digest("hex").slice(0, 8);
     return `localhost-${hash}.deco.host`;
   }
   ```

3. Define InputSchema: `z.object({ path: z.string().describe("Absolute path to project directory") })`.

4. Define OutputSchema:
   ```typescript
   z.object({
     tunnelUrl: z.string().nullable(),
     workspace: z.string().nullable(),
     app: z.string().nullable(),
     reachable: z.boolean(),
   })
   ```

5. Export `FILESYSTEM_READ_TUNNEL_CONFIG` via `defineTool`:
   - name: `"FILESYSTEM_READ_TUNNEL_CONFIG"`
   - description: `"Read wrangler.toml from a project directory, compute the tunnel URL, and check if it's reachable"`
   - annotations: `{ title: "Read Tunnel Config", readOnlyHint: true, destructiveHint: false, idempotentHint: true, openWorldHint: true }`
   - handler:
     a. `ctx.access.check()` + `requireAuth(ctx)`
     b. Try to read `wrangler.toml` from `join(input.path, "wrangler.toml")`
     c. Parse TOML — use dynamic import `const { parse } = await import("smol-toml")`. Check if `smol-toml` is in apps/mesh/package.json; if not, the executor should add it via `bun add smol-toml` in apps/mesh/.
     d. Extract `workspace` from `config.deco.workspace` and `app` from `config.name`
     e. If no workspace found, return `{ tunnelUrl: null, workspace: null, app: null, reachable: false }`
     f. Compute tunnel URL: `https://${computeTunnelDomain(workspace, app)}`
     g. Check reachability server-side (avoids CORS): `fetch(tunnelUrl, { method: "HEAD", signal: AbortSignal.timeout(5000) })`. If response received (any status), `reachable = true`. If fetch throws, `reachable = false`.
     h. Return `{ tunnelUrl, workspace, app, reachable }`
     i. If wrangler.toml doesn't exist or parse fails, return all nulls + `reachable: false`

6. Add re-export to `apps/mesh/src/tools/filesystem/index.ts`:
   ```typescript
   export { FILESYSTEM_READ_TUNNEL_CONFIG } from "./read-tunnel-config";
   ```

7. Verify tool is registered in SELF MCP tools (same check as plan 01 task 1).
  </action>
  <verify>Run `bun run check` to confirm TypeScript compiles. Grep for `FILESYSTEM_READ_TUNNEL_CONFIG` to confirm export chain.</verify>
  <done>FILESYSTEM_READ_TUNNEL_CONFIG tool reads wrangler.toml, computes deterministic tunnel URL, checks reachability server-side, and returns structured result.</done>
</task>

<task type="auto">
  <name>Task 2: Create tunnel detection hook and instructions component</name>
  <files>
    packages/mesh-plugin-site-editor/client/lib/use-tunnel-detection.ts
    packages/mesh-plugin-site-editor/client/lib/query-keys.ts
    packages/mesh-plugin-site-editor/client/components/tunnel-instructions.tsx
  </files>
  <action>
**Step 1: Add tunnel query key** to `query-keys.ts`:
Add a `tunnel` section to the `queryKeys` object:
```typescript
tunnel: {
  detection: (connectionId: string) =>
    ["site-editor", "tunnel", connectionId] as const,
},
```

**Step 2: Create `use-tunnel-detection.ts`:**

This hook:
- Takes `connectionId` and `projectPath` (the path used during connection)
- Calls `FILESYSTEM_READ_TUNNEL_CONFIG` via SELF MCP to get tunnel URL + reachability
- Polls every 5 seconds while tunnel is not reachable
- When tunnel becomes reachable, persists the URL to connection metadata via `COLLECTION_CONNECTIONS_UPDATE` (same pattern as existing `use-tunnel-url.ts` which reads/writes `metadata.previewUrl`)
- Returns `{ tunnelUrl: string | null, reachable: boolean, isLoading: boolean, noWranglerToml: boolean }`

Implementation:
```typescript
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { useMCPClient, SELF_MCP_ALIAS_ID } from "@decocms/mesh-sdk";
import { queryKeys } from "./query-keys";

interface TunnelConfig {
  tunnelUrl: string | null;
  workspace: string | null;
  app: string | null;
  reachable: boolean;
}

export function useTunnelDetection(opts: {
  connectionId: string;
  projectPath: string;
  orgId: string;
  enabled?: boolean;
}) {
  const { connectionId, projectPath, orgId, enabled = true } = opts;
  const selfClient = useMCPClient({ connectionId: SELF_MCP_ALIAS_ID, orgId });
  const queryClient = useQueryClient();

  const query = useQuery({
    queryKey: queryKeys.tunnel.detection(connectionId),
    queryFn: async (): Promise<TunnelConfig> => {
      const result = await selfClient.callTool({
        name: "FILESYSTEM_READ_TUNNEL_CONFIG",
        arguments: { path: projectPath },
      });
      return (result.structuredContent ?? {
        tunnelUrl: null,
        workspace: null,
        app: null,
        reachable: false,
      }) as TunnelConfig;
    },
    enabled: enabled && !!connectionId && !!projectPath,
    refetchInterval: (query) => {
      const data = query.state.data;
      // Stop polling if: no wrangler.toml (tunnelUrl is null) or tunnel is reachable
      if (!data?.tunnelUrl || data?.reachable) return false;
      return 5000; // Poll every 5s while tunnel URL known but not reachable
    },
    refetchIntervalInBackground: false,
  });

  // When tunnel becomes reachable, persist URL to connection metadata
  // Use a ref to track if we've already persisted to avoid repeated calls
  const data = query.data;
  if (data?.reachable && data.tunnelUrl) {
    // Persist tunnel URL — use a query to avoid useEffect
    // Actually, call this imperatively after query settles
    // The executor should wire this: when data.reachable transitions to true,
    // call COLLECTION_CONNECTIONS_UPDATE to set metadata.previewUrl
    // Use a separate one-time query or handle in the component that consumes this hook
  }

  return {
    tunnelUrl: data?.tunnelUrl ?? null,
    reachable: data?.reachable ?? false,
    isLoading: query.isLoading,
    noWranglerToml: data !== undefined && data.tunnelUrl === null,
  };
}
```

Note: The persistence of tunnel URL should be handled by the consuming component. When `reachable` becomes true and `tunnelUrl` is available, the component calls `COLLECTION_CONNECTIONS_UPDATE` to set `metadata.previewUrl`. Follow the same pattern as the existing `use-tunnel-url.ts` hook for writing to connection metadata. Use a ref to ensure it only persists once.

**Step 3: Create `tunnel-instructions.tsx`:**

A component that shows actionable instructions when the tunnel isn't running:

```tsx
interface TunnelInstructionsProps {
  tunnelUrl: string | null;
  reachable: boolean;
  noWranglerToml: boolean;
  isPolling: boolean;
}
```

Three states:
1. **No wrangler.toml** (`noWranglerToml === true`): Show "Set up your tunnel" heading, explain that the project needs `wrangler.toml` with workspace config, link to docs or suggest running `deco init`.
2. **Has tunnel URL but not reachable** (`tunnelUrl && !reachable`): Show "Start your dev tunnel" heading, display the expected tunnel URL, show command: `deco link` in a code block, show a pulsing dot or spinner indicating "Waiting for tunnel..." — will auto-detect when ready.
3. **Reachable** (`reachable === true`): Don't render anything (parent handles this).

Style: Use a card/alert-style container with muted background. Friendly tone per user decision. Include a `Terminal` or `Code` icon from `@untitledui/icons`.

Run `bun run fmt` after all changes.
  </action>
  <verify>Run `bun run check` to confirm TypeScript compiles. Verify query key added. Verify hook exports correctly. Verify component renders three states.</verify>
  <done>Tunnel detection hook polls server-side tool for reachability, instructions component shows actionable guidance for each state, query key registered.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate tunnel detection into pages list</name>
  <files>
    packages/mesh-plugin-site-editor/client/components/pages-list.tsx
  </files>
  <action>
Integrate the tunnel detection into the pages list view so users see tunnel status after connecting:

1. Read the current `pages-list.tsx` to understand its structure and props.

2. Import `useTunnelDetection` from `../lib/use-tunnel-detection` and `TunnelInstructions` (default import) from `./tunnel-instructions`.

3. The pages list component needs access to:
   - `connectionId` (should already be available from context/props)
   - `projectPath` — this needs to be stored somewhere after connection. Check if it's in the connection entity's `connection_headers.args` (the last arg to `@modelcontextprotocol/server-filesystem` is the path). Extract it from there: `connection.connection_headers?.args?.at(-1)`.
   - `orgId` (from `useProjectContext`)

4. Call `useTunnelDetection` with these params. Check the existing `use-tunnel-url.ts` hook — if the connection already has `metadata.previewUrl` set, skip tunnel detection (already configured).

5. Show `TunnelInstructions` component above the pages list when tunnel is not yet configured and not reachable. Once reachable:
   - Persist the tunnel URL to connection metadata (call `COLLECTION_CONNECTIONS_UPDATE` via selfClient to set `metadata.previewUrl = tunnelUrl`)
   - Invalidate the connection queries so `use-tunnel-url.ts` picks up the new URL
   - Hide the instructions

6. Use a ref to ensure the persistence call only happens once (avoid repeated writes on re-renders).

7. The tunnel instructions should appear as a dismissible banner/card at the top of the pages list, NOT replacing the pages list. Users can still manage pages while the tunnel isn't set up.

8. Run `bun run fmt` after changes.
  </action>
  <verify>Run `bun run check` to confirm TypeScript compiles. Verify tunnel detection activates after connection exists. Verify instructions render when tunnel not detected. Verify URL persists to connection metadata when tunnel becomes reachable.</verify>
  <done>Pages list shows tunnel instructions when preview URL not configured, auto-detects tunnel in background, persists URL on detection, and hides instructions once configured.</done>
</task>

</tasks>

<verification>
1. `bun run check` passes (TypeScript compiles)
2. `bun run fmt` has been run
3. FILESYSTEM_READ_TUNNEL_CONFIG reads wrangler.toml, computes tunnel domain matching CLI's algorithm, checks reachability server-side
4. useTunnelDetection hook polls every 5s while tunnel not reachable, stops on detection
5. TunnelInstructions shows "run deco link" guidance when tunnel not running
6. Detected tunnel URL auto-persists to connection metadata.previewUrl
7. Projects without wrangler.toml see setup guidance instead of errors
</verification>

<success_criteria>
- After connection creation, plugin reads wrangler.toml and computes expected tunnel URL
- If tunnel is running, URL auto-configures in preview panel without manual entry
- If tunnel is not running, clear "run deco link" instructions appear with the expected URL
- Background polling detects tunnel when it starts, auto-configures preview
- Projects without wrangler.toml gracefully fall back to manual setup guidance
- Tunnel URL persists across sessions via connection metadata
</success_criteria>

<output>
After completion, create `.planning/phases/06-connection-setup/06-02-SUMMARY.md`
</output>
