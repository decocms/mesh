---
phase: 07-sections-page
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mesh-plugin-site-editor/client/components/sections-list.tsx
autonomous: true

must_haves:
  truths:
    - "User can view a list of all scanned blocks grouped by collapsible categories in a table-rows layout"
    - "Each block row shows name, category tag, and component file path"
    - "Clicking a block row navigates to the block detail page"
    - "User can trigger a codebase re-scan that refreshes the block list"
    - "Empty state shows 'Scan Codebase' button that actually triggers CMS_BLOCK_SCAN"
    - "Re-scan button appears in header when blocks already exist"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/components/sections-list.tsx"
      provides: "Table-rows block list with collapsible categories and scan trigger"
      contains: "CMS_BLOCK_SCAN"
  key_links:
    - from: "sections-list.tsx"
      to: "CMS_BLOCK_SCAN"
      via: "selfClient.callTool via useMCPClient(SELF_MCP_ALIAS_ID)"
      pattern: "selfClient\\.callTool.*CMS_BLOCK_SCAN"
    - from: "sections-list.tsx"
      to: "block-api.ts"
      via: "listBlocks(toolCaller) in useQuery"
      pattern: "listBlocks\\(toolCaller\\)"
    - from: "sections-list.tsx scan onSuccess"
      to: "blockKeys.all"
      via: "queryClient.invalidateQueries after scan"
      pattern: "invalidateQueries.*blockKeys\\.all"
---

<objective>
Refactor the sections list from a card-style button layout to a dense table-rows layout grouped by collapsible categories, and wire the scan trigger to actually call CMS_BLOCK_SCAN.

Purpose: Users need a dense, scannable block browser and a working scan trigger to discover components from their codebase.
Output: Refactored sections-list.tsx with table layout, collapsible categories, and working scan/re-scan functionality.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-sections-page/07-RESEARCH.md
@packages/mesh-plugin-site-editor/client/components/sections-list.tsx
@packages/mesh-plugin-site-editor/client/components/pages-list.tsx
@packages/mesh-plugin-site-editor/client/lib/block-api.ts
@packages/mesh-plugin-site-editor/client/lib/query-keys.ts
@packages/ui/src/components/table.tsx
@packages/ui/src/components/collapsible.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor sections-list to table-rows with collapsible categories and scan trigger</name>
  <files>packages/mesh-plugin-site-editor/client/components/sections-list.tsx</files>
  <action>
Refactor the entire sections-list.tsx component. This is a single-file refactor touching one component.

**Imports to add:**
- `{ Table, TableBody, TableCell, TableHead, TableHeader, TableRow }` from `@deco/ui/components/table.tsx`
- `{ Collapsible, CollapsibleContent, CollapsibleTrigger }` from `@deco/ui/components/collapsible.tsx`
- `{ ChevronDown, ChevronRight, RefreshCw }` from `lucide-react`
- `{ useMutation, useQueryClient }` from `@tanstack/react-query` (add to existing import)
- `{ SELF_MCP_ALIAS_ID, useMCPClient, useProjectContext }` from `@decocms/mesh-sdk`
- `{ toast }` from `sonner`

**Self MCP client setup (inside component body):**
```typescript
const { org } = useProjectContext();
const selfClient = useMCPClient({
  connectionId: SELF_MCP_ALIAS_ID,
  orgId: org.id,
});
const queryClient = useQueryClient();
```

**Scan mutation:**
```typescript
const scanMutation = useMutation({
  mutationFn: () =>
    selfClient.callTool({
      name: "CMS_BLOCK_SCAN",
      arguments: { connectionId },
    }),
  onSuccess: () => {
    toast.success("Codebase scan complete");
    queryClient.invalidateQueries({
      queryKey: blockKeys.all(connectionId),
    });
  },
  onError: (err: unknown) => {
    toast.error(`Scan failed: ${err instanceof Error ? err.message : "Unknown error"}`);
  },
});
```

**Header bar changes:**
- Keep "Sections" title and block count badge
- Add a "Re-scan" button (only when `blocks.length > 0`) using `RefreshCw` icon with text "Re-scan"
- Button shows spinner (Loading01 icon with animate-spin) when `scanMutation.isPending`
- Button is disabled when `scanMutation.isPending`
- `onClick={() => scanMutation.mutate()}`

**Empty state changes (blocks.length === 0):**
- Keep the existing empty state structure but replace the placeholder `console.log` onClick with `() => scanMutation.mutate()`
- Show Loading01 spinner instead of Search icon when `scanMutation.isPending`
- Change button text to "Scanning..." when pending, "Scan Codebase" when idle
- Disable button when pending

**Block list layout -- replace the current button-per-block with table-rows grouped by collapsible categories:**

Per user's locked decision: table rows layout, grouped by category (collapsible), columns: block name, category tag, component file path. Clicking a row navigates to detail.

For each category in `categoryNames`, render a `Collapsible` (defaultOpen):
```tsx
<Collapsible key={category} defaultOpen>
  <CollapsibleTrigger className="flex items-center gap-2 w-full px-4 py-2 text-xs font-medium text-muted-foreground uppercase tracking-wider bg-muted/30 border-b border-border hover:bg-muted/50 transition-colors">
    {/* Chevron rotates based on open state -- use data-[state=open] and data-[state=closed] CSS selectors */}
    <ChevronRight size={14} className="shrink-0 transition-transform data-[state=open]:hidden" />
    <ChevronDown size={14} className="shrink-0 transition-transform data-[state=closed]:hidden" />
    {category}
    <Badge variant="secondary" className="text-xs ml-auto">{grouped[category].length}</Badge>
  </CollapsibleTrigger>
  <CollapsibleContent>
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead className="text-xs">Name</TableHead>
          <TableHead className="text-xs">Category</TableHead>
          <TableHead className="text-xs">Component</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {grouped[category].map((block) => (
          <TableRow
            key={block.id}
            className="cursor-pointer hover:bg-muted/50"
            onClick={() => navigate({
              to: "/site-editor-layout/sections/$blockId",
              params: { blockId: block.id },
            })}
          >
            <TableCell className="text-sm font-medium">{block.label}</TableCell>
            <TableCell>
              <Badge variant="outline" className="text-xs">{block.category}</Badge>
            </TableCell>
            <TableCell className="text-xs text-muted-foreground font-mono">{block.component}</TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  </CollapsibleContent>
</Collapsible>
```

**Note on Collapsible chevron:** The Radix Collapsible sets `data-state="open"` or `data-state="closed"` on the trigger. However, the chevron icons are children, not the trigger itself. A simpler approach: render both chevrons and use CSS to show/hide based on the parent's state. Alternatively, track open state with a local state variable per category. Use whichever approach works cleanly -- the important thing is the visual cue of expand/collapse.

A practical approach: since Collapsible doesn't expose open state to children easily, consider managing open state manually with a `Set<string>` of open categories (all open by default). Toggle on trigger click. Use `open` prop on `Collapsible` instead of `defaultOpen` for controlled mode. This is simpler and avoids CSS hacks.

**Remove unused imports:** `Box` from lucide-react (no longer used in the refactored layout).

**Keep `groupByCategory` helper function** as-is -- it already works correctly.
  </action>
  <verify>
Run `bun run check` from repo root to ensure TypeScript compiles. Run `bun run fmt` to format. Run `bun run lint` to check for lint violations. Visually inspect the component renders: loading state shows spinner, empty state shows scan button, populated state shows table rows grouped by collapsible categories with re-scan button in header.
  </verify>
  <done>
Sections list renders blocks in a dense table-rows layout grouped by collapsible categories. Each row shows block name, category badge, and component path. Clicking a row navigates to `/sections/$blockId`. Empty state has a working "Scan Codebase" button that calls CMS_BLOCK_SCAN via selfClient. Header has a "Re-scan" button when blocks exist. Scan success invalidates block query cache and shows toast. Scan failure shows error toast.
  </done>
</task>

</tasks>

<verification>
1. `bun run check` passes with no TypeScript errors
2. `bun run fmt` completes successfully
3. `bun run lint` passes (no useEffect, no memoization, query key constants used)
4. Sections list imports from @deco/ui table and collapsible components
5. CMS_BLOCK_SCAN is called via selfClient (SELF_MCP_ALIAS_ID), not through toolCaller
6. Query cache is invalidated after successful scan via blockKeys.all(connectionId)
</verification>

<success_criteria>
- Table-rows layout renders blocks grouped by collapsible categories
- Scan trigger calls CMS_BLOCK_SCAN and refreshes block list on success
- Re-scan button visible in header when blocks exist
- Empty state shows scan prompt with working button
- All lint/type checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-sections-page/07-01-SUMMARY.md`
</output>
