---
phase: 07-sections-page
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mesh-plugin-site-editor/client/components/block-detail.tsx
  - packages/mesh-plugin-site-editor/client/components/schema-tree.tsx
autonomous: true

must_haves:
  truths:
    - "User can view a block detail page with two-column layout: schema tree on left, prop editor on right"
    - "Schema tree displays JSON Schema properties as an interactive collapsible tree"
    - "Prop editor form is pre-filled with default prop values from the block definition"
    - "Malformed schema falls back to raw JSON with syntax highlighting and error note"
    - "Component file path is shown as plain text (not a link)"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/components/schema-tree.tsx"
      provides: "Recursive collapsible JSON Schema tree viewer"
      contains: "SchemaTree"
    - path: "packages/mesh-plugin-site-editor/client/components/block-detail.tsx"
      provides: "Two-column block detail with schema tree and prop editor"
      contains: "SchemaTree"
  key_links:
    - from: "block-detail.tsx"
      to: "schema-tree.tsx"
      via: "import SchemaTree component"
      pattern: "import.*SchemaTree.*schema-tree"
    - from: "block-detail.tsx"
      to: "prop-editor.tsx"
      via: "PropEditor with formData from block.defaults"
      pattern: "PropEditor.*schema.*formData"
    - from: "block-detail.tsx"
      to: "block-api.ts"
      via: "getBlock(toolCaller, blockId) in useQuery"
      pattern: "getBlock\\(toolCaller"
---

<objective>
Create a recursive collapsible schema tree component and refactor the block detail view to a two-column layout with schema tree on the left and live prop editor on the right.

Purpose: Users need to understand a block's schema structure and test its prop editor in a side-by-side view.
Output: New schema-tree.tsx component and refactored block-detail.tsx with two-column layout.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-sections-page/07-RESEARCH.md
@packages/mesh-plugin-site-editor/client/components/block-detail.tsx
@packages/mesh-plugin-site-editor/client/components/prop-editor.tsx
@packages/mesh-plugin-site-editor/client/lib/block-api.ts
@packages/ui/src/components/collapsible.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create recursive collapsible schema tree component</name>
  <files>packages/mesh-plugin-site-editor/client/components/schema-tree.tsx</files>
  <action>
Create a new component `schema-tree.tsx` that renders a JSON Schema as an interactive collapsible tree.

**Imports:**
- `{ useState }` from `react`
- `{ Collapsible, CollapsibleContent, CollapsibleTrigger }` from `@deco/ui/components/collapsible.tsx`
- `{ Badge }` from `@deco/ui/components/badge.tsx`
- `{ ChevronDown, ChevronRight }` from `lucide-react`

**Interface:**
```typescript
interface SchemaTreeProps {
  schema: Record<string, unknown>;
  name?: string;
  depth?: number;
  required?: string[];
}
```

**Implementation details:**

1. **$ref resolution:** Before rendering, resolve `$ref` pointers. Create a helper function `resolveRef(schema, rootSchema)` that:
   - If schema has `$ref`, look it up in `rootSchema.$defs` (strip the `#/$defs/` prefix)
   - Return the resolved schema
   - Track visited refs in a Set to prevent infinite recursion -- if already visited, return `{ type: "object", description: "[circular reference]" }` instead

2. **Root export:** Export a default `SchemaTree` component that accepts `{ schema: Record<string, unknown> }` and renders the recursive tree with `rootSchema` passed through for $ref resolution.

3. **Internal recursive component** `SchemaNode`:
   - Props: `{ schema, name, depth, required, rootSchema, visitedRefs }`
   - Resolve $ref first using `resolveRef`
   - **Max depth limit:** 5 levels. Beyond that, show "..." with a type badge
   - **Leaf nodes** (string, number, boolean, or no properties): Render a single row with:
     - Indentation based on depth (use `pl-{n}` where n scales with depth, e.g., `style={{ paddingLeft: depth * 16 }}`)
     - Property name in medium weight
     - Type badge (e.g., `<Badge variant="outline" className="text-xs">string</Badge>`)
     - Required indicator: small red asterisk or "(required)" text if the property name is in the parent's `required` array
     - Description text if present, in muted color below the name
   - **Object nodes** (type === "object" with properties): Render a `Collapsible`:
     - Default open for depth < 2, closed for deeper
     - Trigger shows: property name + type badge "object" + property count
     - Content: recursively render each property from `schema.properties`
     - Pass `schema.required` array down to children
   - **Array nodes** (type === "array" with items): Render a `Collapsible`:
     - Trigger shows: property name + type badge "array" + items type
     - Content: recursively render `schema.items` as a single child node named "[items]"

4. **Styling:**
   - Use subtle left border (`border-l border-border`) for nested levels to show tree structure
   - Compact spacing (py-1 px-2 per node)
   - Type badges use different colors per type: string=default, number=blue variant, boolean=green variant, object=purple variant, array=orange variant. Use Badge variant="outline" with a className for color -- keep it simple, just the outline variant is fine if color variants aren't worth the complexity.

5. **Malformed schema handling:** If the root schema has no `type` or no `properties`, the component still renders something useful -- show a "Schema structure" header and whatever properties exist. If completely empty, show a message "No schema properties defined."

**Do NOT use useEffect or useMemo/useCallback/memo** (banned by lint rules).
  </action>
  <verify>
Run `bun run check` to verify TypeScript compiles. Run `bun run lint` to check for banned patterns (useEffect, memoization). The component should handle: simple flat schemas, nested object schemas, array schemas, schemas with $ref/$defs, schemas with circular references (graceful fallback), and empty schemas.
  </verify>
  <done>
SchemaTree component renders JSON Schema as an interactive collapsible tree. Object/array nodes are collapsible. Leaf nodes show type badges. $ref pointers are resolved from $defs with circular reference protection. Max depth of 5 prevents infinite nesting. Required properties are marked.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor block-detail to two-column layout with schema tree and prop editor</name>
  <files>packages/mesh-plugin-site-editor/client/components/block-detail.tsx</files>
  <action>
Refactor block-detail.tsx from the current single-column layout to a two-column layout per user's locked decision.

**New import:**
- `import SchemaTree from "./schema-tree";`

**Remove:**
- The `schemaExpanded` state and `setSchemaExpanded` -- no longer needed (schema tree replaces the collapsible raw JSON section)
- `ChevronDown`, `ChevronRight` imports from lucide-react (no longer used here)

**Layout changes -- replace the current `<div className="flex-1 overflow-y-auto p-6">` section:**

Keep the header breadcrumb as-is.

Below the header, replace the single-column max-w-2xl content with:

```tsx
<div className="flex-1 overflow-hidden">
  {/* Block info bar -- spans full width */}
  <div className="px-6 py-4 border-b border-border">
    <h2 className="text-xl font-semibold">{block.label}</h2>
    <p className="text-sm text-muted-foreground mt-1">{block.component}</p>
    {block.description && (
      <p className="text-sm text-muted-foreground mt-2">{block.description}</p>
    )}
    {/* Metadata inline: scan method badge, scanned date, props type, props count */}
    <div className="flex items-center gap-4 mt-3 text-xs text-muted-foreground">
      <Badge variant="secondary" className="text-xs">
        {scanMethodLabel(block.metadata.scanMethod)}
      </Badge>
      <span>Scanned {formatTimestamp(block.metadata.scannedAt)}</span>
      {block.metadata.propsTypeName && (
        <span className="font-mono">{block.metadata.propsTypeName}</span>
      )}
      <span>{propsCount} props</span>
    </div>
  </div>

  {/* Two-column layout */}
  <div className="grid grid-cols-1 lg:grid-cols-2 h-[calc(100%-theme(spacing.28))] divide-x divide-border">
    {/* Left column: Schema tree */}
    <div className="overflow-y-auto p-4">
      <h3 className="text-sm font-medium mb-3">Schema</h3>
      {hasValidSchema ? (
        <SchemaTree schema={block.schema as Record<string, unknown>} />
      ) : (
        <div>
          <p className="text-sm text-amber-600 mb-2">
            Schema could not be rendered as a tree. Showing raw JSON.
          </p>
          <pre className="text-xs font-mono bg-muted/30 rounded p-3 max-h-80 overflow-auto">
            {JSON.stringify(block.schema, null, 2)}
          </pre>
        </div>
      )}
    </div>

    {/* Right column: Prop editor */}
    <div className="overflow-y-auto p-4">
      <h3 className="text-sm font-medium mb-3">Props Editor</h3>
      {hasValidSchema ? (
        <PropEditor
          schema={block.schema as any}
          formData={formData}
          onChange={setFormData}
        />
      ) : hasSchema ? (
        <div>
          <p className="text-sm text-amber-600 mb-2">
            Schema could not be rendered as a form. Showing raw JSON.
          </p>
          <pre className="text-xs font-mono bg-muted/30 rounded p-3 max-h-80 overflow-auto">
            {JSON.stringify(block.schema, null, 2)}
          </pre>
        </div>
      ) : (
        <p className="text-sm text-muted-foreground text-center py-8">
          No schema available for this block.
        </p>
      )}
    </div>
  </div>
</div>
```

**Schema validation logic:**
```typescript
const hasSchema = block.schema && typeof block.schema === "object" && Object.keys(block.schema).length > 0;
const hasValidSchema = hasSchema && block.schema.type === "object" && block.schema.properties;
```

Use `hasValidSchema` to decide between SchemaTree/PropEditor vs raw JSON fallback. Per user decision: malformed schema falls back to raw JSON with syntax highlighting + error note.

**Component file path:** Already shown as plain text in the info bar (`block.component`). Per user decision, no clickable link. This is already the case.

**Remove the old metadata grid section** (the bordered card with grid-cols-2). Metadata is now condensed into the inline info bar.

**Remove the old "Raw JSON Schema" collapsible section.** The schema tree replaces it.

**Keep:** Loading state, error state, not-found state, back button, breadcrumb, formData ref-based sync pattern. All unchanged.
  </action>
  <verify>
Run `bun run check` to verify TypeScript compiles. Run `bun run fmt` to format. Run `bun run lint` to check for violations. Verify the two-column layout renders: left column has SchemaTree, right column has PropEditor. Malformed schemas show raw JSON fallback with error note. Component stacks to single column on mobile (grid-cols-1 default).
  </verify>
  <done>
Block detail view shows a two-column layout: collapsible schema tree on the left, live prop editor form on the right. Block info bar at top shows label, component path (plain text), description, and condensed metadata. Malformed schemas fall back to raw JSON with amber warning note. Form is pre-filled with block defaults. Layout is responsive (single column on small screens, two columns on lg+).
  </done>
</task>

</tasks>

<verification>
1. `bun run check` passes with no TypeScript errors
2. `bun run fmt` completes successfully
3. `bun run lint` passes (no useEffect, no memoization, kebab-case filenames)
4. schema-tree.tsx exists and exports a SchemaTree component
5. block-detail.tsx imports and renders SchemaTree in left column
6. block-detail.tsx renders PropEditor in right column with formData from block.defaults
7. Malformed schema shows raw JSON with amber error note (not a crash)
8. $ref resolution handles circular references without stack overflow
</verification>

<success_criteria>
- Two-column layout on block detail page (schema tree left, prop editor right)
- Schema tree renders JSON Schema as interactive collapsible tree with type badges
- Prop editor pre-filled with default values
- Malformed schema gracefully falls back to raw JSON
- Responsive layout stacks on mobile
- All lint/type checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-sections-page/07-02-SUMMARY.md`
</output>
