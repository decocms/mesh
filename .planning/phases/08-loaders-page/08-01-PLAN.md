---
phase: 08-loaders-page
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mesh-plugin-site-editor/client/lib/loader-api.ts
  - packages/mesh-plugin-site-editor/client/lib/query-keys.ts
  - packages/mesh-plugin-site-editor/client/components/loaders-list.tsx
  - packages/mesh-plugin-site-editor/client/components/loader-detail.tsx
autonomous: true

must_haves:
  truths:
    - "User can view a table-rows list of all loaders grouped by collapsible categories with Name, Source, Sections, and Params columns"
    - "User can see which sections consume each loader inline in the list (first 2 names + '+N more' truncation, or 'No sections' in muted gray)"
    - "User can trigger a loader re-scan from the list header and see the list auto-refresh after scan completes"
    - "User can navigate to a loader detail view with breadcrumb 'Loaders / {LoaderName}'"
    - "Loader detail shows output schema tree in left column and input parameters PropEditor (readonly) in right column"
    - "Loader detail shows connected sections as an expandable badge count in the metadata bar"
    - "Empty state shows icon + 'No loaders found' + 'Scan Codebase' button that triggers CMS_LOADER_SCAN"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/lib/loader-api.ts"
      provides: "computeLoaderSectionMap helper for cross-referencing pages to find loader consumers"
      contains: "computeLoaderSectionMap"
    - path: "packages/mesh-plugin-site-editor/client/lib/query-keys.ts"
      provides: "sectionMap query key for caching connected sections data"
      contains: "sectionMap"
    - path: "packages/mesh-plugin-site-editor/client/components/loaders-list.tsx"
      provides: "Table-rows loader list with collapsible categories, scan trigger, connected sections column"
    - path: "packages/mesh-plugin-site-editor/client/components/loader-detail.tsx"
      provides: "Two-column loader detail with SchemaTree left, PropEditor right, connected sections badge"
  key_links:
    - from: "loaders-list.tsx"
      to: "CMS_LOADER_SCAN via selfClient"
      via: "useMutation with useMCPClient(SELF_MCP_ALIAS_ID)"
      pattern: "selfClient\\.callTool.*CMS_LOADER_SCAN"
    - from: "loaders-list.tsx"
      to: "loader-api.ts computeLoaderSectionMap"
      via: "useQuery with loaderKeys.sectionMap"
      pattern: "loaderKeys\\.sectionMap"
    - from: "loader-detail.tsx"
      to: "schema-tree.tsx SchemaTree"
      via: "import and render with outputSchema"
      pattern: "SchemaTree.*outputSchema"
    - from: "loader-detail.tsx"
      to: "prop-editor.tsx PropEditor"
      via: "import and render with inputSchema in readonly mode"
      pattern: "PropEditor.*readonly"
---

<objective>
Upgrade loaders list and detail views to match Phase 7's sections page quality: table-rows with collapsible categories, connected sections column, scan trigger via CMS_LOADER_SCAN, and two-column detail layout with SchemaTree and PropEditor.

Purpose: Users can browse loaders with the same dense, scannable UI as sections, see which sections consume each loader, and inspect loader schemas in a structured two-column view.
Output: Rewritten loaders-list.tsx and loader-detail.tsx, extended loader-api.ts with connected sections helper, extended query-keys.ts with sectionMap key.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-loaders-page/08-RESEARCH.md

# Reference patterns (read these for exact copy-adapt patterns)
@packages/mesh-plugin-site-editor/client/components/sections-list.tsx
@packages/mesh-plugin-site-editor/client/components/block-detail.tsx
@packages/mesh-plugin-site-editor/client/lib/loader-api.ts
@packages/mesh-plugin-site-editor/client/lib/query-keys.ts
@packages/mesh-plugin-site-editor/client/lib/page-api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add connected sections helper and query key</name>
  <files>
    packages/mesh-plugin-site-editor/client/lib/loader-api.ts
    packages/mesh-plugin-site-editor/client/lib/query-keys.ts
  </files>
  <action>
**loader-api.ts** -- Add `computeLoaderSectionMap()` function at the end of the file:

1. Import `listPages` and `getPage` from `./page-api` (these already exist).
2. Import `isLoaderRef` from `./page-api` (already exists).
3. Create `computeLoaderSectionMap(toolCaller: ToolCaller): Promise<Map<string, string[]>>`:
   - Call `listPages(toolCaller)` to get all page summaries.
   - For each page summary, call `getPage(toolCaller, pageSummary.id)` to get the full page with blocks.
   - For each block in `page.blocks`, iterate `Object.entries(block.props)` and check each value with `isLoaderRef(value)`.
   - When a LoaderRef is found, extract `value.__loaderRef` as the loaderId.
   - Derive the section name from `block.blockType` by replacing `"sections--"` prefix and `"--"` separators with `"/"`. Example: `"sections--Hero"` becomes `"Hero"`, `"sections--layout--Header"` becomes `"layout/Header"`.
   - Add the section name to the map entry for that loaderId (deduplicated -- only add if not already present).
   - Return the completed Map.
4. Export the function.

**query-keys.ts** -- Add `sectionMap` key to the `loaders` section:

In the `queryKeys.loaders` object, add:
```typescript
sectionMap: (connectionId: string) =>
  ["site-editor", "loaders", connectionId, "sectionMap"] as const,
```

Also add to the `loaderKeys` shorthand (it already aliases `queryKeys.loaders`, so this is automatic).

NOTE: `listPages` returns `PageSummary[]` with `id` field. `getPage` returns `Page | null` with `blocks: BlockInstance[]` where each BlockInstance has `blockType: string` and `props: Record<string, unknown>`. Check page-api.ts for exact types if needed.
  </action>
  <verify>
Run `bun run check` from the repo root to confirm TypeScript types are valid. Verify the new function is exported and the query key is accessible.
  </verify>
  <done>
`computeLoaderSectionMap` exists in loader-api.ts, is exported, takes a ToolCaller, and returns `Promise<Map<string, string[]>>`. The `loaderKeys.sectionMap(connectionId)` query key exists in query-keys.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite loaders-list.tsx and loader-detail.tsx</name>
  <files>
    packages/mesh-plugin-site-editor/client/components/loaders-list.tsx
    packages/mesh-plugin-site-editor/client/components/loader-detail.tsx
  </files>
  <action>
**loaders-list.tsx** -- Full rewrite to match sections-list.tsx pattern:

1. **Imports:** Copy the import set from sections-list.tsx. Replace block-specific imports with loader equivalents:
   - `listBlocks` -> `listLoaders` from `../lib/loader-api`
   - `blockKeys` -> `loaderKeys` from `../lib/query-keys`
   - `BlockSummary` -> `LoaderSummary` from `../lib/loader-api`
   - Add import of `computeLoaderSectionMap` from `../lib/loader-api`
   - Keep: `SELF_MCP_ALIAS_ID`, `useMCPClient`, `useProjectContext` from `@decocms/mesh-sdk`
   - Keep: `useMutation`, `useQueryClient` from `@tanstack/react-query`
   - Keep: `Table`, `TableBody`, `TableCell`, `TableHead`, `TableHeader`, `TableRow` from `@deco/ui`
   - Keep: `Collapsible`, `CollapsibleContent`, `CollapsibleTrigger` from `@deco/ui`
   - Keep: `toast` from `sonner`
   - Keep: `ChevronDown`, `ChevronRight`, `RefreshCw`, `Search` from `lucide-react`

2. **groupByCategory:** Keep existing function, it already works for LoaderSummary.

3. **Component body:**
   - Get `org` from `useProjectContext()` and create `selfClient` with `useMCPClient({ connectionId: SELF_MCP_ALIAS_ID, orgId: org.id })`.
   - Get `queryClient` from `useQueryClient()`.
   - Query loaders list: `useQuery({ queryKey: loaderKeys.all(connectionId), queryFn: () => listLoaders(toolCaller) })`.
   - Query connected sections map: `useQuery({ queryKey: loaderKeys.sectionMap(connectionId), queryFn: () => computeLoaderSectionMap(toolCaller) })`. Store result as `sectionMap` (default to `new Map()`).
   - Scan mutation: `useMutation({ mutationFn: () => selfClient.callTool({ name: "CMS_LOADER_SCAN", arguments: { connectionId } }), onSuccess: () => { toast.success("Loader scan complete"); queryClient.invalidateQueries({ queryKey: loaderKeys.all(connectionId) }); }, onError: ... })`.
   - `openCategories` state: `useState<Set<string>>(() => new Set(categoryNames))` with `toggleCategory` function. Same pattern as sections-list.tsx.
   - Error state: Same as sections-list.tsx but with "Error loading loaders" text.

4. **Render -- Header:** Same pattern as sections-list.tsx header. Show "Loaders" title + badge showing count + "Re-scan" button when loaders.length > 0.

5. **Render -- Table columns:** Four columns: Name, Source, Sections, Params.
   - **Name**: `<TableCell className="text-sm font-medium">{loader.label}</TableCell>`
   - **Source**: `<TableCell className="text-xs text-muted-foreground font-mono">{loader.source}</TableCell>`
   - **Sections**: Lookup `sectionMap.get(loader.id) ?? []` for connected sections. When length === 0, show `<span className="text-muted-foreground">No sections</span>`. Otherwise show first 2 names joined with ", " and if length > 2, append `<span className="text-muted-foreground ml-1">+{length - 2} more</span>`.
   - **Params**: `<TableCell><Badge variant="outline" className="text-xs">{loader.inputParamsCount} params</Badge></TableCell>`

6. **Render -- Empty state:** Same as sections-list.tsx but with "No loaders found" text and "Scan your codebase to discover data loaders..." description. Scan button calls `scanMutation.mutate()`.

7. **Render -- Loading state:** Same spinner as sections-list.tsx with "Loading loaders..." text.

8. **Row click:** Navigate to `/site-editor-layout/loaders/$loaderId` with `params: { loaderId: loader.id }`.

**loader-detail.tsx** -- Full rewrite to match block-detail.tsx two-column pattern:

1. **Imports:** Start from block-detail.tsx imports. Replace block-specific imports with loader equivalents:
   - `getBlock` -> `getLoader` from `../lib/loader-api`
   - `blockKeys` -> `loaderKeys` from `../lib/query-keys`
   - Add import of `computeLoaderSectionMap` from `../lib/loader-api`
   - Add import of `SchemaTree` from `./schema-tree`
   - Keep `PropEditor` import
   - Add `ChevronDown`, `ChevronRight` from `lucide-react` (for expandable sections badge)

2. **Helper functions:** Keep `formatTimestamp` and `scanMethodLabel` from current loader-detail.tsx.

3. **Component body:**
   - Get `toolCaller`, `connectionId` from plugin context. Get `loaderId` from router params (from `/site-editor-layout/loaders/$loaderId`).
   - Query loader detail: `useQuery({ queryKey: loaderKeys.detail(connectionId, loaderId), queryFn: () => getLoader(toolCaller, loaderId) })`.
   - Query connected sections: `useQuery({ queryKey: loaderKeys.sectionMap(connectionId), queryFn: () => computeLoaderSectionMap(toolCaller), select: (map) => map.get(loaderId) ?? [] })`. This reuses the same cache key as the list, and uses `select` to extract just this loader's sections.
   - `formData` state with ref-based sync: Same pattern as block-detail.tsx. Use `lastSyncedLoaderId` ref.
   - `sectionsExpanded` state: `useState(false)` for expandable connected sections badge.

4. **Render -- Breadcrumb header:** Same pattern as block-detail.tsx. Show "Loaders / {loader.label}" with Loaders being a clickable link to `/site-editor-layout/loaders`.

5. **Render -- Info bar:** Full-width bar below breadcrumb (same as block-detail.tsx):
   - Title: `loader.label`
   - Subtitle: `loader.source`
   - Description: `loader.description` (if present)
   - Metadata row: scan method badge, scanned timestamp, propsTypeName (if present), returnTypeName (if present), input params count.
   - Connected sections badge: A clickable `<button>` showing `<Badge variant="secondary" className="text-xs">{connectedSections.length} sections</Badge>` with a chevron icon. On click, toggle `sectionsExpanded`.
   - When `sectionsExpanded && connectedSections.length > 0`, show a `<div className="flex flex-wrap gap-1.5 mt-2">` with `<Badge variant="outline" className="text-xs">` for each section name.

6. **Render -- Two-column layout:** Same grid as block-detail.tsx: `<div className="grid grid-cols-1 lg:grid-cols-2 h-[calc(100%-7rem)] divide-x divide-border">`.
   - **Left column (Output Schema):** Title "Output Schema". Render `<SchemaTree schema={loader.outputSchema} />` if outputSchema is valid (type=object with properties). Otherwise show raw JSON fallback.
   - **Right column (Input Parameters):** Title "Input Parameters". Render `<PropEditor schema={loader.inputSchema} formData={formData} onChange={setFormData} readonly />` if inputSchema is valid and has properties. Otherwise show "This loader has no input parameters." message.

7. **Loading/Error/Not-found states:** Same patterns as block-detail.tsx but with "loader" text. "Back to Loaders" button navigates to `/site-editor-layout/loaders`.

**IMPORTANT CONSTRAINTS:**
- Do NOT use useEffect (banned by lint rule). Use ref-based sync pattern.
- Do NOT use useMemo/useCallback/memo (banned by lint rule).
- Use `cn()` for conditional classNames if needed (import from appropriate location, check how sections-list.tsx or block-detail.tsx handle conditional classes).
- Use `CMS_LOADER_SCAN` (NOT CMS_BLOCK_SCAN) for the scan mutation. This is a correction to the context decision -- the codebase has separate scan tools.
  </action>
  <verify>
1. Run `bun run check` to confirm TypeScript compilation passes.
2. Run `bun run fmt` to format code with Biome.
3. Run `bun run lint` to verify no useEffect, useMemo, or other banned patterns.
4. Visually confirm loaders-list.tsx has: Table/Collapsible imports, four TableHead columns (Name, Source, Sections, Params), scanMutation with CMS_LOADER_SCAN, sectionMap query.
5. Visually confirm loader-detail.tsx has: SchemaTree import, PropEditor with readonly, two-column grid layout, connected sections badge with expandable state.
  </verify>
  <done>
loaders-list.tsx renders a table-rows layout with collapsible categories, four columns (Name, Source, Sections, Params), connected sections inline display with truncation, working CMS_LOADER_SCAN scan trigger via selfClient, and matching empty/loading/error states. loader-detail.tsx renders a two-column layout with SchemaTree on left for outputSchema, readonly PropEditor on right for inputSchema, breadcrumb navigation, metadata bar with expandable connected sections badge, and proper loading/error/not-found states.
  </done>
</task>

</tasks>

<verification>
1. `bun run check` passes with no TypeScript errors
2. `bun run fmt` completes without changes (code already formatted)
3. `bun run lint` passes with no violations (no useEffect, no useMemo, etc.)
4. loaders-list.tsx has collapsible categories with Table component (not card/button layout)
5. loaders-list.tsx has exactly 4 column headers: Name, Source, Sections, Params
6. loaders-list.tsx calls CMS_LOADER_SCAN (not CMS_BLOCK_SCAN)
7. loader-detail.tsx has grid grid-cols-2 two-column layout
8. loader-detail.tsx imports and renders SchemaTree and PropEditor
9. loader-detail.tsx PropEditor has readonly prop
10. query-keys.ts has sectionMap key under loaders
</verification>

<success_criteria>
The loaders page matches the quality and patterns of the Phase 7 sections page: dense table-rows with collapsible categories, connected sections column showing which sections consume each loader, working scan trigger, and a two-column detail view with output schema tree and readonly input parameters editor.
</success_criteria>

<output>
After completion, create `.planning/phases/08-loaders-page/08-01-SUMMARY.md`
</output>
