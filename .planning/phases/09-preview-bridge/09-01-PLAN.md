---
phase: 09-preview-bridge
plan: 1
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mesh-plugin-site-editor/client/lib/editor-protocol.ts
  - packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts
  - packages/mesh-plugin-site-editor/client/lib/use-editor-messages.ts
  - packages/mesh-plugin-site-editor/client/components/page-composer.tsx
  - packages/mesh-plugin-site-editor/client/components/preview-panel.tsx
  - packages/starter-template/app/lib/editor-client.ts
  - packages/starter-template/app/routes/home.tsx
  - packages/starter-template/app/routes/$.tsx
autonomous: true

must_haves:
  truths:
    - "All iframe sends go through the single useIframeBridge — no dead iframeRef or useEditorMessages"
    - "The protocol types include all message types needed for edit/interact mode, navigation, and click-to-select"
    - "The starter template renders data-block-id attributes on section wrappers"
    - "The site-side editor client sends deco:ready, handles deco:page-config, deco:update-block, deco:set-mode, and emits deco:block-clicked and deco:click-away"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/lib/editor-protocol.ts"
      provides: "Complete typed protocol with EditorMessage and SiteMessage unions"
      contains: "deco:set-mode"
    - path: "packages/starter-template/app/lib/editor-client.ts"
      provides: "Site-side editor bridge client"
      contains: "deco:ready"
    - path: "packages/starter-template/app/routes/home.tsx"
      provides: "Section rendering with data-block-id wrappers"
      contains: "data-block-id"
  key_links:
    - from: "packages/mesh-plugin-site-editor/client/components/page-composer.tsx"
      to: "packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts"
      via: "useIframeBridge called in PageComposer, send() used for deco:update-block"
      pattern: "useIframeBridge\\("
    - from: "packages/starter-template/app/lib/editor-client.ts"
      to: "packages/mesh-plugin-site-editor/client/lib/editor-protocol.ts"
      via: "Site client handles same message types defined in protocol"
      pattern: "deco:page-config|deco:update-block|deco:set-mode"
---

<objective>
Remove dead iframe communication code from PageComposer, extend the postMessage protocol with all Phase 9 message types, consolidate sends through useIframeBridge, and build the site-side editor client that completes the postMessage handshake.

Purpose: Establish the single communication path and site-side counterpart that all interactive features (click-to-select, live editing, mode toggle) will build on in plan 09-02.

Output: Clean bridge with no dead code, extended protocol types, site-side editor client in starter template with data-block-id rendering.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-preview-bridge/09-RESEARCH.md

@packages/mesh-plugin-site-editor/client/lib/editor-protocol.ts
@packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts
@packages/mesh-plugin-site-editor/client/lib/use-editor-messages.ts
@packages/mesh-plugin-site-editor/client/components/page-composer.tsx
@packages/mesh-plugin-site-editor/client/components/preview-panel.tsx
@packages/starter-template/app/routes/home.tsx
@packages/starter-template/app/routes/$.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend protocol, remove dead code, consolidate bridge</name>
  <files>
    packages/mesh-plugin-site-editor/client/lib/editor-protocol.ts
    packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts
    packages/mesh-plugin-site-editor/client/lib/use-editor-messages.ts
    packages/mesh-plugin-site-editor/client/components/page-composer.tsx
    packages/mesh-plugin-site-editor/client/components/preview-panel.tsx
  </files>
  <action>
**Step 1: Extend editor-protocol.ts** with all Phase 9 message types:

EditorMessage union — add:
- `{ type: "deco:deselect" }` — editor tells iframe to clear selection
- `{ type: "deco:set-mode"; mode: "edit" | "interact" }` — switch overlay mode

SiteMessage union — add:
- `{ type: "deco:block-hover"; blockId: string | null; rect: DOMRect | null }` — hover state from iframe
- `{ type: "deco:navigated"; url: string; isInternal: boolean }` — iframe navigation event
- `{ type: "deco:click-away" }` — clicked outside any section
- `{ type: "deco:section-error"; blockId: string; error: string }` — section render error

Keep existing types unchanged. The `Page` import stays.

**Step 2: Delete use-editor-messages.ts.** First verify no other file imports it besides page-composer.tsx (grep for `use-editor-messages`). If only page-composer imports it, delete the entire file.

**Step 3: Lift useIframeBridge to PageComposer.** Currently PreviewPanel calls `useIframeBridge` internally. Refactor:

In **page-composer.tsx**:
- Remove line 74: `const iframeRef = useRef<HTMLIFrameElement>(null);`
- Remove line 75: `const { send } = useEditorMessages(iframeRef);`
- Remove line 44: `import { useEditorMessages } from "../lib/use-editor-messages";`
- Add: `const { send, setIframeRef, ready } = useIframeBridge({ page: localPage, selectedBlockId, onBlockClicked: setSelectedBlockId });`
- The `onBlockClicked` callback should call `setSelectedBlockId`. This replaces the `onBlockClicked` prop that was passed to PreviewPanel.
- Remove the block at lines 158-166 (prevBlocksRef page-config send via dead ref). The bridge's own render-time detection already sends `deco:page-config` when `page` changes.
- Keep the `send({ type: "deco:update-block" ... })` calls in `handlePropChange` (line 244-249), `handleBindLoader` (306-311), and `handleRemoveLoaderBinding` (327-332) — but now they use the lifted bridge's `send()`.
- Pass `setIframeRef` and `ready` as props to PreviewPanel. Remove `page`, `selectedBlockId`, and `onBlockClicked` from PreviewPanel's props (the bridge in PageComposer handles these now).

In **preview-panel.tsx**:
- Remove `useIframeBridge` import and call.
- Accept new props: `setIframeRef: (el: HTMLIFrameElement | null) => void` and `ready: boolean`.
- Keep `path`, `viewport` props. Remove `page`, `selectedBlockId`, `onBlockClicked` props.
- Use the passed `setIframeRef` as the iframe's ref callback.

In **use-iframe-bridge.ts**:
- Add handling for `deco:click-away` messages in the useSyncExternalStore subscription: call a new `onClickAway` callback from options.
- Add `onClickAway?: () => void` to `IframeBridgeOptions`.
- Add handling for `deco:navigated` messages: call `onNavigated?: (url: string, isInternal: boolean) => void` callback.
- Add both callbacks to IframeBridgeOptions interface. Use refs to keep them current (same pattern as onBlockClicked).

In PageComposer, wire `onClickAway` to `() => setSelectedBlockId(null)`. Leave `onNavigated` as a no-op for now (plan 02 implements navigation following).
  </action>
  <verify>
Run `bun run check` from repository root — no TypeScript errors. Grep for `useEditorMessages` — no imports remain. Grep for `use-editor-messages` — file deleted. Verify `page-composer.tsx` has exactly ONE `useIframeBridge` call and ZERO `useRef<HTMLIFrameElement>` declarations.
  </verify>
  <done>
All iframe communication flows through the single `useIframeBridge` hook called in PageComposer. Dead `iframeRef`, `useEditorMessages` import, and duplicate page-config send are removed. PreviewPanel receives `setIframeRef` as a prop. Protocol types include all Phase 9 message types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build site-side editor client and add data-block-id rendering</name>
  <files>
    packages/starter-template/app/lib/editor-client.ts
    packages/starter-template/app/routes/home.tsx
    packages/starter-template/app/routes/$.tsx
  </files>
  <action>
**Step 1: Create `packages/starter-template/app/lib/editor-client.ts`** — the site-side bridge.

This module auto-initializes when loaded in an iframe context (`window !== window.parent`). It is a no-op in production (when not in an iframe). Key behaviors:

```typescript
const DECO_PREFIX = "deco:";
let mode: "edit" | "interact" = "edit";
let hoverOverlay: HTMLDivElement | null = null;
let currentPageState: PageConfig | null = null;
const listeners = new Set<() => void>();
```

- **`initEditorBridge()`**: Exported function. If not in an iframe (`window === window.parent`), return immediately. Otherwise:
  1. Send `{ type: "deco:ready", version: 1 }` to `parent` via postMessage.
  2. Add `window.addEventListener("message", handleEditorMessage)`.
  3. Set up edit mode overlays via `setupEditMode()`.
  4. Listen for Vite HMR: `if (import.meta.hot) { import.meta.hot.on("vite:afterUpdate", () => parent?.postMessage({ type: "deco:ready", version: 1 }, "*")); }` — re-sends ready after HMR.

- **`handleEditorMessage(e: MessageEvent)`**: Filter by `e.data?.type?.startsWith(DECO_PREFIX)`. Handle:
  - `deco:page-config`: Store `e.data.page` in `currentPageState`, notify all listeners (for useSyncExternalStore consumers).
  - `deco:update-block`: Find block by `e.data.blockId` in `currentPageState.blocks`, replace its props with `e.data.props`, notify listeners. This triggers re-render in consuming components.
  - `deco:set-mode`: Update `mode`. If `"edit"`, call `setupEditMode()`. If `"interact"`, call `teardownEditMode()`.
  - `deco:select-block`: Scroll the `[data-block-id="<blockId>"]` element into view.
  - `deco:deselect`: No visual action needed (per user decision: no persistent selected visual).

- **`setupEditMode()`**: Create a fixed-position hover overlay div with:
  - `position: fixed; pointer-events: none; background: rgba(59, 130, 246, 0.08); z-index: 99999; display: none; transition: all 0.1s ease-out;`
  - Append to `document.body`.
  - Add `document.addEventListener("click", handleEditClick, true)` — capture phase.
  - Add `document.addEventListener("mousemove", handleEditHover, true)`.

- **`teardownEditMode()`**: Remove overlay from DOM, remove click/mousemove listeners.

- **`handleEditClick(e: MouseEvent)`**: If `mode !== "edit"`, return. `e.preventDefault(); e.stopPropagation();`. Find deepest `[data-block-id]` ancestor from `e.target`. If found, send `{ type: "deco:block-clicked", blockId, rect }`. If not found, send `{ type: "deco:click-away" }`.

- **`handleEditHover(e: MouseEvent)`**: If `mode !== "edit"` or no overlay, return. Find deepest `[data-block-id]` from `e.target`. Position overlay using `getBoundingClientRect()`. Hide overlay if no section found. Send `{ type: "deco:block-hover", blockId, rect }` to parent.

- **`findDeepestSection(target)`**: Walk up from target via `parentElement`, return first element with `data-block-id` attribute. Returns null if none found.

- **`getEditorPageState()`**: Returns `currentPageState`. Used by `useEditorProps` hook.

- **`subscribeEditorState(callback)`**: Add callback to `listeners` set, return cleanup function. For useSyncExternalStore.

- **`useEditorProps(blockId, staticProps)`**: React hook exported from this module. Uses `useSyncExternalStore(subscribeEditorState, () => getEditorPageState())`. If in editor mode and a matching block exists in currentPageState, return the editor's props. Otherwise return `staticProps`. This enables live prop hot-swap.

- **Navigation detection for interact mode**: Add click listener on `document` (non-capture) that watches for `<a>` clicks. If `mode === "interact"` and the link is internal (same origin as `window.location.origin`), let it navigate normally but send `{ type: "deco:navigated", url: href, isInternal: true }` before navigation. If external, send `{ type: "deco:navigated", url: href, isInternal: false }` before allowing navigation. Also listen for `popstate` events to detect back/forward navigation and send `deco:navigated`.

**Step 2: Update `packages/starter-template/app/routes/home.tsx`**:
- Import `initEditorBridge` and `useEditorProps` from `~/lib/editor-client`.
- Call `initEditorBridge()` at module level (runs once on import).
- Wrap each section in a `<div data-block-id={block.id}>` wrapper.
- Use `useEditorProps(block.id, block.props)` to get the live props for each section. This requires extracting the section rendering into a small `SectionRenderer` component (hooks can't be called in a map callback).

Create a `SectionRenderer` component:
```tsx
function SectionRenderer({ block, registry }: { block: BlockInstance; registry: Record<string, React.ComponentType<any>> }) {
  const props = useEditorProps(block.id, block.props);
  const Section = registry[block.blockType];
  if (!Section) return null;
  return (
    <div data-block-id={block.id}>
      <Section {...props} />
    </div>
  );
}
```

**Step 3: Update `packages/starter-template/app/routes/$.tsx`**:
- Same changes as home.tsx: import editor client, wrap sections in `data-block-id` divs, use `useEditorProps` for live props.
- Call `initEditorBridge()` at module level.
- Extract `SectionRenderer` component (can share with home.tsx or duplicate — since this is a template, duplication is acceptable for simplicity).

**Important:** The `useEditorProps` hook must handle SSR gracefully — use `useSyncExternalStore` with a server snapshot that returns `staticProps`. The `initEditorBridge()` call must be guarded by `typeof window !== "undefined"`.
  </action>
  <verify>
Run `bun run check` from repository root — no TypeScript errors. Verify `editor-client.ts` exists and exports `initEditorBridge` and `useEditorProps`. Verify `home.tsx` and `$.tsx` both have `data-block-id` in their JSX. Grep for `initEditorBridge` in route files — both should import it.
  </verify>
  <done>
Site-side editor client sends `deco:ready` on init, handles `deco:page-config` and `deco:update-block` for live prop hot-swap, handles `deco:set-mode` for edit/interact switching, emits `deco:block-clicked` and `deco:click-away` in edit mode. Starter template routes render `data-block-id` on section wrappers and use `useEditorProps` for live props. The client is a no-op when not in an iframe.
  </done>
</task>

</tasks>

<verification>
1. `bun run check` passes with no TypeScript errors
2. `grep -r "useEditorMessages" packages/mesh-plugin-site-editor/` returns no results (dead code removed)
3. `grep -r "data-block-id" packages/starter-template/` shows both route files
4. `grep -c "useIframeBridge" packages/mesh-plugin-site-editor/client/components/page-composer.tsx` returns 1 (single call)
5. `grep -c "useIframeBridge" packages/mesh-plugin-site-editor/client/components/preview-panel.tsx` returns 0 (removed)
6. `grep "deco:set-mode" packages/mesh-plugin-site-editor/client/lib/editor-protocol.ts` confirms new message type
</verification>

<success_criteria>
- Zero dead iframe refs or duplicate send paths in the editor code
- Protocol types cover all message types for click-to-select, mode toggle, navigation, and errors
- Site-side client completes the deco:ready handshake and handles all editor messages
- Starter template sections render with data-block-id for click targeting
- Live prop hot-swap works via useEditorProps hook in the template
</success_criteria>

<output>
After completion, create `.planning/phases/09-preview-bridge/09-01-SUMMARY.md`
</output>
