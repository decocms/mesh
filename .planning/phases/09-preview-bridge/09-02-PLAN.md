---
phase: 09-preview-bridge
plan: 2
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - packages/mesh-plugin-site-editor/client/components/preview-panel.tsx
  - packages/mesh-plugin-site-editor/client/components/page-composer.tsx
  - packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts
  - packages/mesh-plugin-site-editor/client/components/mode-toggle.tsx
autonomous: true

must_haves:
  truths:
    - "User can click a section in the iframe preview to select it, opening the prop editor in the sidebar"
    - "Clicking outside any section in the preview deselects and closes the prop editor"
    - "Edit/interact mode toggle is visible next to the viewport controls"
    - "In interact mode, clicks pass through to the site normally"
    - "Iframe disconnect shows a dimmed overlay with reconnect button"
    - "Prop changes in the editor reflect in the iframe preview within 1 second"
    - "External link navigation in interact mode disables the editor and shows a way to go back"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/components/mode-toggle.tsx"
      provides: "Edit/interact mode toggle component"
      contains: "MousePointer2"
    - path: "packages/mesh-plugin-site-editor/client/components/preview-panel.tsx"
      provides: "Preview panel with mode toggle, disconnect overlay, mode messaging"
      contains: "deco:set-mode"
  key_links:
    - from: "packages/mesh-plugin-site-editor/client/components/page-composer.tsx"
      to: "packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts"
      via: "onBlockClicked callback wires deco:block-clicked to setSelectedBlockId"
      pattern: "onBlockClicked.*setSelectedBlockId"
    - from: "packages/mesh-plugin-site-editor/client/components/page-composer.tsx"
      to: "packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts"
      via: "onClickAway callback wires deco:click-away to clearing selectedBlockId"
      pattern: "onClickAway.*setSelectedBlockId.*null"
    - from: "packages/mesh-plugin-site-editor/client/components/preview-panel.tsx"
      to: "packages/mesh-plugin-site-editor/client/components/mode-toggle.tsx"
      via: "ModeToggle renders in preview toolbar, onChange sends deco:set-mode"
      pattern: "ModeToggle"
    - from: "packages/mesh-plugin-site-editor/client/components/page-composer.tsx"
      to: "packages/starter-template/app/lib/editor-client.ts"
      via: "handlePropChange -> send(deco:update-block) -> editor-client updates currentPageState -> useEditorProps returns new value -> section re-renders"
      pattern: "deco:update-block"
---

<objective>
Wire click-to-select from the iframe overlay to the sidebar prop editor, add the edit/interact mode toggle, implement iframe disconnect detection with reconnect overlay, handle external link navigation (allow + disable editor + return button per locked decision), and verify live prop editing works end-to-end through the consolidated bridge.

Purpose: Make the visual editor interactive -- users can click sections to edit them, toggle between editing and browsing, recover from dev server crashes, and handle external navigation gracefully.

Output: Fully interactive preview panel with mode toggle, click-to-select, deselect-on-click-away, disconnect overlay, external navigation handling, and live prop editing.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-preview-bridge/09-RESEARCH.md
@.planning/phases/09-preview-bridge/09-01-SUMMARY.md

@packages/mesh-plugin-site-editor/client/lib/editor-protocol.ts
@packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts
@packages/mesh-plugin-site-editor/client/components/page-composer.tsx
@packages/mesh-plugin-site-editor/client/components/preview-panel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add edit/interact mode toggle and wire click-to-select + deselect</name>
  <files>
    packages/mesh-plugin-site-editor/client/components/mode-toggle.tsx
    packages/mesh-plugin-site-editor/client/components/preview-panel.tsx
    packages/mesh-plugin-site-editor/client/components/page-composer.tsx
    packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts
  </files>
  <action>
**Step 1: Create `mode-toggle.tsx`** — a small toggle component.

Import `MousePointer2` and `Hand` from `lucide-react` (already in dependencies). Import `Button` from `@deco/ui/components/button.tsx`.

```tsx
interface ModeToggleProps {
  mode: "edit" | "interact";
  onChange: (mode: "edit" | "interact") => void;
}
```

Render a `div` with `className="flex items-center gap-0.5 bg-muted rounded-lg p-0.5"` containing two `Button` components:
- Edit button: `variant={mode === "edit" ? "default" : "ghost"}`, `size="icon"`, onClick sets "edit", title="Edit mode - click to select sections", icon `<MousePointer2 size={14} />`
- Interact button: `variant={mode === "interact" ? "default" : "ghost"}`, `size="icon"`, onClick sets "interact", title="Interact mode - test links and buttons", icon `<Hand size={14} />`

**Step 2: Add mode state and toggle to PreviewPanel.**

In `preview-panel.tsx`:
- Import `ModeToggle` from `./mode-toggle`.
- Import `useState` from react.
- Add prop: `send: (msg: EditorMessage) => void` (from the lifted bridge in PageComposer).
- Add local state: `const [mode, setMode] = useState<"edit" | "interact">("edit")`.
- Create `handleModeChange` that: (1) calls `setMode(newMode)`, (2) calls `send({ type: "deco:set-mode", mode: newMode })`.
- Add `ModeToggle` next to the iframe in the preview area. Position it as a floating toolbar above the iframe: a small bar with the URL display and the mode toggle. Use a `div` above the iframe with `className="flex items-center justify-between px-3 py-1.5 border-b border-border bg-background"`. Show the current preview URL (truncated) on the left, mode toggle on the right.
- Import `EditorMessage` type from `../lib/editor-protocol`.

**Step 3: Wire click-to-select in PageComposer.**

The `onBlockClicked` callback in `useIframeBridge` already calls `setSelectedBlockId` (from plan 09-01). Verify this wiring exists. When a block is clicked in the iframe:
1. Site-side client sends `deco:block-clicked` with blockId
2. `useIframeBridge` receives it, calls `onBlockClicked(blockId)`
3. PageComposer's `setSelectedBlockId` is called
4. React re-renders, `selectedBlock` is found, prop editor shows in right panel

**Step 4: Wire click-away deselect in PageComposer.**

Verify the `onClickAway` callback from plan 09-01 is wired to `() => setSelectedBlockId(null)`. When user clicks outside any section:
1. Site-side client sends `deco:click-away`
2. `useIframeBridge` receives it, calls `onClickAway()`
3. `setSelectedBlockId(null)` clears selection
4. Right panel shows "Select a section to edit" placeholder

**Step 5: Pass `send` from PageComposer to PreviewPanel.**

In PageComposer, add `send` to PreviewPanel's props:
```tsx
<PreviewPanel
  path={localPage.path}
  viewport={viewport}
  setIframeRef={setIframeRef}
  ready={ready}
  send={send}
/>
```

**Step 6: Ensure mode is sent on iframe ready.**

In `use-iframe-bridge.ts`, after the `deco:ready` handshake sends `deco:page-config`, also send the current mode. Add an `initialMode` option to `IframeBridgeOptions` (default: `"edit"`), store in a ref, and send `{ type: "deco:set-mode", mode }` right after `deco:page-config` in the ready handler. The PreviewPanel should pass its current mode to PageComposer (or PageComposer manages mode state).

Simpler approach: Add `mode` as a prop to `IframeBridgeOptions`. In the `deco:ready` handler (inside useSyncExternalStore subscribe), after sending page-config, send `{ type: "deco:set-mode", mode: modeRef.current }`. Add `modeRef` updated from options like the other refs.

In PageComposer, manage the mode state and pass it to both useIframeBridge and PreviewPanel. In PreviewPanel, accept `mode` and `onModeChange` props instead of managing state locally. This keeps the single source of truth in PageComposer.

Revised PreviewPanel props:
```typescript
interface PreviewPanelProps {
  path?: string;
  viewport: ViewportKey;
  setIframeRef: (el: HTMLIFrameElement | null) => void;
  ready: boolean;
  mode: "edit" | "interact";
  onModeChange: (mode: "edit" | "interact") => void;
}
```

In PageComposer:
```typescript
const [mode, setMode] = useState<"edit" | "interact">("edit");
const [externalNav, setExternalNav] = useState<string | null>(null); // null = not on external page
const handleModeChange = (newMode: "edit" | "interact") => {
  setMode(newMode);
  send({ type: "deco:set-mode", mode: newMode });
};
```

Wire `onNavigated` in `useIframeBridge` options (no longer a no-op):
```typescript
onNavigated: (url: string, isInternal: boolean) => {
  if (isInternal) {
    // Auto-switch the page editor to the new internal page
    // Update URL bar, load that page's sections (uses existing page loading logic)
    // This is the "internal nav = auto-switch editor silently" locked decision
  } else {
    // External navigation: allow it, disable the editor, show return button
    // Per locked decision: "External link navigation: allow it, disable the editor, provide a way to go back"
    setExternalNav(url);
  }
},
```

Pass `mode`, `externalNav`, and `onModeChange={handleModeChange}` to PreviewPanel. Also pass `onReturnFromExternal` callback that: (1) sets `externalNav` to null, (2) reloads the iframe with the original site URL, (3) re-enables editing.

**Step 7: Add external navigation overlay to PreviewPanel.**

In `preview-panel.tsx`, accept `externalNav: string | null` and `onReturnFromExternal: () => void` props. When `externalNav` is not null, render a dimmed overlay over the iframe (similar to disconnect overlay but different message):

```tsx
{externalNav && (
  <div className="absolute inset-0 bg-background/60 flex flex-col items-center justify-center gap-3 z-10">
    <ExternalLink size={32} className="text-muted-foreground" />
    <p className="text-sm font-medium">Navigated to external site</p>
    <p className="text-xs text-muted-foreground max-w-xs truncate">{externalNav}</p>
    <Button
      variant="outline"
      size="sm"
      onClick={onReturnFromExternal}
    >
      Return to editor
    </Button>
  </div>
)}
```

Import `ExternalLink` from `lucide-react`. The editor sidebar should be visually disabled (dimmed / pointer-events-none) when `externalNav` is set — pass this state to PageComposer's sidebar rendering so it applies `opacity-50 pointer-events-none` on the prop editor panel.

Revised PreviewPanel props:
```typescript
interface PreviewPanelProps {
  path?: string;
  viewport: ViewportKey;
  setIframeRef: (el: HTMLIFrameElement | null) => void;
  ready: boolean;
  mode: "edit" | "interact";
  onModeChange: (mode: "edit" | "interact") => void;
  externalNav: string | null;
  onReturnFromExternal: () => void;
}
```
  </action>
  <verify>
Run `bun run check` — no TypeScript errors. Verify `mode-toggle.tsx` exists. Grep for `ModeToggle` in preview-panel.tsx — should find import and usage. Grep for `deco:set-mode` in use-iframe-bridge.ts — should find it in the ready handler. Verify PageComposer has `mode` state and passes it to both useIframeBridge and PreviewPanel.
  </verify>
  <done>
Edit/interact mode toggle renders in the preview toolbar. Click-to-select wires deco:block-clicked to opening the sidebar prop editor. Click-away wires deco:click-away to clearing the selection. Mode state lives in PageComposer and is sent to the iframe on ready and on toggle. External link navigation in interact mode sets externalNav state, shows dimmed overlay with return button, and disables the editor sidebar. Returning clears the state and reloads the iframe. Prop changes flow through the consolidated bridge to the iframe for live preview.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add iframe disconnect detection and reconnect overlay</name>
  <files>
    packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts
    packages/mesh-plugin-site-editor/client/components/preview-panel.tsx
  </files>
  <action>
**Step 1: Add disconnect detection to useIframeBridge.**

In `use-iframe-bridge.ts`:
- Add a `disconnectedRef = useRef(false)` and a `disconnectTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null)`.
- In `handleIframeLoad` (called when iframe fires `load` event): reset `readyRef` to false (already done), start a 5-second timeout. If `deco:ready` is not received within 5 seconds, set `disconnectedRef.current = true` and call `notify()`.
- In the `deco:ready` handler: clear the disconnect timer, set `disconnectedRef.current = false`, and call `notify()`.
- Expose `disconnected: boolean` from `useSyncExternalStore`. The getSnapshot should return an object or use a second useSyncExternalStore. Simplest approach: use a separate `useSyncExternalStore` for the disconnected state, sharing the same message subscription.

Actually, simplest approach: make the subscribe function track both `readyRef` and `disconnectedRef`. Return a composite snapshot: `{ ready: readyRef.current, disconnected: disconnectedRef.current }`. But useSyncExternalStore requires stable object identity for the snapshot.

Better approach: Keep `ready` as-is. Add a separate `disconnected` boolean tracked via its own useSyncExternalStore. The subscribe function for disconnected piggybacks on the same message listener (deduplicating is fine — two subscriptions to the same window event are cheap).

Alternatively, just track disconnected in a ref and expose it as a returned value that PreviewPanel reads. Since iframe load/ready events already trigger re-renders via the `ready` useSyncExternalStore, the disconnected state will be visible on the next render. Use a ref + include disconnected in the return type. When ready transitions back to true, disconnected is false. When the disconnect timer fires, it needs to trigger a re-render — so use the existing `notify()` from the ready subscription (set `readyRef.current = false` which is already the case, then the component re-renders and can check the returned `disconnected` getter).

Simplest viable approach:
- Add `disconnectedRef.current` ref.
- In `handleIframeLoad`: after resetting readyRef, start 5s timeout → `disconnectedRef.current = true`.
- In `deco:ready` handler: clear timeout, `disconnectedRef.current = false`.
- Add `disconnected` as a getter to the return object: `get disconnected() { return disconnectedRef.current; }`. Since the component re-renders when `ready` changes (which it does on both iframe load and deco:ready), the disconnected value will be current.
- Actually, for the disconnect timeout case, we need to trigger a re-render when the timer fires. Add a second `useSyncExternalStore` that subscribes to the same window events plus the timer. Or use a simpler pattern: have a `stateVersionRef` that increments on any state change, and one useSyncExternalStore that returns both ready and disconnected.

Final approach (clean):
- Replace the single `useSyncExternalStore` with one that returns `{ ready: boolean; disconnected: boolean }`. Store both in refs. The `notify` function triggers re-render for both. The getSnapshot returns `readyRef.current` XOR'd with `disconnectedRef.current` encoded as a string to get stable identity? No — just return a new object each time and let React compare.

Actually, `useSyncExternalStore` does strict equality on the snapshot. Returning a new object every time would cause infinite re-renders.

Cleanest solution: encode the state as a number. `0 = not ready, not disconnected`, `1 = ready`, `2 = disconnected`. Use `stateRef.current` as a number. Return it from getSnapshot. Decode in the component.

```typescript
// In useIframeBridge
const stateRef = useRef(0); // 0=loading, 1=ready, 2=disconnected
const disconnectTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

const state = useSyncExternalStore(
  (notify) => {
    const handleMessage = (e: MessageEvent) => {
      // ... existing message handling ...
      if (msg.type === "deco:ready") {
        if (disconnectTimerRef.current) clearTimeout(disconnectTimerRef.current);
        stateRef.current = 1; // ready
        notify();
        // send page config...
      }
      // ... block-clicked, click-away handling ...
    };
    window.addEventListener("message", handleMessage);
    return () => window.removeEventListener("message", handleMessage);
  },
  () => stateRef.current,
  () => 0, // server snapshot
);

const ready = state === 1;
const disconnected = state === 2;
```

In `handleIframeLoad`:
```typescript
const handleIframeLoad = () => {
  stateRef.current = 0; // loading
  if (disconnectTimerRef.current) clearTimeout(disconnectTimerRef.current);
  disconnectTimerRef.current = setTimeout(() => {
    stateRef.current = 2; // disconnected
    // Need to trigger re-render — but we're outside the subscribe callback.
    // Store the notify function in a ref to call it from the timer.
  }, 5000);
};
```

The problem: `notify` is only available inside the `subscribe` callback. Store it in a ref:
```typescript
const notifyRef = useRef<(() => void) | null>(null);
// Inside subscribe: notifyRef.current = notify;
// In handleIframeLoad timer: notifyRef.current?.();
```

This is the pattern. Implement it.

- Return `{ iframeRef, ready, disconnected, send, setIframeRef }` from the hook.

**Step 2: Add disconnect overlay to PreviewPanel.**

In `preview-panel.tsx`, accept `disconnected: boolean` prop. When `disconnected` is true, render a dimmed overlay over the iframe:

```tsx
{disconnected && (
  <div className="absolute inset-0 bg-background/80 flex flex-col items-center justify-center gap-3 z-10">
    <AlertCircle size={32} className="text-muted-foreground" />
    <p className="text-sm font-medium">Preview disconnected</p>
    <p className="text-xs text-muted-foreground">The dev server may have stopped</p>
    <Button
      variant="outline"
      size="sm"
      onClick={() => {
        // Force iframe reload
        const iframe = document.querySelector('iframe[title="Site preview"]') as HTMLIFrameElement;
        if (iframe) iframe.src = iframe.src;
      }}
    >
      Reconnect
    </Button>
  </div>
)}
```

Import `AlertCircle` from `lucide-react` and `Button` from `@deco/ui/components/button.tsx` (Button already imported).

The reconnect button reloads the iframe by resetting its `src`. This triggers the `load` event, which resets the bridge state and starts a new 5s timeout waiting for `deco:ready`.

Actually, better to use the `setIframeRef` mechanism or pass a reconnect callback from the bridge. Simplest: the PreviewPanel already has access to the iframe via `setIframeRef`. Add a `reconnect` function to the bridge return that does `iframeRef.current.src = iframeRef.current.src`. Pass it to PreviewPanel as a prop.

In `use-iframe-bridge.ts`, add to return:
```typescript
const reconnect = () => {
  if (iframeRef.current) {
    iframeRef.current.src = iframeRef.current.src;
  }
};
return { iframeRef, ready, disconnected, send, setIframeRef, reconnect };
```

In PageComposer, pass `reconnect` to PreviewPanel. In PreviewPanel, accept `reconnect: () => void` and use it in the button onClick.

**Step 3: Pass disconnected and reconnect from PageComposer to PreviewPanel.**

In PageComposer:
```typescript
const { send, setIframeRef, ready, disconnected, reconnect } = useIframeBridge({ ... });
```

Pass `disconnected` and `reconnect` to PreviewPanel.
  </action>
  <verify>
Run `bun run check` — no TypeScript errors. Verify `use-iframe-bridge.ts` returns `disconnected` and `reconnect`. Verify `preview-panel.tsx` renders the disconnect overlay conditionally. Grep for `stateRef` in use-iframe-bridge.ts to confirm the state machine pattern. Run `bun run fmt` to ensure formatting.
  </verify>
  <done>
Iframe disconnect is detected 5 seconds after iframe load if no `deco:ready` is received. A dimmed overlay with "Preview disconnected" message and a "Reconnect" button appears over the preview. Clicking reconnect reloads the iframe. The bridge state machine tracks loading/ready/disconnected as a single numeric state for useSyncExternalStore compatibility.
  </done>
</task>

</tasks>

<verification>
1. `bun run check` passes with no TypeScript errors
2. `bun run fmt` produces no changes (code is formatted)
3. `mode-toggle.tsx` exports ModeToggle with MousePointer2 and Hand icons
4. PreviewPanel renders ModeToggle in a toolbar bar above the iframe
5. PageComposer has `mode` state, passes to useIframeBridge and PreviewPanel
6. useIframeBridge returns `ready`, `disconnected`, `reconnect` and handles `deco:click-away`
7. PreviewPanel shows disconnect overlay when `disconnected` is true
8. The full click-to-select flow works: iframe sends deco:block-clicked -> bridge -> setSelectedBlockId -> prop editor opens
9. Live prop editing end-to-end: verify handlePropChange calls send(deco:update-block) -> editor-client.ts handleEditorMessage receives it -> updates currentPageState -> useEditorProps returns new value -> section component re-renders with new props (trace the full chain in code review)
10. External navigation: PageComposer has `externalNav` state, PreviewPanel shows dimmed overlay with return button when external nav is active, return button clears externalNav and reloads iframe
</verification>

<success_criteria>
- Click-to-select: clicking a section in the iframe opens the prop editor for that section
- Click-away: clicking outside sections clears the selection
- Mode toggle: switching to interact mode lets clicks pass through; edit mode intercepts clicks
- Disconnect overlay: appears after 5s if iframe doesn't send deco:ready; reconnect button reloads iframe
- Live prop editing end-to-end: prop change in editor -> deco:update-block sent -> editor-client updates currentPageState -> useEditorProps returns new value -> section re-renders with new props
- External navigation: navigating to external link in interact mode shows dimmed overlay with site URL and "Return to editor" button; clicking return reloads the original site and re-enables editing
</success_criteria>

<output>
After completion, create `.planning/phases/09-preview-bridge/09-02-SUMMARY.md`
</output>
