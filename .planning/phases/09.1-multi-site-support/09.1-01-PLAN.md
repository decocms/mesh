---
phase: 09.1-multi-site-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mesh-plugin-site-editor/client/lib/site-store.ts
  - packages/mesh-plugin-site-editor/client/lib/dirty-state.ts
  - packages/mesh-plugin-site-editor/client/components/unsaved-changes-dialog.tsx
  - packages/mesh-plugin-site-editor/client/components/page-composer.tsx
autonomous: true
requirements:
  - MULTI-SITE-STORE
  - MULTI-SITE-DIRTY

must_haves:
  truths:
    - "Site store tracks multiple site connections with active site ID"
    - "Active site ID persists to localStorage scoped by org and project"
    - "Restoring last active site works on startup from localStorage"
    - "Unsaved changes are detectable from outside the page composer"
    - "Unsaved changes dialog blocks site switch until user confirms"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/lib/site-store.ts"
      provides: "Module-level site store with useSyncExternalStore"
      exports: ["useSiteStore", "setActiveSite", "setSites", "getActiveSiteId"]
    - path: "packages/mesh-plugin-site-editor/client/lib/dirty-state.ts"
      provides: "Module-level dirty state for pending saves"
      exports: ["hasPendingSave", "markDirty", "markClean"]
    - path: "packages/mesh-plugin-site-editor/client/components/unsaved-changes-dialog.tsx"
      provides: "AlertDialog for confirming site switch with unsaved changes"
      contains: "AlertDialog"
  key_links:
    - from: "packages/mesh-plugin-site-editor/client/components/page-composer.tsx"
      to: "packages/mesh-plugin-site-editor/client/lib/dirty-state.ts"
      via: "markDirty/markClean calls in debouncedSave"
      pattern: "markDirty|markClean"
    - from: "packages/mesh-plugin-site-editor/client/lib/site-store.ts"
      to: "localStorage"
      via: "setActiveSite persists to scoped key"
      pattern: "localStorage\\.setItem"
---

<objective>
Create the site store (multi-site state management) and dirty-state API that form the foundation for multi-site support. The site store holds the list of site connections and active site ID with localStorage persistence. The dirty-state module exposes a `hasPendingSave()` function so the site switcher can detect unsaved changes before switching. An AlertDialog component handles the unsaved changes confirmation flow.

Purpose: These are the foundational building blocks that Plan 02 (site switcher UI and PluginLayout integration) depends on.
Output: site-store.ts, dirty-state.ts, unsaved-changes-dialog.tsx, and updated page-composer.tsx
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09.1-multi-site-support/09.1-RESEARCH.md
@packages/mesh-plugin-site-editor/client/lib/query-keys.ts
@packages/mesh-plugin-site-editor/client/components/page-composer.tsx
@packages/starter-template/app/lib/editor-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create site store and dirty-state modules</name>
  <files>
    packages/mesh-plugin-site-editor/client/lib/site-store.ts
    packages/mesh-plugin-site-editor/client/lib/dirty-state.ts
    packages/mesh-plugin-site-editor/client/components/page-composer.tsx
  </files>
  <action>
Create `site-store.ts` following the useSyncExternalStore pattern from `editor-client.ts`:

```typescript
interface SiteConnection {
  connectionId: string;
  projectPath: string;      // from connection.metadata.projectPath
  displayName: string;      // last segment of projectPath (e.g. "anjo.chat")
  status: "active" | "inactive" | "error";
}

interface SiteStoreState {
  sites: SiteConnection[];
  activeSiteId: string | null;
}
```

Key implementation details:
- Module-level `state`, `listeners` Set, `notify()`, `getSnapshot()`, `subscribe()` — exactly like editor-client.ts pattern
- `useSiteStore()` hook returns the full state via `useSyncExternalStore(subscribe, getSnapshot, getSnapshot)` (third arg = server snapshot, same as client since no SSR)
- `setSites(sites, orgId, projectId)` populates the sites array. On first call, restores `activeSiteId` from localStorage, falling back to the first site's connectionId. Does NOT clear activeSiteId if it matches an existing site.
- `setActiveSite(connectionId, orgId, projectId)` updates activeSiteId and persists to localStorage
- `getActiveSiteId()` synchronous getter for use outside React (e.g. dirty-state checks)
- localStorage key: `mesh:site-editor:${orgId}:${projectId}:active-site`
- If restored activeSiteId from localStorage doesn't match any current site, fall back to first site
- Export a `deriveDisplayName(projectPath: string): string` helper that extracts the last path segment

Create `dirty-state.ts` as a simple module-level boolean store:
- `let _dirty = false;`
- `markDirty()` sets `_dirty = true`
- `markClean()` sets `_dirty = false`
- `hasPendingSave(): boolean` returns `_dirty`

Update `page-composer.tsx`:
- Import `markDirty` and `markClean` from `../lib/dirty-state`
- In the `debouncedSave` function, call `markDirty()` when the timer starts (before `setTimeout`)
- In the `debouncedSave` callback (after successful `updatePage`), call `markClean()`
- In `handleSave` (manual save), call `markClean()` after successful save
- Also call `markClean()` on any save error (to avoid permanent dirty state)
- The `saveTimerRef` stays as-is; dirty-state is a parallel signal, not a replacement
  </action>
  <verify>
Run `bun run check` to verify TypeScript compiles. Grep for `markDirty` and `markClean` in page-composer.tsx to confirm integration. Grep for `useSyncExternalStore` in site-store.ts to confirm pattern.
  </verify>
  <done>
site-store.ts exports useSiteStore, setSites, setActiveSite, getActiveSiteId, deriveDisplayName. dirty-state.ts exports hasPendingSave, markDirty, markClean. page-composer.tsx calls markDirty/markClean around saves.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unsaved changes dialog component</name>
  <files>
    packages/mesh-plugin-site-editor/client/components/unsaved-changes-dialog.tsx
  </files>
  <action>
Create `unsaved-changes-dialog.tsx` using the existing `AlertDialog` from `@deco/ui/components/alert-dialog.tsx`:

The component receives:
- `open: boolean` — dialog visibility
- `onSaveAndSwitch: () => void` — flush pending save, then switch
- `onDiscardAndSwitch: () => void` — cancel pending save, then switch
- `onCancel: () => void` — close dialog, stay on current site

Render an AlertDialog with:
- Title: "Unsaved changes"
- Description: "You have unsaved changes on this page. What would you like to do?"
- Three buttons in the footer:
  1. "Cancel" (AlertDialogCancel) — calls onCancel
  2. "Discard changes" (AlertDialogAction, variant destructive) — calls onDiscardAndSwitch
  3. "Save & switch" (AlertDialogAction, default variant) — calls onSaveAndSwitch

Import AlertDialog components:
```typescript
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@deco/ui/components/alert-dialog.tsx";
```

Export as default for lazy loading compatibility.
  </action>
  <verify>
Run `bun run check` to verify TypeScript compiles. Verify the file exports a default component with AlertDialog usage.
  </verify>
  <done>
UnsavedChangesDialog component renders an AlertDialog with Cancel, Discard, and Save & Switch actions. It is ready for use by the site switcher in Plan 02.
  </done>
</task>

</tasks>

<verification>
1. `bun run check` passes with no type errors in new files
2. `bun run fmt` formats all new and modified files
3. site-store.ts follows useSyncExternalStore pattern (no useEffect)
4. dirty-state.ts is a pure module-level store (no React hooks)
5. page-composer.tsx integrates markDirty/markClean in save flow
6. unsaved-changes-dialog.tsx uses AlertDialog from @deco/ui
</verification>

<success_criteria>
- Site store manages multi-site state with localStorage persistence
- Dirty state is externally queryable via hasPendingSave()
- Unsaved changes dialog is ready for integration
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/09.1-multi-site-support/09.1-01-SUMMARY.md`
</output>
