---
phase: 09.1-multi-site-support
plan: 02
type: execute
wave: 2
depends_on: ["09.1-01"]
files_modified:
  - packages/mesh-plugin-site-editor/client/components/site-switcher.tsx
  - packages/mesh-plugin-site-editor/client/components/site-palette.tsx
  - packages/mesh-plugin-site-editor/client/components/plugin-header.tsx
  - packages/mesh-plugin-site-editor/client/index.tsx
  - apps/mesh/src/web/layouts/plugin-layout.tsx
  - packages/mesh-plugin-site-editor/client/components/plugin-empty-state.tsx
  - packages/mesh-plugin-site-editor/client/components/pages-list.tsx
autonomous: true
requirements:
  - MULTI-SITE-SWITCHER
  - MULTI-SITE-LAYOUT
  - MULTI-SITE-LIFECYCLE

must_haves:
  truths:
    - "User sees current site name with colored status dot in top bar"
    - "Clicking site name opens command palette showing all site connections"
    - "Each palette entry shows site name, project path, and connection status"
    - "Disconnected sites appear greyed out with disconnected label"
    - "Plus button in top bar opens add-site flow"
    - "Add site option available inside command palette"
    - "Switching sites navigates to new site pages list"
    - "Switching sites with unsaved changes shows confirmation dialog"
    - "Preview iframe reloads with new site tunnel URL on switch"
    - "Per-site React Query data cached independently and restored instantly"
    - "Last active site restored from localStorage on startup"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/components/site-switcher.tsx"
      provides: "Top bar site name display with status dot and plus button"
      contains: "SiteSwitcher"
    - path: "packages/mesh-plugin-site-editor/client/components/site-palette.tsx"
      provides: "Command palette for site selection with search and add-site"
      contains: "CommandDialog"
    - path: "packages/mesh-plugin-site-editor/client/components/plugin-header.tsx"
      provides: "Updated header replacing ConnectionSelector with SiteSwitcher"
      contains: "SiteSwitcher"
    - path: "apps/mesh/src/web/layouts/plugin-layout.tsx"
      provides: "Multi-site aware layout accepting connectionId override"
      contains: "connectionIdOverride"
  key_links:
    - from: "packages/mesh-plugin-site-editor/client/components/site-switcher.tsx"
      to: "packages/mesh-plugin-site-editor/client/lib/site-store.ts"
      via: "useSiteStore() for current site display"
      pattern: "useSiteStore"
    - from: "packages/mesh-plugin-site-editor/client/components/site-palette.tsx"
      to: "packages/mesh-plugin-site-editor/client/lib/site-store.ts"
      via: "setActiveSite() on selection"
      pattern: "setActiveSite"
    - from: "packages/mesh-plugin-site-editor/client/components/site-palette.tsx"
      to: "packages/mesh-plugin-site-editor/client/lib/dirty-state.ts"
      via: "hasPendingSave() check before switching"
      pattern: "hasPendingSave"
    - from: "packages/mesh-plugin-site-editor/client/index.tsx"
      to: "apps/mesh/src/web/layouts/plugin-layout.tsx"
      via: "connectionId from site store passed as override"
      pattern: "connectionIdOverride|activeSiteId"
---

<objective>
Build the site switcher UI (command palette + top bar) and integrate multi-site support into the PluginLayout. Users can see their current site with a status indicator, switch between sites via a searchable command palette, add new sites, and get confirmation dialogs for unsaved changes. The PluginLayout accepts a connectionId override so the site editor plugin controls which connection is active.

Purpose: This is the user-facing multi-site experience — the command palette for switching, the top bar display, and the layout wiring that makes it all work.
Output: site-switcher.tsx, site-palette.tsx, updated plugin-header.tsx, updated plugin-layout.tsx, updated index.tsx
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09.1-multi-site-support/09.1-RESEARCH.md
@.planning/phases/09.1-multi-site-support/09.1-01-SUMMARY.md
@packages/mesh-plugin-site-editor/client/components/plugin-header.tsx
@packages/mesh-plugin-site-editor/client/components/plugin-empty-state.tsx
@packages/mesh-plugin-site-editor/client/index.tsx
@apps/mesh/src/web/layouts/plugin-layout.tsx
@packages/mesh-plugin-site-editor/client/lib/site-store.ts
@packages/mesh-plugin-site-editor/client/lib/dirty-state.ts
@packages/mesh-plugin-site-editor/client/components/unsaved-changes-dialog.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create site switcher and command palette components</name>
  <files>
    packages/mesh-plugin-site-editor/client/components/site-switcher.tsx
    packages/mesh-plugin-site-editor/client/components/site-palette.tsx
  </files>
  <action>
**site-switcher.tsx** — Top bar component showing current site with status dot and "+" button:

```typescript
interface SiteSwitcherProps {
  onOpenPalette: () => void;
  onAddSite: () => void;
}
```

Implementation:
- Import `useSiteStore` from `../lib/site-store`
- Read `{ sites, activeSiteId }` from the store
- Find the active site from the sites array
- Render a clickable button showing:
  - A small colored dot: green (`bg-green-500`) for status "active", red (`bg-red-500`) for "error", gray (`bg-gray-400`) for "inactive" — use `cn()` for conditional classes
  - The site's `displayName` in `text-sm font-medium`
  - A `ChevronDown` icon (from `@untitledui/icons`) as visual affordance
- Clicking the button calls `onOpenPalette`
- Next to the button, render a "+" button (square icon button, `Plus` icon from `@untitledui/icons`) that calls `onAddSite`
- If no active site (activeSiteId is null), show "No site selected" in muted text
- Always render the switcher, even with one site (per locked decision)
- Export as default for lazy loading

**site-palette.tsx** — Command palette for site selection:

```typescript
interface SitePaletteProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSwitchSite: (connectionId: string) => void;
  onAddSite: () => void;
}
```

Implementation:
- Import `CommandDialog`, `CommandInput`, `CommandList`, `CommandItem`, `CommandGroup`, `CommandEmpty` from `@deco/ui/components/command.tsx`
- Import `useSiteStore` from `../lib/site-store`
- Read `{ sites, activeSiteId }` from the store
- Render `CommandDialog` with `open` and `onOpenChange` props
- Inside: `CommandInput` with placeholder "Search sites..."
- `CommandList` containing:
  1. `CommandGroup` with heading "Sites" listing all sites:
     - Each `CommandItem` shows:
       - Status dot (same color scheme as site-switcher)
       - `displayName` as primary text (bold for active site)
       - `projectPath` as secondary text in `text-xs text-muted-foreground`
       - A check mark icon if this is the active site
     - Disconnected sites (`status !== "active"`) get `opacity-50` class and show "(disconnected)" label after the name
     - `onSelect` calls `onSwitchSite(site.connectionId)` and closes the dialog
  2. `CommandGroup` with heading "Actions":
     - `CommandItem` "Add site..." with `Plus` icon, calls `onAddSite` and closes dialog
  3. `CommandEmpty` showing "No sites found."
- Export as default for lazy loading
  </action>
  <verify>
Run `bun run check` to verify TypeScript compiles. Verify CommandDialog import from @deco/ui. Verify useSiteStore integration.
  </verify>
  <done>
SiteSwitcher renders current site name with status dot and plus button. SitePalette renders a searchable command palette with all sites, status indicators, and "Add site" action.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate multi-site into plugin header and layout</name>
  <files>
    packages/mesh-plugin-site-editor/client/components/plugin-header.tsx
    packages/mesh-plugin-site-editor/client/index.tsx
    apps/mesh/src/web/layouts/plugin-layout.tsx
    packages/mesh-plugin-site-editor/client/components/plugin-empty-state.tsx
    packages/mesh-plugin-site-editor/client/components/pages-list.tsx
  </files>
  <action>
**plugin-layout.tsx** — Add optional `connectionIdOverride` prop:

Add to `PluginLayoutProps`:
```typescript
connectionIdOverride?: string | null;
```

In the component body, change the connection resolution logic:
- If `connectionIdOverride` is provided and truthy, use it as `configuredConnectionId` (skip the plugin config query for determining connection — but still fetch plugin config for other reasons if needed)
- The rest of the layout works the same: find connection from `allConnections`, build `PluginContext`, etc.
- This is a minimal change: add the prop, add one line of logic to prefer it over the config query result
- The `renderEmptyState` still renders when NO connections match (both override and config are null/missing)

Key change in connection resolution:
```typescript
const configuredConnectionId = connectionIdOverride ?? pluginConfig?.config?.connectionId;
```

**plugin-header.tsx** — Replace ConnectionSelector with SiteSwitcher:

- Remove the `ConnectionSelector` component entirely
- Import lazy: `SiteSwitcher` from `./site-switcher`, `SitePalette` from `./site-palette`, `UnsavedChangesDialog` from `./unsaved-changes-dialog`
- Add state: `paletteOpen`, `showUnsavedDialog`, `pendingSwitchId` (connectionId waiting for dialog confirmation), `showAddSite`
- The header now receives additional props beyond `PluginRenderHeaderProps`:
  - `allSiteConnections: ConnectionEntity[]` — all STDIO connections with metadata.projectPath
  - `orgId: string`
  - `projectId: string`
  - These are passed from the site editor plugin's index.tsx renderHeader

On mount (via ref-based sync, not useEffect):
- Call `setSites(derivedSiteConnections, orgId, projectId)` to populate the site store from the connections list

Site switch flow:
1. User clicks site in palette → `handleSwitchSite(connectionId)` called
2. Check `hasPendingSave()`:
   - If dirty: set `pendingSwitchId = connectionId`, `showUnsavedDialog = true`
   - If clean: proceed with `performSwitch(connectionId)`
3. `performSwitch(connectionId)`:
   - Call `setActiveSite(connectionId, orgId, projectId)`
   - Call `markClean()` (reset dirty state since we're leaving)
   - Navigate to pages list: use TanStack Router `navigate` to `/site-editor-layout/` (clean slate per locked decision)

Unsaved changes dialog handlers:
- "Save & switch": flush the current save timer (call `handleSave` from page-composer — this needs a module-level `flushPendingSave` export from dirty-state.ts or page-composer exposes it). Simpler approach: call `markClean()` and then `performSwitch`. The 2-second debounce will fire and save. Actually the simplest approach: just `performSwitch` which navigates away — the save timer fires before unmount. For safety, add a `flushPendingSave: (() => Promise<void>) | null` to dirty-state.ts that page-composer registers.
- "Discard & switch": call `markClean()`, cancel pending timer (via dirty-state's registered flush), then `performSwitch`
- "Cancel": close dialog, clear `pendingSwitchId`

Update dirty-state.ts to support a registered flush callback:
```typescript
let _flushFn: (() => Promise<void>) | null = null;
export function registerFlush(fn: () => Promise<void>) { _flushFn = fn; }
export async function flushPendingSave() { if (_flushFn) await _flushFn(); markClean(); }
export function cancelPendingSave() { /* just markClean, the timer will be killed by unmount */ markClean(); }
```

Update page-composer.tsx to register its save function:
```typescript
import { registerFlush, markDirty, markClean } from "../lib/dirty-state";
// In component body, register the flush function once:
const flushRef = useRef(false);
if (!flushRef.current) {
  registerFlush(async () => { /* clear timer, call updatePage immediately */ });
  flushRef.current = true;
}
```

Actually simpler: since page-composer unmounts on navigation, the timer gets cleared anyway. The "Save & switch" can just trigger `handleSave` (which is already exposed as a manual save). Let's use an event-based approach:
- dirty-state.ts exports `onFlushRequested(cb)` / `requestFlush()`
- page-composer subscribes to flush requests via useSyncExternalStore pattern
- "Save & switch" calls `requestFlush()`, waits briefly, then switches

Even simpler: since the debounce is 2 seconds and switching navigates away (causing unmount which clears the timer), just have "Save & switch" immediately save via the dirty-state registered callback, then switch. Let's go with the `registerFlush` approach — it's the most explicit.

"Add site" flow:
- Set `showAddSite = true` which renders the `PluginEmptyState` in a dialog/overlay
- Actually, per the locked decisions, "Add site" opens the Phase 6 inline wizard. The simplest approach: navigate to a route that shows the empty state, or render PluginEmptyState inline.
- Best approach: the palette's "Add site" and the "+" button both set a state that makes the PluginLayout render the empty state instead of the normal outlet. Pass a `showSetupWizard` prop or simply render PluginEmptyState in a dialog.
- Implementation: Render PluginEmptyState inside a `Dialog` from `@deco/ui` when `showAddSite` is true. After the empty state completes (connection created), invalidate connections query and close dialog.

**index.tsx** — Update renderHeader to pass site connections and integrate site store:

The `clientPlugin.renderHeader` currently just passes PluginRenderHeaderProps. Update it to also access connections and project context. Since renderHeader receives PluginRenderHeaderProps, we need to extend what the header receives.

The cleanest approach: inside PluginHeader, use hooks directly (`useConnections`, `useProjectContext`) to get the data it needs, rather than passing through renderHeader props. This avoids changing the PluginRenderHeaderProps interface.

So in plugin-header.tsx:
```typescript
import { useConnections, useProjectContext } from "@decocms/mesh-sdk";
```
Read all connections, filter to STDIO connections with `metadata?.projectPath`, derive SiteConnection objects, call `setSites()`.

**plugin-layout.tsx** — Pass connectionIdOverride from site store:

The site editor plugin needs to tell PluginLayout which connection to use. Two approaches:
1. PluginLayout reads from site store directly (coupling)
2. Plugin passes override via renderHeader or a wrapper

Best approach: The site editor's `clientPlugin` definition already has a `binding` field. In `index.tsx`, the plugin's rendering is controlled by PluginLayout. We need the site editor to pass `connectionIdOverride`.

Looking at how plugins work: `PluginLayout` is called with `binding`, `renderHeader`, `renderEmptyState`. The plugin doesn't control PluginLayout's props directly — the layout is rendered by the framework.

So the cleanest approach: PluginLayout itself can optionally read from a `connectionIdOverride` callback or the site store. Since only the site editor needs multi-site, add a new optional prop `useConnectionOverride?: () => string | null` to PluginLayoutProps. The site editor passes a function that reads from the site store.

Actually even simpler: add `connectionIdOverride?: string | null` to PluginLayoutProps. The site editor plugin's index.tsx wraps PluginLayout or the framework renders it. Let me check how PluginLayout is actually used...

Looking at the architecture: PluginLayout is rendered directly in route definitions. The plugin's `binding`, `renderHeader`, `renderEmptyState` are passed as props. So the plugin CAN pass additional props.

Update `PluginLayoutProps` to accept `connectionIdOverride?: string | null`.

In `index.tsx`, the clientPlugin needs to signal the override. Since the plugin definition has `binding`, `renderHeader`, `renderEmptyState` — these are the only props PluginLayout receives. We need another channel.

**Revised approach:** Make PluginLayout accept an optional `getConnectionId` function:
```typescript
getConnectionId?: () => string | null;
```

The site editor plugin passes:
```typescript
getConnectionId: () => getActiveSiteId()
```

In PluginLayout, if `getConnectionId` is provided, call it and use the result as `configuredConnectionId` (falling back to plugin config). This is called during render (it's a pure getter, no side effects).

Update the route definition or plugin framework to pass this through. Looking at how plugins register routes with `registerPluginRoutes`, the layout is typically a wrapper component. The site editor can create its own layout wrapper:

```typescript
// In index.tsx or a new wrapper
function SiteEditorLayout() {
  return (
    <PluginLayout
      binding={SITE_BINDING}
      renderHeader={(props) => <PluginHeader {...props} />}
      renderEmptyState={() => <PluginEmptyState />}
      getConnectionId={() => getActiveSiteId()}
    />
  );
}
```

But this depends on how the router is set up. Check `router.ts` for how PluginLayout is integrated.

If the router wraps routes with the layout, the simplest approach is: have the site editor's PluginLayout wrapper read from the site store directly. Create a thin wrapper `SiteEditorLayout` that renders `PluginLayout` with the active site's connectionId.

For the actual implementation, since I can't see the full router setup, go with this approach:
1. Add `connectionIdOverride?: string | null` to `PluginLayoutProps`
2. In `PluginLayout`, prefer `connectionIdOverride` over `pluginConfig?.config?.connectionId`
3. The site editor plugin wraps or extends PluginLayout usage to pass `connectionIdOverride={activeSiteId}` where `activeSiteId` comes from `useSiteStore()`
4. If the plugin can't easily wrap PluginLayout (because it's rendered by the framework), add a `useConnectionOverride` hook-based approach: `PluginLayout` accepts a `connectionOverrideHook?: () => string | null` and calls it conditionally

**Simplest viable approach:** Since PluginLayout already reads from PROJECT_PLUGIN_CONFIG_GET, and the site store overrides which connection is active, have the PluginLayout accept the override as a prop. The site editor's integration point (wherever PluginLayout is rendered for the site editor) passes the override. If the framework renders PluginLayout, add a thin wrapper.

For the pages-list.tsx: The tunnel detection and setup that currently lives in pages-list.tsx works per-connection already (it uses `connectionId` from plugin context). No changes needed since the PluginContext will provide the correct connectionId after switching.

**KEY IMPLEMENTATION NOTE:** Use `connectionId` as React `key` on the `PluginContextProvider` in plugin-layout.tsx. This forces all children to unmount/remount on site switch, giving a clean slate (per locked decision). This is critical for resetting page-composer state, preview iframe, etc.

```typescript
<PluginContextProvider key={pluginContext.connectionId} value={pluginContext}>
```

**pages-list.tsx changes:**
- No structural changes needed — it already reads connectionId from PluginContext
- The remount via key prop handles cleanup

**plugin-empty-state.tsx changes:**
- After successful connection creation, also call `setSites` to update the site store (or rely on query invalidation which triggers the header to re-derive sites)
- The empty state is rendered when `connectionIdOverride` is null AND no plugin config connection exists
- For "Add site" from palette: render PluginEmptyState in a Dialog. After creation completes, the new connection appears in the connections list, the site store updates via the header's derivation logic, and the dialog closes.
  </action>
  <verify>
1. `bun run check` passes
2. `bun run fmt` formats all files
3. Verify PluginLayout has `connectionIdOverride` prop and uses it
4. Verify PluginContextProvider has `key={connectionId}` for clean remount
5. Verify site-switcher renders status dot and display name
6. Verify site-palette uses CommandDialog from @deco/ui
7. Verify plugin-header imports and renders SiteSwitcher instead of ConnectionSelector
8. Verify hasPendingSave check before site switch
  </verify>
  <done>
Users can see current site in top bar with status dot, open command palette to search/switch sites, add new sites via "+" button or palette action, get unsaved changes confirmation before switching, and the PluginLayout correctly remounts with the new site's context on switch. Per-site data is cached independently in React Query.
  </done>
</task>

</tasks>

<verification>
1. `bun run check` passes with no type errors
2. `bun run fmt` formats all files correctly
3. Site switcher shows in top bar with colored dot and site name
4. Command palette opens on click with site list and "Add site" option
5. Switching sites updates the active site in the store and navigates to pages list
6. PluginContextProvider remounts on site switch (key prop)
7. Unsaved changes dialog appears when switching with dirty state
8. localStorage persists active site ID scoped by org/project
9. On startup, last active site is restored from localStorage
</verification>

<success_criteria>
- Complete multi-site switching UX with command palette, status indicators, and confirmation dialogs
- PluginLayout supports connectionId override with clean remount semantics
- All locked decisions from CONTEXT.md implemented: status dots, command palette, "+" button, unsaved changes dialog, clean slate navigation, localStorage persistence
</success_criteria>

<output>
After completion, create `.planning/phases/09.1-multi-site-support/09.1-02-SUMMARY.md`
</output>
