# Phase 09.1: Multi-Site Support - Research

**Researched:** 2026-02-16
**Domain:** Multi-site state management, command palette UX, per-site query caching
**Confidence:** HIGH

## Summary

This phase transforms the site editor plugin from a single-connection model to a multi-site model. The current architecture already scopes data per `connectionId` (query keys, plugin context, tool calls) but assumes a single configured connection per plugin per project. The core challenge is introducing a **site store** that tracks multiple connections, an **active site selector** (command palette), and ensuring all downstream consumers (React Query caches, preview iframe, PluginContext) correctly react to site switches.

The existing codebase provides strong foundations: `cmdk` (v1.1.1) is already installed and wrapped as `CommandDialog` in `@deco/ui`, the `ConnectionEntity` type has a `status` field and `metadata.projectPath` for deriving display names, and query keys are already namespaced by `connectionId`. The `useSyncExternalStore` pattern (already used in `editor-client.ts`) is the correct React 19-compliant approach for the site store, respecting the project's `ban-use-effect` lint rule.

**Primary recommendation:** Build a `SiteStore` (module-level store with `useSyncExternalStore`) that holds the list of site connections and active site ID, persisted to localStorage. Wire the existing `PluginLayout` to read from this store instead of `PROJECT_PLUGIN_CONFIG_GET`. Reuse the existing `CommandDialog` component from `@deco/ui` for the site switcher palette.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
#### Site switcher UX
- Top bar shows current site name with a colored dot indicator (green=connected, red=disconnected)
- Clicking the site name opens a command palette (Cmd+K style) filtered to connected sites
- Each entry in the palette shows: site name (derived from folder), project path, and connection status
- Switcher is always visible, even with only one site (palette can show "Add site" option)
- "+" button next to the site selector in the top bar as a second entry point for adding sites
- "Add site" option also available inside the command palette — both open the inline wizard (Phase 6 flow)

#### State on switch
- If there are unsaved changes in the current editor, show a confirmation dialog before switching
- On switch, navigate to the new site's pages list (clean slate, not same route)
- Preview iframe reloads immediately with the new site's tunnel URL
- Each site's scanned blocks and loaders are cached independently (React Query keyed per site)
- Switching back to a previously visited site shows cached data instantly

#### Connection lifecycle
- Adding new sites: from command palette ("Add site" option) or "+" button in top bar — both open Phase 6 inline wizard
- Removing/disconnecting sites: only through project settings (not from palette — destructive action stays in settings)
- Disconnected sites appear greyed out with "disconnected" label in the palette — still selectable (user sees Phase 9 reconnect overlay)
- No limit on number of site connections

#### Default & memory
- On startup, restore the last active site (remember which site the user was on)
- Last active site preference stored in browser localStorage (per-user, no server round-trip)
- Site display name auto-derived from project folder name (e.g., "anjo.chat") — not user-editable
- If last active site is disconnected on startup, show it anyway (user sees reconnect overlay)

### Claude's Discretion
- Command palette implementation details (reuse existing palette component or build new)
- Exact dot indicator styling and positioning
- localStorage key naming and structure
- React Query key namespacing strategy for per-site caching
- Transition animations between sites

### Deferred Ideas (OUT OF SCOPE)
None — discussion stayed within phase scope
</user_constraints>

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| cmdk | ^1.1.1 | Command palette primitive | Already installed in `@deco/ui`, wraps as `CommandDialog` |
| React 19 | 19.x | UI framework | Project standard, React Compiler enabled |
| @tanstack/react-query | 5.x | Data caching per site | Already used everywhere, query keys already scoped by connectionId |
| @tanstack/react-router | latest | Navigation on site switch | Already used for plugin routing |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @radix-ui/react-alert-dialog | latest | Unsaved changes confirmation | Already installed as `AlertDialog` in `@deco/ui` |
| sonner | latest | Toast notifications | Already used for success/error feedback |
| useSyncExternalStore | React built-in | Site store subscription | Required by ban-use-effect rule for external state |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Module-level store + useSyncExternalStore | Zustand | Zustand adds a dependency; useSyncExternalStore is already the pattern used in this codebase (editor-client.ts) |
| CommandDialog (cmdk) | Custom dropdown | cmdk already installed, provides search/filter/keyboard nav for free |

**Installation:** No new packages needed. Everything is already available.

## Architecture Patterns

### Recommended Structure
```
packages/mesh-plugin-site-editor/client/
├── lib/
│   ├── site-store.ts          # NEW: Multi-site state store (useSyncExternalStore)
│   ├── query-keys.ts          # EXISTING: Already scoped by connectionId (no changes needed)
│   └── ...
├── components/
│   ├── site-switcher.tsx       # NEW: Top bar site name + dot indicator + "+" button
│   ├── site-palette.tsx        # NEW: Command palette for site selection
│   ├── unsaved-changes-dialog.tsx  # NEW: AlertDialog for unsaved changes confirmation
│   └── plugin-header.tsx       # MODIFY: Replace ConnectionSelector with SiteSwitcher
└── ...

apps/mesh/src/web/
├── layouts/
│   └── plugin-layout.tsx       # MODIFY: Support multi-site (read active site from store)
└── ...
```

### Pattern 1: Site Store (useSyncExternalStore)
**What:** A module-level store holding `sites: SiteConnection[]` and `activeSiteId: string | null`, with localStorage persistence.
**When to use:** Whenever components need the current active site or the list of sites.
**Example:**
```typescript
// site-store.ts
interface SiteConnection {
  connectionId: string;
  projectPath: string;      // from connection.metadata.projectPath
  displayName: string;      // derived: last segment of projectPath
  status: "active" | "inactive" | "error";  // from ConnectionEntity.status
}

interface SiteStoreState {
  sites: SiteConnection[];
  activeSiteId: string | null;
}

let state: SiteStoreState = { sites: [], activeSiteId: null };
const listeners = new Set<() => void>();

function getSnapshot(): SiteStoreState { return state; }
function subscribe(cb: () => void) { listeners.add(cb); return () => listeners.delete(cb); }

// Persist activeSiteId to localStorage
const STORAGE_KEY = "mesh:site-editor:active-site";

export function useSiteStore() {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}

export function setActiveSite(connectionId: string) {
  state = { ...state, activeSiteId: connectionId };
  localStorage.setItem(STORAGE_KEY, connectionId);
  notify();
}

export function setSites(sites: SiteConnection[]) {
  state = { ...state, sites };
  // Restore last active from localStorage or default to first
  if (!state.activeSiteId) {
    state.activeSiteId = localStorage.getItem(STORAGE_KEY) ?? sites[0]?.connectionId ?? null;
  }
  notify();
}
```

### Pattern 2: Multi-Site PluginLayout Integration
**What:** The `PluginLayout` currently reads a single `connectionId` from `PROJECT_PLUGIN_CONFIG_GET`. For multi-site, it needs to read from the site store instead.
**When to use:** When rendering the site editor plugin.
**Key insight:** The current `PluginLayout` is generic (used by all plugins). Multi-site is specific to the site editor. Two approaches:
1. Make `PluginLayout` multi-site aware (adds complexity to a generic component)
2. Have the site editor plugin manage its own connection selection and pass it to `PluginLayout`

**Recommendation:** Option 2 is cleaner. The site editor's `renderHeader` already receives connection props. The site store replaces what `PROJECT_PLUGIN_CONFIG_GET` provides. The `PluginLayout` can accept an optional `connectionIdOverride` prop, or the site editor can wrap `PluginLayout` with its own layout that injects the active site's connectionId.

### Pattern 3: Query Key Namespacing (Already Done)
**What:** All query keys in `packages/mesh-plugin-site-editor/client/lib/query-keys.ts` already include `connectionId` as a parameter.
**Key insight:** No changes needed to query key structure. When `activeSiteId` changes, all queries automatically use the new connectionId. Previously cached data for other sites remains in the React Query cache, enabling instant switching.

### Pattern 4: Unsaved Changes Guard
**What:** Before switching sites, check if the page composer has a pending `saveTimerRef` (debounced save in progress).
**When to use:** Only when switching sites while a page editor is open.
**Implementation:** The page-composer uses a 2-second debounce save. The site store can expose a `beforeSwitch` hook that checks for pending saves. An `AlertDialog` from `@deco/ui` handles the confirmation.

### Anti-Patterns to Avoid
- **Don't store site list in localStorage:** Only persist `activeSiteId`. The site list comes from server data (connections with SITE_BINDING). localStorage is for preference only.
- **Don't clear React Query cache on site switch:** Let cached data from other sites persist. This enables instant switching back.
- **Don't use useEffect for localStorage sync:** Use explicit function calls (setActiveSite) that both update state and persist. The ban-use-effect rule forbids useEffect.
- **Don't add multi-site logic to the generic PluginLayout:** Keep it in the site editor plugin. Other plugins (reports, registry) don't need multi-site.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Command palette with search/filter | Custom dropdown with filtering | `CommandDialog` + `CommandInput` + `CommandItem` from `@deco/ui` | cmdk handles keyboard nav, fuzzy search, accessibility |
| Confirmation dialog | Custom modal | `AlertDialog` from `@deco/ui` | Proper focus trap, accessible, already styled |
| External store subscription | Custom event emitter | `useSyncExternalStore` | React 19 concurrent-mode safe, already used in codebase |
| Query cache invalidation per site | Manual cache management | React Query's key-based caching | Already scoped by connectionId, works automatically |

**Key insight:** The existing UI component library and React Query setup handle 90% of this phase's complexity. The novel work is the site store and wiring it into the existing plugin architecture.

## Common Pitfalls

### Pitfall 1: Stale PluginContext After Site Switch
**What goes wrong:** Components deep in the tree still reference the old site's `connectionId` and `toolCaller` after switching.
**Why it happens:** `PluginContextProvider` wraps the entire plugin. If it doesn't re-render with the new connection, children use stale context.
**How to avoid:** When `activeSiteId` changes, the `PluginLayout` (or site editor wrapper) must re-create the `PluginContext` with the new connection's client. Use the connectionId as a React `key` on the provider to force unmount/remount.
**Warning signs:** Tool calls hitting the wrong MCP after switching sites.

### Pitfall 2: Debounced Save Lost on Site Switch
**What goes wrong:** User edits a block, then immediately switches sites. The 2-second debounce timer fires after context has changed, potentially saving to the wrong site or failing silently.
**Why it happens:** `saveTimerRef` in `page-composer.tsx` holds a closure over the old `toolCaller`.
**How to avoid:** Flush (or cancel) pending saves before switching. The unsaved changes dialog should offer "Save & Switch", "Discard & Switch", "Cancel".
**Warning signs:** Edits lost or applied to wrong site.

### Pitfall 3: localStorage Key Collisions
**What goes wrong:** Multiple browser tabs or different organizations share the same localStorage key, causing wrong site to restore.
**Why it happens:** Using a generic key like `active-site` without scoping.
**How to avoid:** Scope the key by org and project: `mesh:site-editor:${orgId}:${projectId}:active-site`.
**Warning signs:** Opening the plugin in a different project restores wrong site.

### Pitfall 4: Connection List Race with Site Store
**What goes wrong:** The site store initializes before connections are loaded from the server, showing empty state or stale data.
**Why it happens:** `useConnections()` is async (React Query), but site store init is synchronous.
**How to avoid:** The site store's `sites` array is populated from `useConnections()` data filtered by SITE_BINDING. The store should handle the empty state gracefully (no active site until connections load).
**Warning signs:** Flash of empty state, then sudden switch to a site.

### Pitfall 5: Preview iframe Not Reloading on Switch
**What goes wrong:** The preview continues showing the old site's pages after switching.
**Why it happens:** The iframe `src` is derived from `connection.metadata.previewUrl`, which comes from `PluginContext`. If context doesn't update, iframe stays stale.
**How to avoid:** Use `connectionId` as a `key` on the component that contains the iframe, forcing a full remount. Or explicitly set iframe `src` when active site changes.
**Warning signs:** Preview shows pages from the wrong site.

## Code Examples

### Existing CommandDialog Usage
```typescript
// Source: packages/ui/src/components/command.tsx
// cmdk ^1.1.1 already wrapped with dialog, input, list, item, group, etc.
import {
  CommandDialog,
  CommandInput,
  CommandList,
  CommandItem,
  CommandGroup,
  CommandEmpty,
} from "@deco/ui/components/command.tsx";
```

### Existing Connection Entity Status
```typescript
// Source: packages/mesh-sdk/src/types/connection.ts
// ConnectionEntity already has:
status: z.enum(["active", "inactive", "error"]).describe("Current status"),
metadata: z.record(z.string(), z.unknown()).nullable(),
// metadata.projectPath is set during Phase 6 connection creation
```

### Existing Query Keys (Already Per-Connection)
```typescript
// Source: packages/mesh-plugin-site-editor/client/lib/query-keys.ts
export const queryKeys = {
  pages: {
    all: (connectionId: string) => ["site-editor", "pages", connectionId] as const,
    detail: (connectionId: string, pageId: string, locale?: string | null) =>
      ["site-editor", "pages", connectionId, pageId, locale ?? "default"] as const,
  },
  blocks: {
    all: (connectionId: string) => ["site-editor", "blocks", connectionId] as const,
  },
  // ... all keys already include connectionId
};
```

### Existing useSyncExternalStore Pattern
```typescript
// Source: packages/starter-template/app/lib/editor-client.ts
// This exact pattern should be followed for the site store:
let state: SomeState = initialValue;
const listeners = new Set<() => void>();

function notify() { for (const fn of listeners) fn(); }
function getSnapshot() { return state; }
function subscribe(cb: () => void) { listeners.add(cb); return () => listeners.delete(cb); }

// Hook
export function useMyStore() {
  return useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
}
```

### Existing Plugin Empty State (Phase 6 Wizard)
```typescript
// Source: packages/mesh-plugin-site-editor/client/components/plugin-empty-state.tsx
// This component handles the "Add Site" flow:
// 1. Folder picker (FILESYSTEM_PICK_DIRECTORY)
// 2. Validate project (FILESYSTEM_VALIDATE_PROJECT)
// 3. Create STDIO connection
// 4. Bind to plugin (PROJECT_PLUGIN_CONFIG_UPDATE)
// The "Add site" action in the palette should reuse this same flow.
```

### Current PluginLayout Single-Connection Architecture
```typescript
// Source: apps/mesh/src/web/layouts/plugin-layout.tsx
// Currently fetches ONE connectionId from PROJECT_PLUGIN_CONFIG_GET
// and builds PluginContext around it.
// For multi-site, the site editor needs to:
// 1. Track multiple connectionIds (all SITE_BINDING connections)
// 2. Let the user pick which is "active"
// 3. Provide the active connection's context to children
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Single connectionId per plugin via PROJECT_PLUGIN_CONFIG | Multi-site store with user-selectable active site | This phase (09.1) | Enables managing multiple sites from one project |
| Connection selector in project settings only | Command palette in top bar + settings | This phase (09.1) | Faster site switching, better discoverability |

**Architecture shift:** The `project_plugin_configs` table currently stores one `connectionId` per (project, plugin) pair. Multi-site doesn't change this table -- it changes how the **client** selects which connection to use. The plugin config becomes a "default" or "fallback", while the site store (localStorage) tracks the user's current selection from all available SITE_BINDING connections.

## Open Questions

1. **How to list all SITE_BINDING connections for the palette?**
   - What we know: `useConnections()` fetches all connections. The `filterConnectionsByBinding` utility (referenced in PluginLayout comments) can filter by binding. Connections have a `bindings` field (array of strings).
   - What's unclear: Whether `bindings` is always populated for STDIO connections (it's populated after tool discovery, which happens asynchronously).
   - Recommendation: Filter connections where `connection_type === "STDIO"` AND `metadata.projectPath` exists as a heuristic, falling back to binding check when available. Or filter by the presence of expected tools.

2. **Should PROJECT_PLUGIN_CONFIG store the "primary" site or is it obsolete for multi-site?**
   - What we know: Currently stores one connectionId. Multi-site needs many.
   - What's unclear: Whether to keep it as a "default" fallback or ignore it entirely.
   - Recommendation: Keep it as the fallback for first-time load (before localStorage has a preference). The site store initializes from: localStorage > plugin config > first available site.

3. **How to detect "unsaved changes" from outside page-composer?**
   - What we know: `page-composer.tsx` uses a `saveTimerRef` for 2-second debounced saves. There's no external API to check if saves are pending.
   - What's unclear: Best way to expose this state without useEffect.
   - Recommendation: Add a module-level `hasPendingSave()` function to page-composer (or a shared dirty-state store), similar to the editor-client pattern. The site switcher checks this before allowing a switch.

## Sources

### Primary (HIGH confidence)
- `packages/ui/src/components/command.tsx` - cmdk ^1.1.1 wrapper, CommandDialog API
- `packages/mesh-plugin-site-editor/client/lib/query-keys.ts` - query keys already scoped by connectionId
- `packages/mesh-plugin-site-editor/client/components/plugin-empty-state.tsx` - Phase 6 "Add Site" wizard
- `packages/starter-template/app/lib/editor-client.ts` - useSyncExternalStore pattern
- `apps/mesh/src/web/layouts/plugin-layout.tsx` - current single-connection PluginLayout
- `packages/mesh-sdk/src/types/connection.ts` - ConnectionEntity with status and metadata fields
- `apps/mesh/src/storage/project-plugin-configs.ts` - single connectionId per (project, plugin) pair
- `packages/mesh-plugin-site-editor/client/components/page-composer.tsx` - debounced save, unsaved state
- `packages/mesh-plugin-site-editor/client/components/preview-panel.tsx` - iframe preview using tunnel URL
- `packages/bindings/src/well-known/site.ts` - SITE_BINDING definition

### Secondary (MEDIUM confidence)
- `packages/ui/src/components/alert-dialog.tsx` - AlertDialog for unsaved changes confirmation
- `apps/mesh/src/web/components/settings/project-plugins-form.tsx` - plugin connection binding UI

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - all libraries already installed and in use
- Architecture: HIGH - patterns directly observed in codebase (useSyncExternalStore, query key scoping, PluginLayout)
- Pitfalls: HIGH - identified from reading actual code (saveTimerRef, PluginContext lifecycle, localStorage scoping)

**Research date:** 2026-02-16
**Valid until:** 2026-03-16 (stable -- all dependencies are already pinned in the project)
