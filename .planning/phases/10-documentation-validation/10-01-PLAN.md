---
phase: 10-documentation-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/BLOCKS_FRAMEWORK.md
  - .claude/commands/deco/blocks-framework.md
  - packages/starter-template/BLOCKS_FRAMEWORK.md
autonomous: true
requirements:
  - SPEC-01

must_haves:
  truths:
    - "An AI agent reading BLOCKS_FRAMEWORK.md can understand .deco/ directory conventions without additional context"
    - "The spec documents every postMessage type, payload shape, and expected response for both EditorMessage and SiteMessage unions"
    - "Both integration paths (Vite plugin auto-inject and explicit initEditorBridge) are documented with decision tree for when to use which"
    - "A machine-checkable compatibility checklist exists with file paths to verify and attributes to check"
    - "Real JSON Schema examples from anjo.chat blocks are included for agents to pattern-match"
  artifacts:
    - path: "docs/BLOCKS_FRAMEWORK.md"
      provides: "Canonical blocks framework specification"
      min_lines: 300
    - path: ".claude/commands/deco/blocks-framework.md"
      provides: "Claude Code skill exposing the full spec"
      min_lines: 300
    - path: "packages/starter-template/BLOCKS_FRAMEWORK.md"
      provides: "Full spec copy in starter template"
      min_lines: 300
  key_links:
    - from: "docs/BLOCKS_FRAMEWORK.md"
      to: "packages/mesh-plugin-site-editor/client/lib/editor-protocol.ts"
      via: "documents EditorMessage and SiteMessage types"
      pattern: "deco:page-config|deco:update-block|deco:ready"
    - from: "docs/BLOCKS_FRAMEWORK.md"
      to: "packages/mesh-plugin-site-editor/server/scanner/types.ts"
      via: "documents BlockDefinition interface as canonical format"
      pattern: "BlockDefinition|schema|defaults|metadata"
    - from: ".claude/commands/deco/blocks-framework.md"
      to: "docs/BLOCKS_FRAMEWORK.md"
      via: "identical content copy"
      pattern: "Blocks Framework Specification"
---

<objective>
Write the comprehensive BLOCKS_FRAMEWORK.md specification document that enables any AI agent or developer to make a TypeScript site deco-compatible. Place the canonical version at `docs/BLOCKS_FRAMEWORK.md`, copy it as a Claude Code skill at `.claude/commands/deco/blocks-framework.md`, and copy it into the starter template.

Purpose: SPEC-01 requires a single document sufficient for AI agents to understand .deco/ conventions, block formats, data-block-id attributes, postMessage protocol, and initEditorBridge() integration. This is the final documentation deliverable for v1.1.
Output: Three identical files — canonical spec, Claude skill, starter template copy.
</objective>

<execution_context>
@/Users/guilherme/.claude/get-shit-done/workflows/execute-plan.md
@/Users/guilherme/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-documentation-validation/10-RESEARCH.md

# Source files to extract spec content from (read these during execution):
@packages/mesh-plugin-site-editor/client/lib/editor-protocol.ts
@packages/mesh-plugin-site-editor/server/scanner/types.ts
@packages/mesh-plugin-site-editor/client/lib/inject-bridge.ts
@packages/vite-plugin-deco/index.ts
@packages/starter-template/app/lib/editor-client.ts
@packages/starter-template/app/routes/home.tsx
@/Users/guilherme/Projects/anjo.chat/.deco/blocks/sections--Hero.json
@/Users/guilherme/Projects/anjo.chat/.deco/pages/page_home.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write canonical BLOCKS_FRAMEWORK.md specification</name>
  <files>docs/BLOCKS_FRAMEWORK.md</files>
  <action>
Create `docs/BLOCKS_FRAMEWORK.md` by extracting and documenting from actual source code. The document structure must follow the user's locked decisions:

**Goal-first organization** — start with "what you're trying to achieve" (make a site deco-compatible), then explain how each piece fits. Top-down narrative.

**Document structure (in order):**

1. **Overview / Goal** — "This document explains how to make any TypeScript site compatible with the deco CMS editor." Audience: AI agents and developers. State the two integration paths up front.

2. **Quick Start Decision Tree** — Clear flowchart: "If you use Vite → use decoEditorBridgePlugin(). If you want explicit control → use initEditorBridge(). NEVER use both simultaneously." Per research pitfall #2.

3. **.deco/ Directory Conventions** — Document the full directory structure:
   ```
   .deco/
   ├── blocks/          # Block definitions (scanner-generated)
   │   └── sections--Hero.json
   ├── pages/           # Page configurations
   │   ├── page_home.json
   │   └── page_home.en-US.json   # Locale variant
   └── loaders/         # Loader definitions
       └── loaders--products.json
   ```
   - ID convention: `{category}--{ComponentName}` derived from file path
   - Page filename convention: `{pageId}.json` default, `{pageId}.{locale}.json` for variants
   - Locale pattern: `[a-z]{2}(-[A-Z]{2})?`

4. **Block Definition Format** — Document the `BlockDefinition` interface from `scanner/types.ts` as canonical. Include a REAL example from anjo.chat's `sections--Hero.json` (read it from disk during execution). Fields: id, component, label, category, description, schema (JSON Schema), defaults, metadata (scannedAt, scanMethod, propsTypeName, customized).

   Note that older hand-crafted files may use legacy field names (type, title, filePath). Scanner output is authoritative.

5. **Page Configuration Format** — Document the `Page` type from `page-api.ts`. Show real example from anjo.chat's `page_home.json`. Fields: id, path, title, blocks (array of BlockInstance with id, blockType, props), metadata.

6. **data-block-id Attribute** — Explain this is THE critical rendering requirement. Every section wrapper div MUST have `data-block-id={block.id}`. Without it, click-to-select and hover overlays silently fail. Show the rendering pattern:
   ```tsx
   <div data-block-id={block.id}>
     <Section {...block.props} />
   </div>
   ```

7. **Integration Path 1: Vite Plugin (Auto-Inject)** — Explained walkthrough per user decision:
   - What it does: injects a `<script>` into every HTML response during dev
   - Where it goes: `vite.config.ts` plugins array
   - What each part means: the plugin only runs in `serve` mode, checks `window.self !== window.top`, handles full postMessage protocol
   - Then the code: `decoEditorBridgePlugin()` import and usage
   - For live prop hot-swap: the injected bridge dispatches CustomEvents (`deco:page-config`, `deco:update-block`). Site listens with `addEventListener` or custom hook.
   - Reference anjo.chat's approach: `useEditorBlocks()` hook listening for CustomEvents.

8. **Integration Path 2: Explicit Client Bridge (Starter Template)** — Explained walkthrough:
   - What it does: gives the site direct access to bridge state
   - Where it goes: imported at module level in route files
   - `initEditorBridge()` — module-level singleton, no-op outside iframes
   - `useEditorProps(blockId, staticProps)` — useSyncExternalStore hook for automatic prop hot-swap
   - SectionRenderer component pattern
   - Reference starter template's `editor-client.ts` and `home.tsx`

9. **postMessage Protocol Specification** — Document EVERY message type from `editor-protocol.ts`. Read the actual TypeScript source and extract all union members.

   **Editor → Site (EditorMessage):**
   For each: type string, payload shape, purpose, when sent.
   - `deco:page-config` — full page config, sent on initial connection and page navigation
   - `deco:update-block` — single block prop update, sent on prop editor change
   - `deco:select-block` — scroll to and highlight, sent when user clicks section in sidebar
   - `deco:set-viewport` — viewport width change
   - `deco:deselect` — clear selection
   - `deco:set-mode` — edit/interact toggle
   - `deco:ping` — heartbeat

   **Site → Editor (SiteMessage):**
   - `deco:ready` — bridge initialized, version number
   - `deco:block-clicked` — user clicked section, with DOMRect
   - `deco:blocks-rendered` — all block positions (for overlay alignment)
   - `deco:block-hover` — hover enter/leave with DOMRect
   - `deco:navigated` — URL change in interact mode
   - `deco:click-away` — click outside any section
   - `deco:section-error` — section render error
   - `deco:pong` — heartbeat response

   Include the exact TypeScript type definition for each message (copy from source).

10. **Troubleshooting / Common Mistakes** — Ordered by likelihood per research:
    1. Missing `data-block-id` attributes — click-to-select silently fails
    2. Both bridge approaches active simultaneously — duplicate events
    3. Vite plugin not in dev mode — only runs during `serve`, not production
    4. Cross-origin iframe restrictions — bridge fails silently
    5. Block IDs mismatch between page JSON and rendered DOM
    6. Missing `.deco/` directory or incorrect block format
    7. Wrong postMessage origin — wildcard `*` avoids in dev

    Each item: symptom, cause, fix.

11. **Machine-Checkable Compatibility Checklist** — Structured format per user decision:
    ```
    CHECK-01: .deco/ directory exists at project root
      verify: fs.existsSync('.deco/')
    CHECK-02: .deco/blocks/ contains at least one .json file
      verify: glob('.deco/blocks/*.json').length > 0
    CHECK-03: Each block JSON has required fields (id, component, schema)
      verify: JSON.parse(file).id && JSON.parse(file).component && JSON.parse(file).schema
    CHECK-04: .deco/pages/ contains at least one page JSON
      verify: glob('.deco/pages/*.json').length > 0
    CHECK-05: Page JSON has blocks array with blockType and props
      verify: page.blocks.every(b => b.blockType && b.props)
    CHECK-06: Site renders data-block-id on section wrappers
      verify: document.querySelectorAll('[data-block-id]').length > 0
    CHECK-07: Bridge integration active (Vite plugin OR initEditorBridge)
      verify: vite.config includes decoEditorBridgePlugin OR route files import initEditorBridge
    CHECK-08: NOT both bridge approaches active simultaneously
      verify: !(vite.config includes decoEditorBridgePlugin AND route files import initEditorBridge)
    ```

CRITICAL: Extract all type definitions, field names, and message shapes from the ACTUAL source files listed in context. Do NOT write from memory — read each source file and copy/extract accurately. The spec's accuracy depends on this.

The document should be 400-600 lines of markdown. Comprehensive but not padded.
  </action>
  <verify>
- `docs/BLOCKS_FRAMEWORK.md` exists and has 300+ lines
- Contains all 11 sections listed above
- All postMessage types from editor-protocol.ts are documented
- Real JSON examples from anjo.chat are included (not fabricated)
- Machine-checkable checklist has 8+ items with verify fields
- Both integration paths have code examples
  </verify>
  <done>
A developer or AI agent reading docs/BLOCKS_FRAMEWORK.md can understand the complete .deco/ convention, block format, page format, data-block-id requirement, both bridge integration paths, full postMessage protocol, troubleshooting steps, and can run the compatibility checklist — all without reading any other file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Claude skill and starter template copies</name>
  <files>.claude/commands/deco/blocks-framework.md, packages/starter-template/BLOCKS_FRAMEWORK.md</files>
  <action>
1. Create `.claude/commands/deco/blocks-framework.md` with frontmatter:
   ```
   ---
   description: Blocks framework specification for making TypeScript sites deco-compatible
   ---
   ```
   Then the FULL content of `docs/BLOCKS_FRAMEWORK.md` (identical copy, not a condensed version). Per user decision: "Full copy in the starter template — same BLOCKS_FRAMEWORK.md, one source of truth, no condensed version."

2. Copy `docs/BLOCKS_FRAMEWORK.md` to `packages/starter-template/BLOCKS_FRAMEWORK.md` (identical content, no frontmatter wrapper for this one since it's just a markdown file in the template).

Both copies must be byte-identical to the canonical `docs/BLOCKS_FRAMEWORK.md` content (the Claude skill adds frontmatter on top, the starter template is a direct copy).
  </action>
  <verify>
- `.claude/commands/deco/blocks-framework.md` exists and has frontmatter with description field
- `packages/starter-template/BLOCKS_FRAMEWORK.md` exists
- Content body of all three files is identical (diff the body sections)
  </verify>
  <done>
The spec is available as `/deco:blocks-framework` Claude Code skill, in the canonical docs location, and bundled with new projects created from the starter template.
  </done>
</task>

</tasks>

<verification>
1. `docs/BLOCKS_FRAMEWORK.md` exists with 300+ lines
2. `.claude/commands/deco/blocks-framework.md` exists with frontmatter + full spec content
3. `packages/starter-template/BLOCKS_FRAMEWORK.md` exists with full spec content
4. All postMessage types from `editor-protocol.ts` appear in the spec
5. Real anjo.chat block JSON and page JSON examples are included
6. Machine-checkable compatibility checklist has structured verify fields
7. Both integration paths (Vite plugin + explicit bridge) documented with code examples
8. Troubleshooting section has 7 items ordered by likelihood
</verification>

<success_criteria>
An AI agent invoking `/deco:blocks-framework` receives a complete, accurate specification sufficient to make any TypeScript site deco-compatible without reading additional source files. The spec matches the actual codebase implementation (not hypothetical features).
</success_criteria>

<output>
After completion, create `.planning/phases/10-documentation-validation/10-01-SUMMARY.md`
</output>
