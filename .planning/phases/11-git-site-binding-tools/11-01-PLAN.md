---
phase: 11-git-site-binding-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - /Users/guilherme/Projects/mcps/local-fs/server/git.ts
  - /Users/guilherme/Projects/mcps/local-fs/server/tools.ts
  - /Users/guilherme/Projects/mesh/packages/bindings/src/well-known/site.ts
  - /Users/guilherme/Projects/mcps/local-fs/server/mcp.test.ts
autonomous: true
requirements:
  - DIFF-01
  - DIFF-02
  - DIFF-03
  - DIFF-04
  - DIFF-05
  - COMMIT-01
  - COMMIT-02
  - COMMIT-03
  - HIST-01
  - HIST-02
  - HIST-03

must_haves:
  truths:
    - "GIT_STATUS tool returns typed file status list (modified/added/deleted/untracked/renamed) distinguishing staged vs unstaged per file"
    - "GIT_DIFF tool returns raw unified diff string between working tree and HEAD for a given path (or whole repo)"
    - "GIT_LOG tool returns commits (hash, author, date, message) touching a file or the full repo, default limit 50"
    - "GIT_SHOW tool returns file content string at a specific commit hash"
    - "GIT_CHECKOUT reverts file(s) to HEAD or a specified commit and requires force:true to execute (throws without it)"
    - "GIT_COMMIT stages all changes (git add -A), auto-configures identity from fallback, commits with provided message, returns {hash, message}"
    - "SITE_BINDING in site.ts declares all 6 new tools as optional ToolBinder entries (opt:true)"
    - "tools.ts calls registerGitTools(server, storage) so all 6 tools are available at runtime"
  artifacts:
    - path: "/Users/guilherme/Projects/mcps/local-fs/server/git.ts"
      provides: "All 6 git MCP tools implemented using execFile"
      exports: ["registerGitTools"]
    - path: "/Users/guilherme/Projects/mcps/local-fs/server/tools.ts"
      provides: "registerTools calls registerGitTools"
      contains: "registerGitTools(server, storage)"
    - path: "/Users/guilherme/Projects/mesh/packages/bindings/src/well-known/site.ts"
      provides: "SITE_BINDING extended with 6 optional git tool entries"
      contains: "GIT_STATUS"
    - path: "/Users/guilherme/Projects/mcps/local-fs/server/mcp.test.ts"
      provides: "Tests for all 6 git tools"
      contains: "GIT_STATUS"
  key_links:
    - from: "/Users/guilherme/Projects/mcps/local-fs/server/tools.ts"
      to: "/Users/guilherme/Projects/mcps/local-fs/server/git.ts"
      via: "import { registerGitTools } from ./git.js"
      pattern: "registerGitTools"
    - from: "/Users/guilherme/Projects/mcps/local-fs/server/git.ts"
      to: "storage.resolvePath / storage.root"
      via: "resolvePath() for traversal guard, storage.root as cwd for execFile"
      pattern: "storage\\.resolvePath|storage\\.root"
    - from: "/Users/guilherme/Projects/mesh/packages/bindings/src/well-known/site.ts"
      to: "SITE_BINDING array"
      via: "6 new ToolBinder entries with opt:true"
      pattern: "GIT_STATUS.*opt.*true"
---

<objective>
Implement the server-side git API for the site editor — 6 MCP tools (GIT_STATUS, GIT_DIFF, GIT_LOG, GIT_SHOW, GIT_CHECKOUT, GIT_COMMIT) in the local-fs MCP plus SITE_BINDING declaration in the mesh bindings package.

Purpose: Phases 12-14 consume these tools to show diff badges, history panels, and commit/revert UI. This phase delivers the server-side API only — no UI.

Output: git.ts (new), tools.ts (modified), site.ts (modified), mcp.test.ts (modified)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/11-git-site-binding-tools/11-CONTEXT.md
@.planning/phases/11-git-site-binding-tools/11-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create git.ts with 6 MCP tools using execFile</name>
  <files>/Users/guilherme/Projects/mcps/local-fs/server/git.ts</files>
  <action>
Create `/Users/guilherme/Projects/mcps/local-fs/server/git.ts` from scratch. This file exports one function: `registerGitTools(server: McpServer, storage: LocalFileStorage): void`.

**Imports needed:**
```typescript
import { execFile } from "node:child_process";
import { promisify } from "node:util";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import type { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";
import type { LocalFileStorage } from "./storage.js";

const execFileAsync = promisify(execFile);
```

**Helper — runGit(storage, args):**
```typescript
async function runGit(storage: LocalFileStorage, args: string[]): Promise<string> {
  const { stdout } = await execFileAsync("git", args, { cwd: storage.root });
  return stdout;
}
```

**Path guard helper — resolveRelative(storage, path):**
```typescript
function resolveRelative(storage: LocalFileStorage, path: string): string {
  // This validates traversal AND returns the absolute path.
  // We only need to confirm it stays in root; git receives relative path.
  storage.resolvePath(path); // throws if traversal detected
  return path; // return original relative path for use as git argument
}
```

**Tool 1 — GIT_STATUS:**
```typescript
server.registerTool(
  "GIT_STATUS",
  {
    title: "Git Status",
    description:
      "Return the working-tree status for the repository (or a specific path). " +
      "Distinguishes modified, added, deleted, untracked, and renamed files. " +
      "Each entry reports staged and unstaged status separately. " +
      "Only works within the allowed directory.",
    inputSchema: {
      path: z
        .string()
        .optional()
        .describe("File or directory path relative to project root. Defaults to full repo."),
    },
    annotations: { readOnlyHint: true },
  },
  async (args): Promise<CallToolResult> => {
    try {
      const gitArgs = ["status", "--porcelain=v1", "--untracked-files=all"];
      if (args.path) {
        resolveRelative(storage, args.path);
        gitArgs.push("--", args.path);
      }
      const stdout = await runGit(storage, gitArgs);
      const files = parseGitStatus(stdout);
      return {
        content: [{ type: "text", text: JSON.stringify(files, null, 2) }],
        structuredContent: { files },
      };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${(error as Error).message}` }],
        isError: true,
      };
    }
  },
);
```

**parseGitStatus helper** — parses `--porcelain=v1` output. Each line is `XY path` or `XY new\told` for renames. X=staged column, Y=unstaged column. `?? ` = untracked.

```typescript
type GitStatusEnum = "modified" | "added" | "deleted" | "untracked" | "renamed";

interface GitFileStatus {
  path: string;
  oldPath?: string;
  staged: GitStatusEnum | null;
  unstaged: GitStatusEnum | null;
}

function parseGitStatus(output: string): GitFileStatus[] {
  if (!output.trim()) return [];
  return output
    .trim()
    .split("\n")
    .map((line): GitFileStatus | null => {
      if (line.length < 4) return null;
      const X = line[0]; // staged column
      const Y = line[1]; // unstaged column
      const rest = line.slice(3);

      // Untracked
      if (X === "?" && Y === "?") {
        return { path: rest, staged: null, unstaged: "untracked" };
      }

      // Rename: "new\told" (tab separated)
      if (X === "R" || Y === "R") {
        const [newPath, oldPath] = rest.split("\t");
        return {
          path: newPath,
          oldPath,
          staged: X === "R" ? "renamed" : null,
          unstaged: Y === "R" ? "renamed" : null,
        };
      }

      const toStatus = (c: string): GitStatusEnum | null => {
        if (c === "M") return "modified";
        if (c === "A") return "added";
        if (c === "D") return "deleted";
        return null;
      };

      return {
        path: rest,
        staged: toStatus(X),
        unstaged: toStatus(Y),
      };
    })
    .filter((x): x is GitFileStatus => x !== null);
}
```

**Tool 2 — GIT_DIFF:**
```typescript
server.registerTool(
  "GIT_DIFF",
  {
    title: "Git Diff",
    description:
      "Return the unified diff between the working tree and HEAD for a file or the whole repo. " +
      "Returns empty string if there are no changes. Only works within the allowed directory.",
    inputSchema: {
      path: z
        .string()
        .optional()
        .describe("File path relative to project root. Defaults to full repo."),
    },
    annotations: { readOnlyHint: true },
  },
  async (args): Promise<CallToolResult> => {
    try {
      const gitArgs = ["diff", "HEAD"];
      if (args.path) {
        resolveRelative(storage, args.path);
        gitArgs.push("--", args.path);
      }
      const diff = await runGit(storage, gitArgs);
      return {
        content: [{ type: "text", text: diff }],
        structuredContent: { diff },
      };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${(error as Error).message}` }],
        isError: true,
      };
    }
  },
);
```

**Tool 3 — GIT_LOG:**
```typescript
server.registerTool(
  "GIT_LOG",
  {
    title: "Git Log",
    description:
      "Return the commit history for a file or the whole repository. " +
      "Each entry includes hash, author, date (ISO 8601), and message. " +
      "Only works within the allowed directory.",
    inputSchema: {
      path: z
        .string()
        .optional()
        .describe("File path relative to project root. Omit for full repo log."),
      limit: z
        .number()
        .optional()
        .default(50)
        .describe("Maximum number of commits to return (default 50)."),
    },
    annotations: { readOnlyHint: true },
  },
  async (args): Promise<CallToolResult> => {
    try {
      const limit = args.limit ?? 50;
      // Use NUL-delimited format for safe parsing: hash\x00author\x00date\x00message\x1F per commit
      const format = "%H%x00%an%x00%aI%x00%s%x1F";
      const gitArgs = ["log", `--max-count=${limit}`, `--format=${format}`];
      if (args.path) {
        resolveRelative(storage, args.path);
        gitArgs.push("--", args.path);
      }
      const stdout = await runGit(storage, gitArgs);
      const commits = parseGitLog(stdout);
      return {
        content: [{ type: "text", text: JSON.stringify(commits, null, 2) }],
        structuredContent: { commits },
      };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${(error as Error).message}` }],
        isError: true,
      };
    }
  },
);
```

**parseGitLog helper:**
```typescript
interface GitCommit {
  hash: string;
  author: string;
  date: string;
  message: string;
}

function parseGitLog(output: string): GitCommit[] {
  if (!output.trim()) return [];
  return output
    .split("\x1F")
    .map((block) => block.trim())
    .filter(Boolean)
    .map((block) => {
      const [hash, author, date, ...msgParts] = block.split("\x00");
      return {
        hash: hash?.trim() ?? "",
        author: author?.trim() ?? "",
        date: date?.trim() ?? "",
        message: msgParts.join("\x00").trim(),
      };
    })
    .filter((c) => c.hash.length > 0);
}
```

**Tool 4 — GIT_SHOW:**
```typescript
server.registerTool(
  "GIT_SHOW",
  {
    title: "Git Show",
    description:
      "Return the contents of a file at a specific commit hash. " +
      "Use GIT_LOG to find commit hashes. Only works within the allowed directory.",
    inputSchema: {
      path: z.string().describe("File path relative to project root."),
      commitHash: z.string().describe("Git commit SHA to read from."),
    },
    annotations: { readOnlyHint: true },
  },
  async (args): Promise<CallToolResult> => {
    try {
      resolveRelative(storage, args.path);
      const content = await runGit(storage, ["show", `${args.commitHash}:${args.path}`]);
      return {
        content: [{ type: "text", text: content }],
        structuredContent: { content },
      };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${(error as Error).message}` }],
        isError: true,
      };
    }
  },
);
```

**Tool 5 — GIT_CHECKOUT:**
```typescript
server.registerTool(
  "GIT_CHECKOUT",
  {
    title: "Git Checkout",
    description:
      "Revert a file to HEAD or a specified commit, discarding working-tree changes. " +
      "DESTRUCTIVE: requires force=true to confirm intent. " +
      "Only works within the allowed directory.",
    inputSchema: {
      path: z.string().describe("File path relative to project root."),
      commitHash: z
        .string()
        .optional()
        .describe("Commit to restore from. Defaults to HEAD."),
      force: z
        .boolean()
        .optional()
        .describe("Must be true to confirm destructive operation."),
    },
    annotations: { readOnlyHint: false, destructiveHint: true },
  },
  async (args): Promise<CallToolResult> => {
    try {
      if (!args.force) {
        throw new Error(
          "GIT_CHECKOUT is destructive and discards working-tree changes. Pass force=true to confirm.",
        );
      }
      resolveRelative(storage, args.path);
      const ref = args.commitHash ?? "HEAD";
      await runGit(storage, ["checkout", ref, "--", args.path]);
      return {
        content: [{ type: "text", text: `Restored ${args.path} to ${ref}` }],
        structuredContent: { path: args.path, ref },
      };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${(error as Error).message}` }],
        isError: true,
      };
    }
  },
);
```

**Tool 6 — GIT_COMMIT:**
```typescript
server.registerTool(
  "GIT_COMMIT",
  {
    title: "Git Commit",
    description:
      "Stage all changes (tracked and untracked) and create a git commit. " +
      "Pre-checks that the working tree is dirty before staging. " +
      "Auto-configures git identity if not set. Returns the new commit hash and message. " +
      "Only works within the allowed directory.",
    inputSchema: {
      message: z.string().describe("Commit message."),
    },
    annotations: { readOnlyHint: false, destructiveHint: false },
  },
  async (args): Promise<CallToolResult> => {
    try {
      // Pre-check: working tree must be dirty
      const statusOut = await runGit(storage, [
        "status",
        "--porcelain=v1",
        "--untracked-files=all",
      ]);
      if (!statusOut.trim()) {
        throw new Error("Nothing to commit: working tree is clean.");
      }

      // Stage all changes including untracked
      await runGit(storage, ["add", "-A"]);

      // Commit with identity fallback via -c flags
      const { stdout } = await execFileAsync(
        "git",
        [
          "-c",
          "user.name=Deco Editor",
          "-c",
          "user.email=editor@deco.cx",
          "commit",
          "--message",
          args.message,
        ],
        { cwd: storage.root },
      );

      // Extract hash from commit output (format: "[branch hash] message")
      const hashMatch = stdout.match(/\[[\w/.-]+ ([0-9a-f]+)\]/);
      const hash = hashMatch?.[1] ?? "";

      const result = { hash, message: args.message };
      return {
        content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
        structuredContent: result,
      };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${(error as Error).message}` }],
        isError: true,
      };
    }
  },
);
```

**Note on GIT_COMMIT identity:** The `-c user.name=X -c user.email=Y` flags only override if no global/local identity is configured — git uses them as fallback config, not forced override. This matches the decision: "auto-configures git identity with a fallback." If the repo already has user.name/email configured, those take precedence. To implement the fallback correctly, use `--author` only when git config is absent. Simpler approach: always pass `-c user.name=... -c user.email=...` as they override for this invocation but don't persist — this is the correct implementation as they take effect only for this commit call.

Run `bun run fmt` after writing the file to ensure Biome formatting.
  </action>
  <verify>
From `/Users/guilherme/Projects/mcps/local-fs`:
```bash
bun run fmt
bun run check
```
Both must complete without errors. The file must export `registerGitTools`.
  </verify>
  <done>git.ts exists with registerGitTools exporting 6 tools; TypeScript check passes; file is Biome-formatted.</done>
</task>

<task type="auto">
  <name>Task 2: Wire git tools into tools.ts and extend SITE_BINDING in site.ts</name>
  <files>
    /Users/guilherme/Projects/mcps/local-fs/server/tools.ts
    /Users/guilherme/Projects/mesh/packages/bindings/src/well-known/site.ts
  </files>
  <action>
**Part A — tools.ts modification:**

Add import at the top of `/Users/guilherme/Projects/mcps/local-fs/server/tools.ts` (after existing imports):
```typescript
import { registerGitTools } from "./git.js";
```

At the end of the `registerTools` function body (just before the closing `}`), add:
```typescript
  registerGitTools(server, storage);
```

**Part B — site.ts SITE_BINDING extension:**

In `/Users/guilherme/Projects/mesh/packages/bindings/src/well-known/site.ts`, add 6 new schema pairs and 6 new entries to the SITE_BINDING array.

Add these schema definitions after the existing `ReadFileAtOutputSchema` / types block (around line 202, before the `// Binding Definition` comment):

```typescript
// ============================================================================
// Git Tool Schemas (optional -- git-native editing, phases 12-14)
// ============================================================================

/**
 * GIT_STATUS - Return working-tree status
 */
const GitStatusInputSchema = z.object({
  path: z
    .string()
    .optional()
    .describe("File or directory path relative to project root. Defaults to full repo."),
});

const GitStatusOutputSchema = z.object({
  files: z.array(
    z.object({
      path: z.string(),
      oldPath: z.string().optional(),
      staged: z
        .enum(["modified", "added", "deleted", "untracked", "renamed"])
        .nullable(),
      unstaged: z
        .enum(["modified", "added", "deleted", "untracked", "renamed"])
        .nullable(),
    }),
  ),
});

export type GitStatusInput = z.infer<typeof GitStatusInputSchema>;
export type GitStatusOutput = z.infer<typeof GitStatusOutputSchema>;

/**
 * GIT_DIFF - Return unified diff between working tree and HEAD
 */
const GitDiffInputSchema = z.object({
  path: z
    .string()
    .optional()
    .describe("File path relative to project root. Defaults to full repo."),
});

const GitDiffOutputSchema = z.object({
  diff: z.string().describe("Raw unified diff output"),
});

export type GitDiffInput = z.infer<typeof GitDiffInputSchema>;
export type GitDiffOutput = z.infer<typeof GitDiffOutputSchema>;

/**
 * GIT_LOG - Return commit history for a file or repo
 */
const GitLogInputSchema = z.object({
  path: z
    .string()
    .optional()
    .describe("File path relative to project root. Omit for full repo log."),
  limit: z
    .number()
    .optional()
    .describe("Maximum number of commits to return (default 50)."),
});

const GitLogOutputSchema = z.object({
  commits: z.array(
    z.object({
      hash: z.string(),
      author: z.string(),
      date: z.string(),
      message: z.string(),
    }),
  ),
});

export type GitLogInput = z.infer<typeof GitLogInputSchema>;
export type GitLogOutput = z.infer<typeof GitLogOutputSchema>;

/**
 * GIT_SHOW - Return file content at a specific commit
 */
const GitShowInputSchema = z.object({
  path: z.string().describe("File path relative to project root."),
  commitHash: z.string().describe("Git commit SHA to read from."),
});

const GitShowOutputSchema = z.object({
  content: z.string().describe("File content at the specified commit."),
});

export type GitShowInput = z.infer<typeof GitShowInputSchema>;
export type GitShowOutput = z.infer<typeof GitShowOutputSchema>;

/**
 * GIT_CHECKOUT - Revert file to HEAD or a specified commit
 */
const GitCheckoutInputSchema = z.object({
  path: z.string().describe("File path relative to project root."),
  commitHash: z
    .string()
    .optional()
    .describe("Commit to restore from. Defaults to HEAD."),
  force: z
    .boolean()
    .optional()
    .describe("Must be true to confirm destructive operation."),
});

const GitCheckoutOutputSchema = z.object({
  path: z.string(),
  ref: z.string(),
});

export type GitCheckoutInput = z.infer<typeof GitCheckoutInputSchema>;
export type GitCheckoutOutput = z.infer<typeof GitCheckoutOutputSchema>;

/**
 * GIT_COMMIT - Stage all changes and create a commit
 */
const GitCommitInputSchema = z.object({
  message: z.string().describe("Commit message."),
});

const GitCommitOutputSchema = z.object({
  hash: z.string().describe("New commit hash."),
  message: z.string().describe("Commit message."),
});

export type GitCommitInput = z.infer<typeof GitCommitInputSchema>;
export type GitCommitOutput = z.infer<typeof GitCommitOutputSchema>;
```

Then extend the `SITE_BINDING` array by appending 6 entries before the closing `] as const satisfies Binder`:

```typescript
  {
    name: "GIT_STATUS" as const,
    inputSchema: GitStatusInputSchema,
    outputSchema: GitStatusOutputSchema,
    opt: true,
  } satisfies ToolBinder<"GIT_STATUS", GitStatusInput, GitStatusOutput>,
  {
    name: "GIT_DIFF" as const,
    inputSchema: GitDiffInputSchema,
    outputSchema: GitDiffOutputSchema,
    opt: true,
  } satisfies ToolBinder<"GIT_DIFF", GitDiffInput, GitDiffOutput>,
  {
    name: "GIT_LOG" as const,
    inputSchema: GitLogInputSchema,
    outputSchema: GitLogOutputSchema,
    opt: true,
  } satisfies ToolBinder<"GIT_LOG", GitLogInput, GitLogOutput>,
  {
    name: "GIT_SHOW" as const,
    inputSchema: GitShowInputSchema,
    outputSchema: GitShowOutputSchema,
    opt: true,
  } satisfies ToolBinder<"GIT_SHOW", GitShowInput, GitShowOutput>,
  {
    name: "GIT_CHECKOUT" as const,
    inputSchema: GitCheckoutInputSchema,
    outputSchema: GitCheckoutOutputSchema,
    opt: true,
  } satisfies ToolBinder<"GIT_CHECKOUT", GitCheckoutInput, GitCheckoutOutput>,
  {
    name: "GIT_COMMIT" as const,
    inputSchema: GitCommitInputSchema,
    outputSchema: GitCommitOutputSchema,
    opt: true,
  } satisfies ToolBinder<"GIT_COMMIT", GitCommitInput, GitCommitOutput>,
```

After edits, run `bun run fmt` in both repos to ensure Biome formatting.
  </action>
  <verify>
From `/Users/guilherme/Projects/mcps/local-fs`:
```bash
bun run check
```
From `/Users/guilherme/Projects/mesh`:
```bash
bun run check
```
Both must pass. Verify site.ts contains "GIT_STATUS" and tools.ts contains "registerGitTools".
  </verify>
  <done>tools.ts calls registerGitTools; site.ts SITE_BINDING has 6 new optional entries (GIT_STATUS through GIT_COMMIT); TypeScript check passes in both repos.</done>
</task>

<task type="auto">
  <name>Task 3: Add git tool integration tests to mcp.test.ts</name>
  <files>/Users/guilherme/Projects/mcps/local-fs/server/mcp.test.ts</files>
  <action>
Append a new `describe("git tools", ...)` block to `/Users/guilherme/Projects/mcps/local-fs/server/mcp.test.ts`. The tests use the existing `client`, `storage`, and `tempDir` fixtures set up in `beforeAll`. The temp directory is a git repo because the tests need git — initialize one in a new `describe` block with its own `beforeAll`.

Add this after the last existing `describe` block (before the closing `});` of the outer `describe("MCP Server Integration", ...)`):

```typescript
  describe("git tools", () => {
    const { execFile } = require("node:child_process");
    const { promisify } = require("node:util");
    const execFileAsync = promisify(execFile);

    // Initialize git repo in tempDir before git tests
    beforeAll(async () => {
      await execFileAsync("git", ["init"], { cwd: tempDir });
      await execFileAsync("git", ["config", "user.email", "test@test.com"], { cwd: tempDir });
      await execFileAsync("git", ["config", "user.name", "Test"], { cwd: tempDir });
    });

    test("GIT_STATUS returns empty list when repo is clean", async () => {
      // Commit everything so working tree is clean
      await storage.write("status-test-seed.txt", "seed");
      await execFileAsync("git", ["add", "-A"], { cwd: tempDir });
      await execFileAsync("git", ["commit", "-m", "seed commit"], { cwd: tempDir });

      const result = await client.callTool({
        name: "GIT_STATUS",
        arguments: {},
      });
      expect(result.isError).toBeFalsy();
      const sc = (result as any).structuredContent as { files: unknown[] };
      expect(sc.files).toEqual([]);
    });

    test("GIT_STATUS detects a modified file", async () => {
      await storage.write("status-test-seed.txt", "modified content");

      const result = await client.callTool({
        name: "GIT_STATUS",
        arguments: {},
      });
      expect(result.isError).toBeFalsy();
      const sc = (result as any).structuredContent as { files: Array<{ path: string; unstaged: string }> };
      expect(sc.files.some((f) => f.unstaged === "modified")).toBe(true);
    });

    test("GIT_DIFF returns non-empty diff for modified file", async () => {
      // status-test-seed.txt is still modified from previous test
      const result = await client.callTool({
        name: "GIT_DIFF",
        arguments: { path: "status-test-seed.txt" },
      });
      expect(result.isError).toBeFalsy();
      const sc = (result as any).structuredContent as { diff: string };
      expect(sc.diff.length).toBeGreaterThan(0);
      expect(sc.diff).toContain("modified content");
    });

    test("GIT_DIFF returns empty string when no changes", async () => {
      // Reset the file to HEAD state
      await execFileAsync("git", ["checkout", "HEAD", "--", "status-test-seed.txt"], { cwd: tempDir });

      const result = await client.callTool({
        name: "GIT_DIFF",
        arguments: { path: "status-test-seed.txt" },
      });
      expect(result.isError).toBeFalsy();
      const sc = (result as any).structuredContent as { diff: string };
      expect(sc.diff).toBe("");
    });

    test("GIT_LOG returns commit history", async () => {
      const result = await client.callTool({
        name: "GIT_LOG",
        arguments: { path: "status-test-seed.txt" },
      });
      expect(result.isError).toBeFalsy();
      const sc = (result as any).structuredContent as { commits: Array<{ hash: string; message: string }> };
      expect(sc.commits.length).toBeGreaterThan(0);
      expect(sc.commits[0].hash.length).toBeGreaterThan(0);
      expect(sc.commits[0].message).toBe("seed commit");
    });

    test("GIT_SHOW returns file content at a commit", async () => {
      // Get the commit hash from GIT_LOG
      const logResult = await client.callTool({
        name: "GIT_LOG",
        arguments: { path: "status-test-seed.txt" },
      });
      const sc = (logResult as any).structuredContent as { commits: Array<{ hash: string }> };
      const hash = sc.commits[0].hash;

      const showResult = await client.callTool({
        name: "GIT_SHOW",
        arguments: { path: "status-test-seed.txt", commitHash: hash },
      });
      expect(showResult.isError).toBeFalsy();
      const showSc = (showResult as any).structuredContent as { content: string };
      expect(showSc.content).toBe("seed");
    });

    test("GIT_CHECKOUT without force=true returns error", async () => {
      const result = await client.callTool({
        name: "GIT_CHECKOUT",
        arguments: { path: "status-test-seed.txt" },
      });
      expect(result.isError).toBe(true);
      expect(
        (result.content[0] as { text: string }).text,
      ).toContain("force=true");
    });

    test("GIT_CHECKOUT with force=true reverts the file", async () => {
      // Modify the file first
      await storage.write("status-test-seed.txt", "will be reverted");

      const result = await client.callTool({
        name: "GIT_CHECKOUT",
        arguments: { path: "status-test-seed.txt", force: true },
      });
      expect(result.isError).toBeFalsy();

      // File should be back to seed content
      const readResult = await storage.read("status-test-seed.txt");
      expect(readResult.content).toBe("seed");
    });

    test("GIT_COMMIT stages and commits with message, returns hash", async () => {
      await storage.write("commit-test.txt", "content for commit");

      const result = await client.callTool({
        name: "GIT_COMMIT",
        arguments: { message: "test commit from MCP" },
      });
      expect(result.isError).toBeFalsy();
      const sc = (result as any).structuredContent as { hash: string; message: string };
      expect(sc.hash.length).toBeGreaterThan(0);
      expect(sc.message).toBe("test commit from MCP");
    });

    test("GIT_COMMIT throws when working tree is clean", async () => {
      const result = await client.callTool({
        name: "GIT_COMMIT",
        arguments: { message: "should fail" },
      });
      expect(result.isError).toBe(true);
      expect(
        (result.content[0] as { text: string }).text,
      ).toContain("Nothing to commit");
    });
  });
```

Run `bun run fmt` after editing.
  </action>
  <verify>
From `/Users/guilherme/Projects/mcps/local-fs`:
```bash
bun test server/mcp.test.ts 2>&1 | tail -20
```
All git tool tests must pass (green). Any pre-existing tests must continue to pass.
  </verify>
  <done>All 9 new git tool tests pass; no regressions in existing tests; file is Biome-formatted.</done>
</task>

</tasks>

<verification>
After all tasks complete, verify end-to-end:

1. `bun run check` passes in `/Users/guilherme/Projects/mcps/local-fs` — git.ts and tools.ts are type-correct
2. `bun run check` passes in `/Users/guilherme/Projects/mesh` — site.ts SITE_BINDING extension is type-correct
3. `bun test server/mcp.test.ts` passes in `/Users/guilherme/Projects/mcps/local-fs` — all 9 git tests green
4. The `tools/list` test in mcp.test.ts now includes GIT_STATUS, GIT_DIFF, GIT_LOG, GIT_SHOW, GIT_CHECKOUT, GIT_COMMIT in its expected tool names (update the list-tools test to include these 6 names)
5. `bun run fmt` produces no changes — everything is already formatted

Spot-check:
- `git.ts` uses `execFile` (not `exec`) — no shell injection vulnerability
- `resolveRelative` calls `storage.resolvePath()` for traversal guard before passing relative path to git
- `GIT_COMMIT` passes `-c user.name=... -c user.email=...` to handle identity fallback
- All 6 SITE_BINDING entries have `opt: true`
</verification>

<success_criteria>
- git.ts created with registerGitTools exporting 6 tools (GIT_STATUS, GIT_DIFF, GIT_LOG, GIT_SHOW, GIT_CHECKOUT, GIT_COMMIT)
- tools.ts imports and calls registerGitTools
- SITE_BINDING has 6 new optional entries covering all 6 git tools
- All git tool tests pass
- TypeScript check passes in both repos
- Phase 12-14 can now call these tools to build diff badges, history UI, and commit/revert flows
</success_criteria>

<output>
After completion, create `.planning/phases/11-git-site-binding-tools/11-01-SUMMARY.md` following the summary template.
</output>
