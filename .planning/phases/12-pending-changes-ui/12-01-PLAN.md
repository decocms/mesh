---
phase: 12-pending-changes-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mesh-plugin-site-editor/client/lib/pending-changes-api.ts
  - packages/mesh-plugin-site-editor/client/lib/use-pending-changes.ts
  - packages/mesh-plugin-site-editor/client/lib/query-keys.ts
  - packages/mesh-plugin-site-editor/client/components/section-list-sidebar.tsx
  - packages/mesh-plugin-site-editor/client/components/page-composer.tsx
autonomous: true
requirements:
  - DIFF-01
  - DIFF-02
  - DIFF-03
  - DIFF-04
  - DIFF-05
must_haves:
  truths:
    - "GIT_STATUS called on `.deco/pages/${pageId}.json` returns isDirty; GIT_SHOW on HEAD gives committed JSON for section-level diffing"
    - "Section items in the sidebar show colored badges: '(new)' in green, '(edited)' in yellow, '(deleted)' in muted red with greyed text"
    - "Deleted sections (present in HEAD JSON, absent in current blocks) appear at the bottom of the section list as greyed-out ghost rows with an Undelete button"
    - "Undelete restores the committed section object from the GIT_SHOW result into the current blocks array and triggers a save — no git operation needed"
    - "Discard Changes button appears in the composer toolbar only when isDirty is true; clicking it calls GIT_CHECKOUT with force:true then refetches the page"
    - "The usePendingChanges hook is triggered after every save (invalidate the pendingChanges query key) and never uses useEffect"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/lib/pending-changes-api.ts"
      provides: "getGitStatus() and getCommittedPage() helper functions that call GIT_STATUS and GIT_SHOW via toolCaller; discardPageChanges() calling GIT_CHECKOUT"
    - path: "packages/mesh-plugin-site-editor/client/lib/use-pending-changes.ts"
      provides: "usePendingChanges(toolCaller, connectionId, pageId) hook returning { sectionStatuses, isDirty, refetch } using useQuery"
    - path: "packages/mesh-plugin-site-editor/client/components/section-list-sidebar.tsx"
      provides: "Augmented SectionListSidebar that accepts sectionStatuses prop, renders diff badges and deleted ghost rows with Undelete button"
    - path: "packages/mesh-plugin-site-editor/client/components/page-composer.tsx"
      provides: "Discard Changes button in toolbar, wires usePendingChanges, passes sectionStatuses + onUndelete to SectionListSidebar"
  key_links:
    - from: "page-composer.tsx"
      to: "use-pending-changes.ts"
      via: "usePendingChanges(toolCaller, connectionId, pageId)"
      pattern: "useQuery-based hook, refetched after save by invalidating queryKeys.pendingChanges.page"
    - from: "page-composer.tsx"
      to: "section-list-sidebar.tsx"
      via: "sectionStatuses prop + onUndelete callback"
      pattern: "lift state up — composer owns the statuses, sidebar renders them"
    - from: "use-pending-changes.ts"
      to: "pending-changes-api.ts"
      via: "getGitStatus() + getCommittedPage()"
      pattern: "pure async helpers mirroring branch-api.ts / history-api.ts patterns"
    - from: "page-composer.tsx (Discard button)"
      to: "pending-changes-api.ts"
      via: "discardPageChanges(toolCaller, pageFilePath)"
      pattern: "mutation calling GIT_CHECKOUT {path, force:true} then queryClient.invalidateQueries"
---

## Overview

This plan implements the Pending Changes UI for the site editor page composer. When a user edits a page, the composer sidebar shows per-section diff badges derived from comparing the committed HEAD version of the page JSON against the in-memory blocks. A "Discard Changes" button in the toolbar allows resetting the working tree. Deleted sections (committed but removed from current blocks) appear as greyed-out ghost rows with an Undelete action.

All new code follows established patterns from the site editor plugin:
- API helpers in `lib/` following `branch-api.ts` / `history-api.ts` patterns (plain `async` functions, graceful `try/catch` returning null on failure)
- Data fetching via `useQuery` from `@tanstack/react-query` — no `useEffect`
- Tool calls via `toolCaller` from `usePluginContext<typeof SITE_BINDING>()`
- Query key constants in `query-keys.ts`

---

## Task 1: Create `pending-changes-api.ts`

**File:** `packages/mesh-plugin-site-editor/client/lib/pending-changes-api.ts`

Create a new file following the `branch-api.ts` / `history-api.ts` pattern. Export three async functions:

### `getGitStatus(toolCaller, filePath)`
Calls `GIT_STATUS` with `{ path: filePath }`. Returns the status object for the given file, or `null` if the tool throws (tool not supported or file not tracked).

```typescript
import type { TypedToolCaller } from "@decocms/bindings";
import type { SiteBinding } from "@decocms/bindings/site";
import type { BlockInstance } from "./page-api";

type ToolCaller = TypedToolCaller<SiteBinding>;

export interface FileStatus {
  path: string;
  staged: "modified" | "added" | "deleted" | "untracked" | "renamed" | null;
  unstaged: "modified" | "added" | "deleted" | "untracked" | "renamed" | null;
}

export async function getGitStatus(
  toolCaller: ToolCaller,
  filePath: string,
): Promise<FileStatus | null> {
  try {
    const result = await toolCaller("GIT_STATUS", { path: filePath });
    return result.files.find((f) => f.path === filePath) ?? null;
  } catch {
    return null;
  }
}
```

### `getCommittedPage(toolCaller, filePath)`
Calls `GIT_SHOW` with `{ path: filePath, commitHash: "HEAD" }`. Parses the JSON and returns the blocks array from the committed version, or `null` if the tool throws or the file is untracked.

```typescript
export async function getCommittedPage(
  toolCaller: ToolCaller,
  filePath: string,
): Promise<BlockInstance[] | null> {
  try {
    const result = await toolCaller("GIT_SHOW", {
      path: filePath,
      commitHash: "HEAD",
    });
    const page = JSON.parse(result.content);
    return Array.isArray(page.blocks) ? page.blocks : null;
  } catch {
    return null;
  }
}
```

### `discardPageChanges(toolCaller, filePath)`
Calls `GIT_CHECKOUT` with `{ path: filePath, force: true }`. Returns `true` on success, `false` on failure.

```typescript
export async function discardPageChanges(
  toolCaller: ToolCaller,
  filePath: string,
): Promise<boolean> {
  try {
    await toolCaller("GIT_CHECKOUT", { path: filePath, force: true });
    return true;
  } catch {
    return false;
  }
}
```

---

## Task 2: Add query key for pending changes in `query-keys.ts`

**File:** `packages/mesh-plugin-site-editor/client/lib/query-keys.ts`

Add a `pendingChanges` key group to the existing `queryKeys` object:

```typescript
pendingChanges: {
  page: (connectionId: string, pageId: string) =>
    ["site-editor", "pending-changes", connectionId, pageId] as const,
},
```

This sits alongside the existing `history`, `pages`, `blocks`, etc. entries.

---

## Task 3: Create `use-pending-changes.ts`

**File:** `packages/mesh-plugin-site-editor/client/lib/use-pending-changes.ts`

Create a hook that fetches pending change status for the current page. It uses `useQuery` (no `useEffect`) and returns a stable object the composer can pass down to the sidebar.

### Exported types

```typescript
export type SectionChangeStatus = "new" | "edited" | "deleted";

export interface SectionStatus {
  sectionId: string;
  status: SectionChangeStatus;
  /** Only set for deleted sections — the full block instance from HEAD */
  committedBlock?: BlockInstance;
}

export interface PendingChangesResult {
  sectionStatuses: SectionStatus[];
  isDirty: boolean;
  /** True while fetching (initial load) */
  isLoading: boolean;
}
```

### Hook signature

```typescript
export function usePendingChanges(
  toolCaller: TypedToolCaller<SiteBinding>,
  connectionId: string,
  pageId: string,
  /** Current in-memory blocks from undo/redo state */
  currentBlocks: BlockInstance[],
): PendingChangesResult
```

### Implementation logic

```typescript
import { useQuery } from "@tanstack/react-query";
import { getGitStatus, getCommittedPage } from "./pending-changes-api";
import { queryKeys } from "./query-keys";

const pageFilePath = `.deco/pages/${pageId}.json`;

// Step 1: Check if the file is dirty via GIT_STATUS
const { data: fileStatus, isLoading: isLoadingStatus } = useQuery({
  queryKey: queryKeys.pendingChanges.page(connectionId, pageId),
  queryFn: () => getGitStatus(toolCaller, pageFilePath),
  staleTime: 0, // Always re-fetch when invalidated
});

const isDirty =
  fileStatus?.unstaged != null ||
  fileStatus?.staged != null ||
  fileStatus?.unstaged === "untracked";

// Step 2: Fetch committed page blocks only when dirty
const { data: committedBlocks, isLoading: isLoadingCommitted } = useQuery({
  queryKey: [...queryKeys.pendingChanges.page(connectionId, pageId), "head"],
  queryFn: () => getCommittedPage(toolCaller, pageFilePath),
  enabled: isDirty,
  staleTime: 0,
});

// Step 3: Compute per-section statuses
const sectionStatuses = computeSectionStatuses(
  currentBlocks,
  committedBlocks ?? null,
  isDirty,
);

return {
  sectionStatuses,
  isDirty,
  isLoading: isLoadingStatus || (isDirty && isLoadingCommitted),
};
```

### `computeSectionStatuses` helper (pure function, defined in same file)

```typescript
function computeSectionStatuses(
  currentBlocks: BlockInstance[],
  committedBlocks: BlockInstance[] | null,
  isDirty: boolean,
): SectionStatus[] {
  // If not dirty or no committed data, return empty (no badges)
  if (!isDirty || !committedBlocks) {
    // If file is untracked (new page), all sections are "new"
    if (isDirty && committedBlocks === null) {
      return currentBlocks.map((b) => ({ sectionId: b.id, status: "new" }));
    }
    return [];
  }

  const statuses: SectionStatus[] = [];
  const committedMap = new Map(committedBlocks.map((b) => [b.id, b]));
  const currentMap = new Map(currentBlocks.map((b) => [b.id, b]));

  // Find new sections (in current, not in committed)
  for (const block of currentBlocks) {
    if (!committedMap.has(block.id)) {
      statuses.push({ sectionId: block.id, status: "new" });
    }
  }

  // Find edited sections (in both, but props differ)
  for (const block of currentBlocks) {
    const committed = committedMap.get(block.id);
    if (!committed) continue;
    if (JSON.stringify(block.props) !== JSON.stringify(committed.props)) {
      statuses.push({ sectionId: block.id, status: "edited" });
    }
  }

  // Find deleted sections (in committed, not in current)
  for (const block of committedBlocks) {
    if (!currentMap.has(block.id)) {
      statuses.push({
        sectionId: block.id,
        status: "deleted",
        committedBlock: block,
      });
    }
  }

  return statuses;
}
```

---

## Task 4: Augment `SectionListSidebar` with diff badges and deleted ghost rows

**File:** `packages/mesh-plugin-site-editor/client/components/section-list-sidebar.tsx`

### Changes to props interface

Add two new optional props to `SectionListSidebarProps`:

```typescript
import type { SectionStatus } from "../lib/use-pending-changes";

interface SectionListSidebarProps {
  blocks: BlockInstance[];
  selectedBlockId: string | null;
  onSelect: (blockId: string) => void;
  onDelete: (blockId: string) => void;
  onReorder: (activeId: string, overId: string) => void;
  onAddClick: () => void;
  /** Per-section diff status from usePendingChanges */
  sectionStatuses?: SectionStatus[];
  /** Called when user clicks Undelete on a deleted ghost row */
  onUndelete?: (block: import("../lib/page-api").BlockInstance) => void;
}
```

### Changes to `SortableSectionItem`

Add an optional `status` prop to `SortableSectionItemProps`:

```typescript
interface SortableSectionItemProps {
  block: BlockInstance;
  isSelected: boolean;
  onSelect: () => void;
  onDelete: () => void;
  status?: "new" | "edited";
}
```

In the item JSX, after the block label `<button>`, render a badge if `status` is set:

```tsx
{status && (
  <span
    className={cn(
      "shrink-0 text-[10px] font-medium px-1 py-0.5 rounded",
      status === "new" && "bg-green-100 text-green-700",
      status === "edited" && "bg-yellow-100 text-yellow-700",
    )}
  >
    {status === "new" ? "new" : "edited"}
  </span>
)}
```

### New `DeletedSectionGhostRow` component

Create a new component (non-sortable, not wrapped in `useSortable`) for deleted sections. Render it after the `SortableContext` block, below the live section list:

```tsx
interface DeletedSectionGhostRowProps {
  block: BlockInstance;
  onUndelete: () => void;
}

function DeletedSectionGhostRow({
  block,
  onUndelete,
}: DeletedSectionGhostRowProps) {
  return (
    <div className="flex items-center gap-1.5 px-2 py-1.5 rounded text-sm opacity-40 italic">
      <span className="shrink-0 w-5" /> {/* spacer for drag handle alignment */}
      <span className="flex-1 truncate text-muted-foreground">
        {blockLabel(block.blockType)}
      </span>
      <span className="shrink-0 text-[10px] font-medium px-1 py-0.5 rounded bg-red-100 text-red-700">
        deleted
      </span>
      <button
        type="button"
        className="shrink-0 text-xs text-blue-600 hover:text-blue-800 transition-colors whitespace-nowrap"
        onClick={(e) => {
          e.stopPropagation();
          onUndelete();
        }}
        title="Restore this section"
      >
        Undelete
      </button>
    </div>
  );
}
```

### Changes to `SectionListSidebar` render

1. Build a lookup map from `sectionStatuses` by `sectionId`.
2. Pass `status` to each `SortableSectionItem` (only `"new"` or `"edited"` — `"deleted"` is for ghost rows).
3. After the `SortableContext`, render a `DeletedSectionGhostRow` for each entry in `sectionStatuses` where `status === "deleted"`, if `onUndelete` is provided.

```tsx
const statusMap = new Map(
  (sectionStatuses ?? []).map((s) => [s.sectionId, s]),
);

const deletedStatuses = (sectionStatuses ?? []).filter(
  (s) => s.status === "deleted" && s.committedBlock,
);
```

In the `SortableContext` block items, pass `status`:

```tsx
<SortableSectionItem
  key={block.id}
  block={block}
  isSelected={selectedBlockId === block.id}
  onSelect={() => onSelect(block.id)}
  onDelete={() => onDelete(block.id)}
  status={
    statusMap.get(block.id)?.status === "deleted"
      ? undefined
      : (statusMap.get(block.id)?.status as "new" | "edited" | undefined)
  }
/>
```

After the closing `</SortableContext>`, render ghost rows:

```tsx
{deletedStatuses.length > 0 && onUndelete && (
  <div className="border-t border-dashed border-border/50 mt-1 pt-1">
    {deletedStatuses.map((s) => (
      <DeletedSectionGhostRow
        key={s.sectionId}
        block={s.committedBlock!}
        onUndelete={() => onUndelete(s.committedBlock!)}
      />
    ))}
  </div>
)}
```

---

## Task 5: Wire everything into `PageComposer`

**File:** `packages/mesh-plugin-site-editor/client/components/page-composer.tsx`

### 5a: Import new hook and API function

```typescript
import { usePendingChanges } from "../lib/use-pending-changes";
import { discardPageChanges } from "../lib/pending-changes-api";
```

### 5b: Add `usePendingChanges` call

Place this after the `localPage` and `blocks` are defined, passing `blocks` (the undo/redo-managed in-memory array):

```typescript
const { sectionStatuses, isDirty: gitIsDirty } = usePendingChanges(
  toolCaller,
  connectionId,
  pageId,
  blocks,
);
```

### 5c: Invalidate pendingChanges query after every save

In `handleSave` (after `markClean()`), and in `debouncedSave` (after `markClean()`), add:

```typescript
queryClient.invalidateQueries({
  queryKey: queryKeys.pendingChanges.page(connectionId, pageId),
});
```

This triggers `usePendingChanges` to re-fetch GIT_STATUS after each save, keeping the badges current.

### 5d: Add Discard Changes button to toolbar

In the toolbar `<div className="flex items-center gap-3">` block, add the Discard button **before** the Save button, conditionally visible only when `gitIsDirty`:

```tsx
{gitIsDirty && (
  <Button
    variant="ghost"
    size="sm"
    className="text-destructive hover:text-destructive"
    onClick={handleDiscard}
    title="Discard all uncommitted changes to this page"
  >
    <XCircle size={14} className="mr-1" />
    Discard changes
  </Button>
)}
```

Import `XCircle` from `lucide-react` (already a dep in the package).

### 5e: Implement `handleDiscard`

```typescript
const handleDiscard = async () => {
  if (saveTimerRef.current) {
    clearTimeout(saveTimerRef.current);
    saveTimerRef.current = null;
  }
  const pageFilePath = `.deco/pages/${pageId}.json`;
  const success = await discardPageChanges(toolCaller, pageFilePath);
  if (success) {
    markClean();
    toast.success("Changes discarded");
    queryClient.invalidateQueries({
      queryKey: queryKeys.pages.detail(connectionId, pageId, activeLocale),
    });
    queryClient.invalidateQueries({
      queryKey: queryKeys.pendingChanges.page(connectionId, pageId),
    });
  } else {
    toast.error("Failed to discard changes");
  }
};
```

### 5f: Implement `handleUndelete`

When the user clicks Undelete on a ghost row, restore the committed block instance into the current blocks array at the end, then trigger a save:

```typescript
const handleUndelete = (block: BlockInstance) => {
  const updatedBlocks = [...blocks, block];
  pushBlocks(updatedBlocks);
  debouncedSave(updatedBlocks);
};
```

### 5g: Pass props to `SectionListSidebar`

Update the `<SectionListSidebar>` call to pass the new props:

```tsx
<SectionListSidebar
  blocks={localPage.blocks}
  selectedBlockId={selectedBlockId}
  onSelect={(id) =>
    setSelectedBlockId((prev) => (prev === id ? null : id))
  }
  onDelete={handleDeleteBlock}
  onReorder={handleReorder}
  onAddClick={() => setShowBlockPicker(true)}
  sectionStatuses={sectionStatuses}
  onUndelete={handleUndelete}
/>
```

---

## Dependency Notes

- No new npm packages required. All tools (`GIT_STATUS`, `GIT_SHOW`, `GIT_CHECKOUT`) are already defined in `SITE_BINDING` in `packages/bindings/src/well-known/site.ts` as optional tools.
- `lucide-react` is already a dependency of the package (used in `section-list-sidebar.tsx` for `GripVertical`, `Plus`, `Trash2`).
- `@tanstack/react-query` is already used throughout the plugin.
- The `diffPages` logic in `page-diff.tsx` (Phase 10) is similar but serves a different purpose (historical commit diff). Do not reuse it — implement `computeSectionStatuses` independently in `use-pending-changes.ts` as a pure function.

## Graceful Degradation

`getGitStatus` and `getCommittedPage` both return `null` on any error (tool not available, file untracked, network issue). When `fileStatus` is `null`, `isDirty` is `false`, the Discard button is hidden, and no badges are rendered. The UI degrades silently — no error state shown for missing git tools.

## Formatting

After all changes, run `bun run fmt` from the repo root.
