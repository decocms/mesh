---
phase: 13-commit-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mesh-plugin-site-editor/client/lib/git-api.ts
  - packages/mesh-plugin-site-editor/client/lib/query-keys.ts
  - packages/mesh-plugin-site-editor/client/components/commit-dialog.tsx
  - packages/mesh-plugin-site-editor/client/components/page-composer.tsx
  - packages/mesh-plugin-site-editor/server/tools/commit-message.ts
  - packages/mesh-plugin-site-editor/server/index.ts
autonomous: true
requirements:
  - COMMIT-01
  - COMMIT-02
  - COMMIT-03
must_haves:
  truths:
    - "Commit button appears in toolbar only when isDirty is true (from Phase 12's usePendingChanges hook)"
    - "Clicking Commit calls GIT_DIFF via toolCaller then POST /api/plugins/site-editor/commit-message to generate a Claude Haiku commit message"
    - "User can edit the generated message in an inline textarea before confirming"
    - "Confirming calls GIT_COMMIT via toolCaller then refetches pendingChanges — isDirty clears, Commit button hides, diff badges clear"
    - "If message generation fails (no API key, network error), the textarea appears pre-filled with an empty string and the user can type manually"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/lib/git-api.ts"
      provides: "getDiff(), gitCommit() helper functions that call GIT_DIFF and GIT_COMMIT via toolCaller"
    - path: "packages/mesh-plugin-site-editor/client/components/commit-dialog.tsx"
      provides: "Inline CommitDialog component: loading state, editable textarea, Confirm/Cancel buttons"
    - path: "packages/mesh-plugin-site-editor/client/components/page-composer.tsx"
      provides: "Commit button in toolbar (visible only when isDirty), wires CommitDialog open/close, calls gitCommit then refetches"
    - path: "packages/mesh-plugin-site-editor/server/tools/commit-message.ts"
      provides: "CMS_GENERATE_COMMIT_MESSAGE server tool (not used directly — kept for parity); actually the route handler at POST /api/plugins/site-editor/commit-message calls Anthropic API via fetch"
    - path: "packages/mesh-plugin-site-editor/server/index.ts"
      provides: "Registers the POST /commit-message authenticated route on the server plugin"
---

## Overview

This plan adds a Commit button to the page composer toolbar. When clicked, it:

1. Calls `GIT_DIFF` via the existing `toolCaller` to get the current diff
2. POSTs the diff to a new server-side route (`POST /api/plugins/site-editor/commit-message`) which calls Claude Haiku via the Anthropic API
3. Shows an editable textarea pre-filled with the generated message
4. On Confirm, calls `GIT_COMMIT` with the (possibly edited) message
5. Invalidates the `pendingChanges` query key, which triggers `usePendingChanges` to re-fetch GIT_STATUS — badges clear, Commit button hides

The commit message generation is server-side (in the site-editor plugin's authenticated Hono route) so that the `ANTHROPIC_API_KEY` env var is never exposed to the client. The client makes a normal `fetch` call to `/api/plugins/site-editor/commit-message`.

All patterns follow the established conventions of the site editor plugin: API helpers in `lib/`, data fetching via `useMutation`, tool calls via `toolCaller`.

---

## Research Notes

### Why server-side route, not a server plugin MCP tool

The `ServerPluginToolContext` does not expose an LLM provider or environment variables — it only has `db`, `auth`, `access`, and `createMCPProxy`. The Anthropic call requires `ANTHROPIC_API_KEY` from the environment and a direct HTTP fetch. The `ServerPlugin.routes` hook provides a Hono app mounted at `/api/plugins/site-editor/*` with full access to `process.env`, which is the right place for this.

### Anthropic API call

The mesh app does not have `@ai-sdk/anthropic` installed (only `@ai-sdk/provider` and `@ai-sdk/react` are present). Instead, the route handler will call the Anthropic Messages API directly via `fetch`:

```
POST https://api.anthropic.com/v1/messages
x-api-key: ${process.env.ANTHROPIC_API_KEY}
anthropic-version: 2023-06-01
content-type: application/json

{
  "model": "claude-haiku-4-5-20251001",
  "max_tokens": 200,
  "messages": [{ "role": "user", "content": "<prompt>" }]
}
```

This requires no new npm packages.

### Phase 12's isDirty and refetch

Phase 12's `usePendingChanges` hook returns `{ sectionStatuses, isDirty, isLoading }`. After commit, we invalidate `queryKeys.pendingChanges.page(connectionId, pageId)` and `queryKeys.pages.detail(connectionId, pageId, activeLocale)` — the same pattern used by `handleDiscard` in Phase 12. This causes `usePendingChanges` to re-run GIT_STATUS, which returns no dirty files after the commit, making `isDirty` become `false`.

### GIT_DIFF and GIT_COMMIT are already in SITE_BINDING

Both tools are declared as optional (`opt: true`) in `packages/bindings/src/well-known/site.ts`. They are called through `toolCaller` the same way all other site binding tools are called (e.g., `toolCaller("GIT_DIFF", { path: undefined })` for full repo diff).

### Toolbar placement

Phase 12 adds a "Discard Changes" button before the Save button, visible only when `gitIsDirty`. The Commit button goes immediately before the Discard button in the same conditional block. Both are visible only when `isDirty` is true.

---

## Task 1: Create `git-api.ts` — GIT_DIFF and GIT_COMMIT client helpers

**File:** `packages/mesh-plugin-site-editor/client/lib/git-api.ts`

New file following the `branch-api.ts` / `history-api.ts` pattern. Export two async functions:

```typescript
/**
 * Git API helpers
 *
 * Client-side git operations using SITE_BINDING tools (GIT_DIFF, GIT_COMMIT).
 * These are thin wrappers around toolCaller that handle errors gracefully.
 */

import type { TypedToolCaller } from "@decocms/bindings";
import type { SiteBinding } from "@decocms/bindings/site";

type ToolCaller = TypedToolCaller<SiteBinding>;

/**
 * Get the full unified diff of working-tree changes against HEAD.
 * Returns the raw diff string, or null if GIT_DIFF is not supported.
 */
export async function getDiff(
  toolCaller: ToolCaller,
  path?: string,
): Promise<string | null> {
  try {
    const result = await toolCaller("GIT_DIFF", { path });
    return result.diff;
  } catch {
    return null;
  }
}

/**
 * Stage all changes and create a git commit with the given message.
 * Returns { hash, message } on success, or null if GIT_COMMIT is not supported.
 */
export async function gitCommit(
  toolCaller: ToolCaller,
  message: string,
): Promise<{ hash: string; message: string } | null> {
  try {
    const result = await toolCaller("GIT_COMMIT", { message });
    return result;
  } catch {
    return null;
  }
}
```

---

## Task 2: Add `generateCommitMessage` client helper

**File:** `packages/mesh-plugin-site-editor/client/lib/git-api.ts` (same file, append)

Add a third function that POSTs the diff to the server-side route:

```typescript
/**
 * Generate a commit message via Claude Haiku (server-side).
 *
 * Calls POST /api/plugins/site-editor/commit-message with the diff text.
 * Returns the generated message string, or null on failure.
 * Failure is non-fatal — the caller should fall back to an empty textarea.
 */
export async function generateCommitMessage(
  diff: string,
): Promise<string | null> {
  try {
    const response = await fetch(
      "/api/plugins/site-editor/commit-message",
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ diff }),
        credentials: "include",
      },
    );
    if (!response.ok) return null;
    const data = (await response.json()) as { message?: string };
    return data.message ?? null;
  } catch {
    return null;
  }
}
```

---

## Task 3: Add server-side route for commit message generation

**File:** `packages/mesh-plugin-site-editor/server/tools/commit-message.ts`

Create a new file that exports a Hono route registration function:

```typescript
/**
 * Commit Message Generator — Server Route
 *
 * POST /api/plugins/site-editor/commit-message
 *
 * Accepts { diff: string } and returns { message: string } generated by Claude Haiku.
 * Uses the Anthropic Messages API directly via fetch (no @ai-sdk/anthropic needed).
 *
 * Requires ANTHROPIC_API_KEY environment variable. Returns { message: "" } if not set.
 */

import type { Hono } from "hono";
import type { ServerPluginContext } from "@decocms/bindings/server-plugin";

const ANTHROPIC_API_URL = "https://api.anthropic.com/v1/messages";
const HAIKU_MODEL = "claude-haiku-4-5-20251001";
const MAX_TOKENS = 200;

const COMMIT_MESSAGE_PROMPT = `You are a git commit message generator. Generate a single conventional commit message for the following git diff.

Rules:
- Format: <type>(<scope>): <short description>
- Types: feat, fix, chore, docs, style, refactor, perf, test
- Scope: a short noun describing the area changed (e.g., pages, hero, nav, loader)
- Description: imperative, lowercase, no period, max 72 chars total
- Output ONLY the commit message — no explanation, no quotes, no newlines

Examples:
- feat(pages): add hero section with CTA button
- fix(nav): correct mobile menu z-index
- chore(loaders): remove unused product-list loader

Git diff:`;

export function registerCommitMessageRoute(
  app: Hono,
  _ctx: ServerPluginContext,
): void {
  app.post("/commit-message", async (c) => {
    const apiKey = process.env.ANTHROPIC_API_KEY;
    if (!apiKey) {
      return c.json({ message: "" }, 200);
    }

    let diff: string;
    try {
      const body = await c.req.json<{ diff?: string }>();
      diff = body.diff ?? "";
    } catch {
      return c.json({ error: "Invalid request body" }, 400);
    }

    // Trim diff to avoid exceeding context limits — Haiku has 200k context but
    // we keep prompts short for speed and cost.
    const trimmedDiff = diff.slice(0, 8000);
    const userMessage = `${COMMIT_MESSAGE_PROMPT}\n\n${trimmedDiff}`;

    try {
      const response = await fetch(ANTHROPIC_API_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": apiKey,
          "anthropic-version": "2023-06-01",
        },
        body: JSON.stringify({
          model: HAIKU_MODEL,
          max_tokens: MAX_TOKENS,
          messages: [{ role: "user", content: userMessage }],
        }),
      });

      if (!response.ok) {
        console.error(
          "[site-editor] Anthropic API error:",
          response.status,
          await response.text(),
        );
        return c.json({ message: "" }, 200);
      }

      const data = (await response.json()) as {
        content?: Array<{ type: string; text?: string }>;
      };
      const message =
        data.content
          ?.find((b) => b.type === "text")
          ?.text?.trim() ?? "";

      return c.json({ message });
    } catch (err) {
      console.error("[site-editor] Failed to generate commit message:", err);
      return c.json({ message: "" }, 200);
    }
  });
}
```

---

## Task 4: Register the route in the server plugin entry point

**File:** `packages/mesh-plugin-site-editor/server/index.ts`

Add the `routes` property to the server plugin export by importing and calling `registerCommitMessageRoute`:

```typescript
/**
 * Site Editor Plugin - Server Entry Point
 *
 * Provides site file management tools (pages, sections, loaders).
 * Tools have access to the mesh database (via Kysely) and MCP proxy.
 */

import type { ServerPlugin } from "@decocms/bindings/server-plugin";
import { PLUGIN_ID, PLUGIN_DESCRIPTION } from "../shared";
import { tools } from "./tools";
import { registerCommitMessageRoute } from "./tools/commit-message";

export const serverPlugin: ServerPlugin = {
  id: PLUGIN_ID,
  description: PLUGIN_DESCRIPTION,

  // MCP tools (added in plan 01-03)
  tools,

  // Authenticated API routes at /api/plugins/site-editor/*
  routes: (app, ctx) => {
    registerCommitMessageRoute(app, ctx);
  },
};
```

---

## Task 5: Create `CommitDialog` inline component

**File:** `packages/mesh-plugin-site-editor/client/components/commit-dialog.tsx`

A focused inline component that handles the three UI states:
1. **Generating** — loading spinner with "Generating commit message..." text
2. **Ready** — editable textarea pre-filled with the AI message, plus Confirm and Cancel buttons
3. **Committing** — loading spinner on the Confirm button while GIT_COMMIT is in flight

```tsx
/**
 * CommitDialog Component
 *
 * Inline commit flow within the toolbar area.
 * Three states: generating (AI call in flight), editing (textarea + Confirm/Cancel),
 * committing (GIT_COMMIT in flight).
 */

import { useState } from "react";
import { Loading01 } from "@untitledui/icons";
import { Button } from "@deco/ui/components/button.tsx";

interface CommitDialogProps {
  /** Initial message from AI generation (may be empty string if generation failed) */
  initialMessage: string;
  /** Whether the AI generation call is still in flight */
  isGenerating: boolean;
  /** Whether the GIT_COMMIT call is in flight */
  isCommitting: boolean;
  /** Called with the final message text when user confirms */
  onConfirm: (message: string) => void;
  /** Called when user cancels */
  onCancel: () => void;
}

export function CommitDialog({
  initialMessage,
  isGenerating,
  isCommitting,
  onConfirm,
  onCancel,
}: CommitDialogProps) {
  const [message, setMessage] = useState(initialMessage);

  // Sync message when initialMessage changes (AI call completes)
  // Use a key-based approach from the parent instead of useEffect.
  // The parent re-mounts this component with a new key once AI call completes.

  if (isGenerating) {
    return (
      <div className="flex items-center gap-2 px-3 py-1.5 rounded-md bg-muted/50 text-xs text-muted-foreground">
        <Loading01 size={12} className="animate-spin shrink-0" />
        <span>Generating commit message...</span>
        <button
          type="button"
          onClick={onCancel}
          className="ml-2 text-muted-foreground hover:text-foreground transition-colors"
        >
          Cancel
        </button>
      </div>
    );
  }

  return (
    <div className="flex items-start gap-2">
      <textarea
        value={message}
        onChange={(e) => setMessage(e.target.value)}
        rows={2}
        placeholder="Enter commit message..."
        className="flex-1 min-w-[280px] text-xs px-2 py-1.5 rounded-md border border-border bg-background resize-none focus:outline-none focus:ring-1 focus:ring-primary font-mono"
        autoFocus
        onKeyDown={(e) => {
          // Cmd+Enter / Ctrl+Enter confirms
          if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
            e.preventDefault();
            if (message.trim()) onConfirm(message.trim());
          }
          // Escape cancels
          if (e.key === "Escape") {
            e.preventDefault();
            onCancel();
          }
        }}
      />
      <div className="flex items-center gap-1 shrink-0">
        <Button
          size="sm"
          disabled={isCommitting || !message.trim()}
          onClick={() => {
            if (message.trim()) onConfirm(message.trim());
          }}
        >
          {isCommitting ? (
            <Loading01 size={12} className="animate-spin mr-1" />
          ) : null}
          {isCommitting ? "Committing..." : "Commit"}
        </Button>
        <Button
          variant="ghost"
          size="sm"
          disabled={isCommitting}
          onClick={onCancel}
        >
          Cancel
        </Button>
      </div>
    </div>
  );
}
```

---

## Task 6: Wire Commit button and CommitDialog into PageComposer

**File:** `packages/mesh-plugin-site-editor/client/components/page-composer.tsx`

### 6a: New imports

Add the following imports:

```typescript
import { GitCommit } from "lucide-react"; // or use a suitable icon from @untitledui/icons
import { CommitDialog } from "./commit-dialog";
import { getDiff, gitCommit, generateCommitMessage } from "../lib/git-api";
import { queryKeys } from "../lib/query-keys"; // already imported
```

Check `@untitledui/icons` for a commit/git icon. If none exists, use `lucide-react` which is already a dependency (`lucide-react` is in `mesh-plugin-site-editor/package.json`). A suitable icon from lucide-react would be `GitCommit` or `GitBranch`.

### 6b: New state variables

Add inside `PageComposer`:

```typescript
// Commit flow state
type CommitState =
  | { mode: "idle" }
  | { mode: "generating" }
  | { mode: "editing"; generatedMessage: string }
  | { mode: "committing"; message: string };

const [commitState, setCommitState] = useState<CommitState>({ mode: "idle" });
```

### 6c: Commit handler functions

```typescript
// Start commit flow: fetch diff → call Haiku → show editable textarea
const handleCommitClick = async () => {
  setCommitState({ mode: "generating" });

  // 1. Get the git diff
  const diff = await getDiff(toolCaller);

  // 2. Generate commit message (server-side Haiku call)
  // Both may fail gracefully — we fall back to empty string
  const generatedMessage = diff
    ? (await generateCommitMessage(diff)) ?? ""
    : "";

  setCommitState({ mode: "editing", generatedMessage });
};

// User cancelled commit dialog
const handleCommitCancel = () => {
  setCommitState({ mode: "idle" });
};

// User confirmed commit with final message
const handleCommitConfirm = async (message: string) => {
  setCommitState({ mode: "committing", message });

  const result = await gitCommit(toolCaller, message);

  if (result) {
    toast.success(`Committed: ${result.hash.slice(0, 7)} — ${result.message}`);
  } else {
    toast.error("Commit failed. Is GIT_COMMIT supported by this site?");
  }

  // Reset commit state
  setCommitState({ mode: "idle" });

  // Invalidate pending changes → isDirty clears → badges clear → Commit button hides
  queryClient.invalidateQueries({
    queryKey: queryKeys.pendingChanges.page(connectionId, pageId),
  });
  // Also invalidate pages to sync UI
  queryClient.invalidateQueries({
    queryKey: queryKeys.pages.detail(connectionId, pageId, activeLocale),
  });
};
```

### 6d: Toolbar changes

The toolbar currently (after Phase 12) has this structure in the `<div className="flex items-center gap-3">` block:

```tsx
{gitIsDirty && (
  <Button variant="ghost" size="sm" className="text-destructive ..." onClick={handleDiscard}>
    <XCircle ... />
    Discard changes
  </Button>
)}
<Button size="sm" onClick={handleSave}>
  <Save01 ... />
  Save
</Button>
```

The Commit button and CommitDialog go before the Discard button. Replace the `{gitIsDirty && ...Discard...}` block with:

```tsx
{gitIsDirty && commitState.mode === "idle" && (
  <>
    <Button
      variant="outline"
      size="sm"
      onClick={handleCommitClick}
      title="Generate commit message and commit all changes"
    >
      <GitCommit size={14} className="mr-1" />
      Commit
    </Button>
    <Button
      variant="ghost"
      size="sm"
      className="text-destructive hover:text-destructive"
      onClick={handleDiscard}
      title="Discard all uncommitted changes to this page"
    >
      <XCircle size={14} className="mr-1" />
      Discard changes
    </Button>
  </>
)}

{/* Inline commit dialog — shown when commit flow is in progress */}
{commitState.mode !== "idle" && (
  <CommitDialog
    key={commitState.mode === "editing" ? "editing" : "generating"}
    initialMessage={
      commitState.mode === "editing" ? commitState.generatedMessage : ""
    }
    isGenerating={commitState.mode === "generating"}
    isCommitting={commitState.mode === "committing"}
    onConfirm={handleCommitConfirm}
    onCancel={handleCommitCancel}
  />
)}
```

The `key` prop on `CommitDialog` forces a remount when transitioning from `generating` → `editing`, which sets the textarea value to `initialMessage` (replaces the need for `useEffect` to sync state — React 19 compiler compliant).

---

## Dependency Notes

- No new npm packages required. The server route uses `fetch` (available in Bun) to call Anthropic directly.
- `lucide-react` is already in `mesh-plugin-site-editor/package.json` dependencies.
- `GIT_DIFF` and `GIT_COMMIT` are already declared as optional tools in `SITE_BINDING`.
- The `ServerPlugin.routes` interface is already defined in `@decocms/bindings/server-plugin`.
- `@decocms/bindings/server-plugin` is already imported in `server/index.ts`.
- The Hono `app` received in the `routes` callback is the same pattern used by other server plugins — `commit-message.ts` only needs `import type { Hono } from "hono"` and `import type { ServerPluginContext } from "@decocms/bindings/server-plugin"`.

---

## Graceful Degradation

| Scenario | Behavior |
|---|---|
| `ANTHROPIC_API_KEY` not set | Route returns `{ message: "" }` → textarea appears empty, user types manually |
| Anthropic API error / timeout | Route returns `{ message: "" }` → textarea appears empty, user types manually |
| `GIT_DIFF` tool not supported by MCP | `getDiff()` returns `null` → `generateCommitMessage` is skipped → textarea empty |
| `GIT_COMMIT` tool not supported by MCP | `gitCommit()` returns `null` → error toast "Commit failed. Is GIT_COMMIT supported by this site?" |
| Network error calling `/api/plugins/site-editor/commit-message` | `generateCommitMessage()` returns `null` → textarea empty |

The UI never shows an error state for message generation failure — it simply shows an empty textarea so the user can type manually.

---

## Formatting

After all changes, run `bun run fmt` from the repo root.
