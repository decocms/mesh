---
phase: 17-site-editor-plugin
plan: 02
type: execute
wave: 2
depends_on:
  - 17-01
files_modified:
  - packages/mesh-plugin-site-editor/client/lib/page-api.ts
  - packages/mesh-plugin-site-editor/client/lib/block-api.ts
  - packages/mesh-plugin-site-editor/client/lib/git-api.ts
  - packages/mesh-plugin-site-editor/client/lib/query-keys.ts
autonomous: true
requirements:
  - EDT-01
  - EDT-02
  - EDT-03
  - EDT-04
  - EDT-11
  - EDT-12
  - EDT-13
  - EDT-14

must_haves:
  truths:
    - "listPages() calls the 'list' filesystem tool on the connection and returns Page[] (filtered to non-deleted .json files)"
    - "getPage() reads a .deco/pages/{id}.json file and returns a parsed Page object"
    - "createPage() writes a new .deco/pages/{id}.json and returns the Page"
    - "updatePage() writes the full Page JSON to the file (atomic full-document write)"
    - "deletePage() writes a tombstone { deleted: true, deletedAt: string } to the file"
    - "listBlocks() calls BLOCKS_LIST typed and returns BlockDefinition[]"
    - "listLoaders() calls LOADERS_LIST typed and returns LoaderDefinition[]"
    - "gitStatus() calls bash tool with 'git status --porcelain .deco/pages/{id}.json' and parses the output"
    - "gitLog() calls bash tool with git log format and returns GitCommit[]"
    - "gitShow() calls bash tool to get page content at a commit"
    - "gitCheckout() calls bash tool to revert a file to a commit"
    - "gitCommit() calls bash tool to stage and commit with a message"
    - "All functions compile cleanly with TypeScript strict mode"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/lib/page-api.ts"
      provides: "listPages, getPage, createPage, updatePage, deletePage"
      exports: ["listPages", "getPage", "createPage", "updatePage", "deletePage", "Page", "BlockInstance"]
    - path: "packages/mesh-plugin-site-editor/client/lib/block-api.ts"
      provides: "listBlocks, listLoaders using typed DECO_BLOCKS_BINDING tool caller"
      exports: ["listBlocks", "listLoaders"]
    - path: "packages/mesh-plugin-site-editor/client/lib/git-api.ts"
      provides: "gitStatus, gitLog, gitShow, gitCheckout, gitCommit, hasBashTool"
      exports: ["gitStatus", "gitLog", "gitShow", "gitCheckout", "gitCommit", "hasBashTool", "GitCommit", "GitFileStatus"]
    - path: "packages/mesh-plugin-site-editor/client/lib/query-keys.ts"
      provides: "TanStack Query key constants for all queries"
      exports: ["QUERY_KEYS"]
  key_links:
    - from: "packages/mesh-plugin-site-editor/client/lib/page-api.ts"
      to: "local-dev 'list' tool"
      via: "genericCaller('list', { path: '.deco/pages/' })"
      pattern: "genericCaller.*list"
    - from: "packages/mesh-plugin-site-editor/client/lib/git-api.ts"
      to: "local-dev 'bash' tool"
      via: "genericCaller('bash', { command: 'git ...' })"
      pattern: "genericCaller.*bash"
    - from: "packages/mesh-plugin-site-editor/client/lib/block-api.ts"
      to: "DECO_BLOCKS_BINDING"
      via: "TypedToolCaller<typeof DECO_BLOCKS_BINDING>"
      pattern: "toolCaller.*BLOCKS_LIST"
---

<objective>
Build the complete data access layer for the site editor: page CRUD via filesystem tools, block/loader listing via typed tool calls, and all git operations via the bash tool. These pure functions have no React dependencies — they are called from TanStack Query hooks in later plans.

Purpose: Establish the data contract before building UI. All tool-calling patterns are centralized here, making it easy to see how each operation maps to a tool call.
Output: page-api.ts, block-api.ts, git-api.ts, query-keys.ts in packages/mesh-plugin-site-editor/client/lib/
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/17-site-editor-plugin/17-RESEARCH.md
@.planning/phases/17-site-editor-plugin/17-01-SUMMARY.md
@packages/bindings/src/well-known/deco-blocks.ts
@packages/bindings/src/core/plugin-context.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create page-api.ts and query-keys.ts</name>
  <files>
    packages/mesh-plugin-site-editor/client/lib/page-api.ts
    packages/mesh-plugin-site-editor/client/lib/query-keys.ts
  </files>
  <action>
**page-api.ts** — Page data types and filesystem tool calls:

Define types:
```typescript
import { nanoid } from "nanoid";

// GenericToolCaller for filesystem/bash tools not in DECO_BLOCKS_BINDING
export type GenericToolCaller = (
  toolName: string,
  args: Record<string, unknown>,
) => Promise<unknown>;

export interface BlockInstance {
  id: string;          // nanoid(8)
  blockType: string;   // e.g. "ProductShelf" (matches block.name from BLOCKS_LIST)
  props: Record<string, unknown>;
  loaderBinding?: {    // optional loader prop binding
    prop: string;      // prop name this loader is bound to
    loaderName: string;
    loaderProps: Record<string, unknown>;
  };
}

export interface PageMetadata {
  description: string;
  createdAt: string;
  updatedAt: string;
}

export interface Page {
  id: string;          // e.g. "page_abc12345"
  path: string;        // URL path e.g. "/products"
  title: string;
  blocks: BlockInstance[];
  metadata: PageMetadata;
}

// Tombstone shape for deleted pages
interface PageTombstone {
  deleted: true;
  deletedAt: string;
  id: string;
  title: string;
}
```

Functions to implement:

**listPages(toolCaller: GenericToolCaller): Promise<Page[]>**
- Call `toolCaller("list", { path: ".deco/pages/" })`
- Handle both response shapes defensively: `result.entries` (array) or `result` being array directly
- Filter to `.json` files only (name.endsWith('.json'))
- For each file: call getPage(toolCaller, id) where id = name without .json extension
- Filter out tombstoned pages (where parsed JSON has `deleted: true`)
- Return Page[] sorted by metadata.createdAt descending
- If list returns empty or directory not found, return []
- Wrap in try/catch — return [] on error (directory may not exist yet)

**getPage(toolCaller: GenericToolCaller, id: string): Promise<Page | null>**
- Call `toolCaller("read", { path: ".deco/pages/${id}.json" })`
- Parse `(result as { content: string }).content` as JSON
- If parsed JSON has `deleted: true`, return null
- Return parsed Page

**createPage(toolCaller: GenericToolCaller, title: string, path: string): Promise<Page>**
- Generate `id = "page_" + nanoid(8)`
- Build Page object with blocks: [], metadata.createdAt = new Date().toISOString(), metadata.updatedAt = same
- Call `toolCaller("write", { path: ".deco/pages/${id}.json", content: JSON.stringify(page, null, 2) })`
- Return page

**updatePage(toolCaller: GenericToolCaller, page: Page): Promise<void>**
- Set page.metadata.updatedAt = new Date().toISOString()
- Call `toolCaller("write", { path: ".deco/pages/${page.id}.json", content: JSON.stringify(page, null, 2) })`

**deletePage(toolCaller: GenericToolCaller, id: string, title: string): Promise<void>**
- Build tombstone: `{ deleted: true as const, deletedAt: new Date().toISOString(), id, title }`
- Call `toolCaller("write", { path: ".deco/pages/${id}.json", content: JSON.stringify(tombstone, null, 2) })`

**query-keys.ts** — TanStack Query key constants (per project lint rule `enforce-query-key-constants`):
```typescript
export const QUERY_KEYS = {
  pages: (projectId: string) => ["site-editor", "pages", projectId] as const,
  page: (projectId: string, pageId: string) => ["site-editor", "page", projectId, pageId] as const,
  blocks: (projectId: string) => ["site-editor", "blocks", projectId] as const,
  loaders: (projectId: string) => ["site-editor", "loaders", projectId] as const,
  gitStatus: (projectId: string, pageId: string) => ["site-editor", "git-status", projectId, pageId] as const,
  gitLog: (projectId: string, pageId: string) => ["site-editor", "git-log", projectId, pageId] as const,
} as const;
```
  </action>
  <verify>
    bun run --cwd=packages/mesh-plugin-site-editor check 2>&1 | grep -E "error|Error" | head -10
    Expect: no TypeScript errors in page-api.ts or query-keys.ts
  </verify>
  <done>page-api.ts exports Page, BlockInstance types and all 5 CRUD functions; query-keys.ts exports QUERY_KEYS constant; no TS errors</done>
</task>

<task type="auto">
  <name>Task 2: Create block-api.ts and git-api.ts</name>
  <files>
    packages/mesh-plugin-site-editor/client/lib/block-api.ts
    packages/mesh-plugin-site-editor/client/lib/git-api.ts
  </files>
  <action>
**block-api.ts** — Typed DECO_BLOCKS_BINDING tool calls:

```typescript
import type { TypedToolCaller } from "@decocms/bindings";
import type { DecoBlocksBinding } from "@decocms/bindings";
import type { BlockDefinition, LoaderDefinition } from "@decocms/mesh-plugin-deco-blocks";

// TypedToolCaller typed to DECO_BLOCKS_BINDING
type BlocksToolCaller = TypedToolCaller<DecoBlocksBinding>;

export async function listBlocks(toolCaller: BlocksToolCaller): Promise<BlockDefinition[]> {
  const result = await toolCaller("BLOCKS_LIST", {});
  return result.blocks;
}

export async function listLoaders(toolCaller: BlocksToolCaller): Promise<LoaderDefinition[]> {
  const result = await toolCaller("LOADERS_LIST", {});
  return result.loaders;
}
```

Note on imports: `TypedToolCaller` is in `@decocms/bindings` (re-exported from plugin-context.ts). `DecoBlocksBinding` is the type of `DECO_BLOCKS_BINDING` in deco-blocks.ts. `BlockDefinition` and `LoaderDefinition` are exported from `@decocms/mesh-plugin-deco-blocks/src/index.ts`. Check actual export paths and adjust if needed.

**git-api.ts** — All git operations via the bash tool on the connection:

```typescript
import type { GenericToolCaller } from "./page-api";

export interface GitCommit {
  hash: string;
  author: string;
  date: string;      // ISO 8601
  message: string;
}

export type GitFileStatus = "M" | "A" | "D" | "?" | "clean";

export interface GitStatusResult {
  status: GitFileStatus;
  rawLine: string;
}

/**
 * Check if the connection exposes a bash tool.
 * Git UX is hidden when bash is not available (non-local-dev connections).
 */
export function hasBashTool(
  tools: Array<{ name: string }> | null | undefined
): boolean {
  return (tools ?? []).some((t) => t.name === "bash");
}

/**
 * Get git status for a specific page file.
 * Returns "clean" if file has no changes, otherwise the git porcelain status code.
 */
export async function gitStatus(
  toolCaller: GenericToolCaller,
  pageId: string
): Promise<GitStatusResult> {
  const result = await toolCaller("bash", {
    command: `git status --porcelain .deco/pages/${pageId}.json`,
  }) as { stdout: string; stderr: string; exitCode: number };

  const line = result.stdout.trim();
  if (!line) return { status: "clean", rawLine: "" };

  // git porcelain: "XY filename" — first two chars are status codes
  const code = line.slice(0, 2).trim();
  const status: GitFileStatus =
    code === "M" || code === "MM" ? "M"
    : code === "A" || code === "AM" ? "A"
    : code === "D" ? "D"
    : code === "??" ? "?"
    : "M"; // fallback: treat as modified
  return { status, rawLine: line };
}

/**
 * Get git commit history for a specific page file.
 * Returns empty array if git is not initialized or file has no history.
 */
export async function gitLog(
  toolCaller: GenericToolCaller,
  pageId: string
): Promise<GitCommit[]> {
  const result = await toolCaller("bash", {
    command: `git log --format="%H|%an|%aI|%s" -- .deco/pages/${pageId}.json`,
  }) as { stdout: string; exitCode: number };

  if (result.exitCode !== 0 || !result.stdout.trim()) return [];

  return result.stdout
    .trim()
    .split("\n")
    .filter(Boolean)
    .map((line) => {
      const [hash, author, date, ...messageParts] = line.split("|");
      return { hash: hash ?? "", author: author ?? "", date: date ?? "", message: messageParts.join("|") };
    });
}

/**
 * Get the content of a page file at a specific commit.
 */
export async function gitShow(
  toolCaller: GenericToolCaller,
  hash: string,
  pageId: string
): Promise<string> {
  const result = await toolCaller("bash", {
    command: `git show ${hash}:.deco/pages/${pageId}.json`,
  }) as { stdout: string; exitCode: number };
  return result.stdout;
}

/**
 * Revert a page file to a specific commit (file-level revert).
 */
export async function gitCheckout(
  toolCaller: GenericToolCaller,
  hash: string,
  pageId: string
): Promise<void> {
  await toolCaller("bash", {
    command: `git checkout ${hash} -- .deco/pages/${pageId}.json`,
  });
}

/**
 * Stage all changes and commit with the given message.
 * Escapes double quotes in message to prevent shell injection.
 */
export async function gitCommit(
  toolCaller: GenericToolCaller,
  message: string
): Promise<void> {
  const safeMessage = message.replace(/"/g, '\\"').replace(/`/g, "\\`");
  await toolCaller("bash", {
    command: `git add -A && git commit -m "${safeMessage}"`,
  });
}
```
  </action>
  <verify>
    bun run --cwd=packages/mesh-plugin-site-editor check 2>&1 | grep -E "error|Error" | head -10
    Expect: no TypeScript errors across all lib files
  </verify>
  <done>block-api.ts exports listBlocks, listLoaders; git-api.ts exports all git functions + hasBashTool; TypeScript compiles cleanly with no errors</done>
</task>

</tasks>

<verification>
1. Run `bun run --cwd=packages/mesh-plugin-site-editor check` — expect 0 errors
2. Confirm page-api.ts: exports Page, BlockInstance interfaces and listPages/getPage/createPage/updatePage/deletePage
3. Confirm git-api.ts: hasBashTool checks connection.tools array for "bash"
4. Confirm block-api.ts: listBlocks calls "BLOCKS_LIST" via TypedToolCaller
5. Confirm query-keys.ts: all key functions are const arrow functions (not string literals)
6. Run `bun run fmt` to ensure Biome formatting passes
</verification>

<success_criteria>
- All 4 lib files created and TypeScript-clean
- page-api.ts handles defensive list response shape (both { entries: [...] } and array)
- git-api.ts: all operations use bash tool; hasBashTool gates git UX availability
- block-api.ts: typed calls to BLOCKS_LIST / LOADERS_LIST
- query-keys.ts: all keys exported as constants (not ad-hoc strings)
</success_criteria>

<output>
After completion, create `.planning/phases/17-site-editor-plugin/17-02-SUMMARY.md`
</output>
