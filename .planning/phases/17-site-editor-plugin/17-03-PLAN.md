---
phase: 17-site-editor-plugin
plan: 03
type: tdd
wave: 2
depends_on:
  - 17-01
files_modified:
  - packages/mesh-plugin-site-editor/client/lib/use-undo-redo.ts
  - packages/mesh-plugin-site-editor/client/lib/use-undo-redo.test.ts
  - packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts
autonomous: true
requirements:
  - EDT-09
  - EDT-10

must_haves:
  truths:
    - "useUndoRedo(initial) returns { value, push, undo, redo, canUndo, canRedo, reset }"
    - "push(next) adds next to history and sets it as value"
    - "undo() moves value back to previous state; canUndo becomes false when at initial"
    - "redo() moves value forward; canRedo becomes false after last undo is re-applied"
    - "reset(next) sets value to next and clears all history"
    - "History capped at 100 entries — the 101st push drops the oldest"
    - "useIframeBridge exists as a non-broken export using useSyncExternalStore (no useEffect)"
  artifacts:
    - path: "packages/mesh-plugin-site-editor/client/lib/use-undo-redo.ts"
      provides: "useUndoRedo hook — snapshot-based undo/redo with useReducer"
      exports: ["useUndoRedo"]
    - path: "packages/mesh-plugin-site-editor/client/lib/use-undo-redo.test.ts"
      provides: "Unit tests for useUndoRedo covering all cases"
    - path: "packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts"
      provides: "useIframeBridge hook — postMessage bridge with useSyncExternalStore"
      exports: ["useIframeBridge"]
  key_links:
    - from: "packages/mesh-plugin-site-editor/client/lib/use-undo-redo.ts"
      to: "react"
      via: "useReducer (no useEffect — banned)"
      pattern: "useReducer"
    - from: "packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts"
      to: "react"
      via: "useSyncExternalStore (not useEffect)"
      pattern: "useSyncExternalStore"
---

<objective>
Implement the two core stateful hooks using TDD: useUndoRedo (snapshot-based history) and useIframeBridge (postMessage bridge). These are pure logic with defined inputs/outputs — ideal TDD candidates. The reference implementation from gui/site-builder is the gold standard; transplant and adapt.

Purpose: Tests drive correct implementation of undo/redo (EDT-10) and iframe bridge (EDT-09) before they are wired into the composer UI.
Output: use-undo-redo.ts (tested), use-undo-redo.test.ts, use-iframe-bridge.ts
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/17-site-editor-plugin/17-RESEARCH.md
@.planning/phases/17-site-editor-plugin/17-CONTEXT.md

Key pitfall from research: useEffect is BANNED in this project. Use useSyncExternalStore for all external subscriptions (keyboard events, window message events). The reference use-undo-redo.ts uses useReducer internally and useSyncExternalStore for keyboard shortcuts.
</context>

<feature>
  <name>useUndoRedo hook</name>
  <files>
    packages/mesh-plugin-site-editor/client/lib/use-undo-redo.ts
    packages/mesh-plugin-site-editor/client/lib/use-undo-redo.test.ts
  </files>
  <behavior>
    Snapshot-based undo/redo using useReducer. State shape:
    ```
    { past: T[], present: T, future: T[] }
    ```
    Actions:
    - PUSH(payload: T) → future=[], past=[...past.slice(-99), present], present=payload
    - UNDO → past.length > 0: future=[present, ...future], present=last(past), past=past.slice(0,-1)
    - REDO → future.length > 0: past=[...past, present], present=first(future), future=future.slice(1)
    - RESET(payload: T) → past=[], present=payload, future=[]

    Return value:
    ```typescript
    {
      value: T,           // present
      push: (next: T) => void,
      undo: () => void,
      redo: () => void,
      canUndo: boolean,   // past.length > 0
      canRedo: boolean,   // future.length > 0
      reset: (next: T) => void,
    }
    ```

    Test cases (input → expected output):
    - initial state: value=initial, canUndo=false, canRedo=false
    - push(1): value=1, canUndo=true, canRedo=false
    - push(1), push(2), undo(): value=1, canUndo=false, canRedo=true
    - push(1), push(2), undo(), redo(): value=2, canRedo=false
    - push(1), push(2), undo(), push(3): canRedo=false (future cleared on push)
    - push 101 times: past.length === 99 (capped at 100 total with present)
    - reset(99): value=99, canUndo=false, canRedo=false
  </behavior>
  <implementation>
    useReducer with the state/actions described above. No useEffect. The hook is UI-framework-agnostic logic — tests use the renderHook pattern from @testing-library/react if available, or test the reducer function directly.

    For tests: test the reducer logic directly (not renderHook) to avoid React testing setup complexity. Export the reducer function as a named export for testability.

    Keyboard shortcuts (Cmd+Z / Cmd+Shift+Z) are wired in the composer component (plan 17-05) using useSyncExternalStore, not in this hook. The hook only exposes undo/redo/canUndo/canRedo.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>RED: Write failing tests for useUndoRedo reducer</name>
  <files>
    packages/mesh-plugin-site-editor/client/lib/use-undo-redo.test.ts
  </files>
  <action>
Create the test file first, testing the reducer function (to be exported from use-undo-redo.ts):

```typescript
import { describe, test, expect } from "bun:test";
// Import will fail until use-undo-redo.ts exists with this export
import { undoRedoReducer, type UndoRedoState, type UndoRedoAction } from "./use-undo-redo";

describe("undoRedoReducer", () => {
  function initial<T>(value: T): UndoRedoState<T> {
    return { past: [], present: value, future: [] };
  }

  test("PUSH adds to past, clears future, sets present", () => {
    const s0 = initial(0);
    const s1 = undoRedoReducer(s0, { type: "PUSH", payload: 1 });
    expect(s1.present).toBe(1);
    expect(s1.past).toEqual([0]);
    expect(s1.future).toEqual([]);
  });

  test("initial state has canUndo=false, canRedo=false", () => {
    const s = initial("hello");
    expect(s.past.length).toBe(0);
    expect(s.future.length).toBe(0);
  });

  test("UNDO moves present to future, last past to present", () => {
    let s = initial(0);
    s = undoRedoReducer(s, { type: "PUSH", payload: 1 });
    s = undoRedoReducer(s, { type: "PUSH", payload: 2 });
    s = undoRedoReducer(s, { type: "UNDO" });
    expect(s.present).toBe(1);
    expect(s.past).toEqual([0]);
    expect(s.future).toEqual([2]);
  });

  test("UNDO at initial state is a no-op", () => {
    const s = initial(42);
    const s2 = undoRedoReducer(s, { type: "UNDO" });
    expect(s2).toEqual(s);
  });

  test("REDO moves present to past, first future to present", () => {
    let s = initial(0);
    s = undoRedoReducer(s, { type: "PUSH", payload: 1 });
    s = undoRedoReducer(s, { type: "PUSH", payload: 2 });
    s = undoRedoReducer(s, { type: "UNDO" });
    s = undoRedoReducer(s, { type: "REDO" });
    expect(s.present).toBe(2);
    expect(s.future).toEqual([]);
  });

  test("REDO with empty future is a no-op", () => {
    const s = initial(42);
    const s2 = undoRedoReducer(s, { type: "REDO" });
    expect(s2).toEqual(s);
  });

  test("PUSH clears future (new branch)", () => {
    let s = initial(0);
    s = undoRedoReducer(s, { type: "PUSH", payload: 1 });
    s = undoRedoReducer(s, { type: "PUSH", payload: 2 });
    s = undoRedoReducer(s, { type: "UNDO" });
    s = undoRedoReducer(s, { type: "PUSH", payload: 99 });
    expect(s.future).toEqual([]);
    expect(s.present).toBe(99);
  });

  test("PUSH caps history at 100 entries", () => {
    let s = initial(0);
    for (let i = 1; i <= 101; i++) {
      s = undoRedoReducer(s, { type: "PUSH", payload: i });
    }
    // past should have at most 100 entries (present is the 101st value)
    expect(s.past.length).toBeLessThanOrEqual(100);
  });

  test("RESET clears all history", () => {
    let s = initial(0);
    s = undoRedoReducer(s, { type: "PUSH", payload: 1 });
    s = undoRedoReducer(s, { type: "PUSH", payload: 2 });
    s = undoRedoReducer(s, { type: "RESET", payload: 99 });
    expect(s.present).toBe(99);
    expect(s.past).toEqual([]);
    expect(s.future).toEqual([]);
  });
});
```

Run tests — expect them to FAIL (import error since use-undo-redo.ts doesn't export undoRedoReducer yet):
```bash
bun test packages/mesh-plugin-site-editor/client/lib/use-undo-redo.test.ts 2>&1 | tail -10
```
  </action>
  <verify>
    bun test packages/mesh-plugin-site-editor/client/lib/use-undo-redo.test.ts 2>&1 | grep -E "fail|error|FAIL|ERROR" | head -5
    Expect: tests FAIL (import error or missing export) — RED phase confirmed
  </verify>
  <done>Test file exists and fails because use-undo-redo.ts does not yet export undoRedoReducer</done>
</task>

<task type="auto">
  <name>GREEN + REFACTOR: Implement useUndoRedo and useIframeBridge</name>
  <files>
    packages/mesh-plugin-site-editor/client/lib/use-undo-redo.ts
    packages/mesh-plugin-site-editor/client/lib/use-iframe-bridge.ts
  </files>
  <action>
**use-undo-redo.ts** — implement to pass tests:

```typescript
import { useReducer } from "react";

const MAX_HISTORY = 100;

export interface UndoRedoState<T> {
  past: T[];
  present: T;
  future: T[];
}

export type UndoRedoAction<T> =
  | { type: "PUSH"; payload: T }
  | { type: "UNDO" }
  | { type: "REDO" }
  | { type: "RESET"; payload: T };

export function undoRedoReducer<T>(
  state: UndoRedoState<T>,
  action: UndoRedoAction<T>,
): UndoRedoState<T> {
  switch (action.type) {
    case "PUSH": {
      const newPast = [...state.past, state.present];
      // Cap at MAX_HISTORY by dropping oldest entries
      const trimmedPast = newPast.length > MAX_HISTORY
        ? newPast.slice(newPast.length - MAX_HISTORY)
        : newPast;
      return { past: trimmedPast, present: action.payload, future: [] };
    }
    case "UNDO": {
      if (state.past.length === 0) return state;
      const previous = state.past[state.past.length - 1];
      return {
        past: state.past.slice(0, -1),
        present: previous,
        future: [state.present, ...state.future],
      };
    }
    case "REDO": {
      if (state.future.length === 0) return state;
      const next = state.future[0];
      return {
        past: [...state.past, state.present],
        present: next,
        future: state.future.slice(1),
      };
    }
    case "RESET": {
      return { past: [], present: action.payload, future: [] };
    }
    default:
      return state;
  }
}

export interface UseUndoRedoResult<T> {
  value: T;
  push: (next: T) => void;
  undo: () => void;
  redo: () => void;
  canUndo: boolean;
  canRedo: boolean;
  reset: (next: T) => void;
}

export function useUndoRedo<T>(initial: T): UseUndoRedoResult<T> {
  const [state, dispatch] = useReducer(undoRedoReducer<T>, {
    past: [],
    present: initial,
    future: [],
  });

  return {
    value: state.present,
    push: (next: T) => dispatch({ type: "PUSH", payload: next }),
    undo: () => dispatch({ type: "UNDO" }),
    redo: () => dispatch({ type: "REDO" }),
    canUndo: state.past.length > 0,
    canRedo: state.future.length > 0,
    reset: (next: T) => dispatch({ type: "RESET", payload: next }),
  };
}
```

After writing, run tests:
```bash
bun test packages/mesh-plugin-site-editor/client/lib/use-undo-redo.test.ts
```
All tests must pass (GREEN). Fix any failures before proceeding.

---

**use-iframe-bridge.ts** — postMessage bridge. Note: this is more complex to test (requires DOM + iframe), so tests are NOT written here. Instead, implement directly from the reference pattern with careful attention to the useEffect ban.

Key requirements:
- Uses `useSyncExternalStore` to subscribe to `window.addEventListener("message", ...)` — NOT useEffect
- Manages: iframe ref, ready state, disconnected state, hoverRect for block hover highlighting, selectedBlockId sync
- Sends page/block state updates to iframe via postMessage
- Listens for iframe messages: BLOCK_CLICKED, MOUSE_OVER, HANDSHAKE_COMPLETE, DISCONNECT

```typescript
import { useRef, useCallback, useSyncExternalStore } from "react";
import type { Page, BlockInstance } from "./page-api";

export type IframeMode = "edit" | "interact";

export interface IframeMessage {
  type: string;
  payload?: unknown;
}

export interface UseIframeBridgeOptions {
  page: Page | null;
  selectedBlockId: string | null;
  mode: IframeMode;
  onBlockClicked?: (id: string) => void;
  onClickAway?: () => void;
}

export interface UseIframeBridgeResult {
  setIframeRef: (el: HTMLIFrameElement | null) => void;
  send: (msg: IframeMessage) => void;
  ready: boolean;
  disconnected: boolean;
  reconnect: () => void;
  hoverRect: DOMRect | null;
  clearHover: () => void;
}

// External store for iframe messages — bridges window events to React
interface IframeStore {
  lastMessage: MessageEvent | null;
  subscribe: (notify: () => void) => () => void;
  getSnapshot: () => MessageEvent | null;
}

function createIframeStore(): IframeStore {
  let lastMessage: MessageEvent | null = null;
  const listeners = new Set<() => void>();

  const handler = (event: MessageEvent) => {
    lastMessage = event;
    for (const notify of listeners) notify();
  };

  return {
    lastMessage,
    subscribe: (notify: () => void) => {
      listeners.add(notify);
      if (listeners.size === 1) {
        window.addEventListener("message", handler);
      }
      return () => {
        listeners.delete(notify);
        if (listeners.size === 0) {
          window.removeEventListener("message", handler);
        }
      };
    },
    getSnapshot: () => lastMessage,
  };
}

// Module-level store (singleton) — avoids recreating on each render
const iframeStore = createIframeStore();

export function useIframeBridge(options: UseIframeBridgeOptions): UseIframeBridgeResult {
  const { page, selectedBlockId, mode, onBlockClicked, onClickAway } = options;
  const iframeRef = useRef<HTMLIFrameElement | null>(null);
  const readyRef = useRef(false);
  const disconnectedRef = useRef(false);
  const hoverRectRef = useRef<DOMRect | null>(null);

  // Subscribe to window messages via useSyncExternalStore (not useEffect — banned)
  const lastMessage = useSyncExternalStore(
    iframeStore.subscribe,
    iframeStore.getSnapshot,
    () => null, // server snapshot
  );

  // Process incoming iframe message
  // This runs during render — intentionally side-effect-free except for ref updates
  // (Ref updates don't cause re-renders, so this is safe)
  if (lastMessage && iframeRef.current) {
    const msg = lastMessage.data as IframeMessage | undefined;
    if (msg?.type === "HANDSHAKE_COMPLETE") {
      readyRef.current = true;
      disconnectedRef.current = false;
    } else if (msg?.type === "DISCONNECT") {
      disconnectedRef.current = true;
    } else if (msg?.type === "BLOCK_CLICKED") {
      const id = msg.payload as string;
      if (id) onBlockClicked?.(id);
      else onClickAway?.();
    } else if (msg?.type === "HOVER_RECT") {
      hoverRectRef.current = msg.payload as DOMRect | null;
    }
  }

  const send = useCallback((msg: IframeMessage) => {
    iframeRef.current?.contentWindow?.postMessage(msg, "*");
  }, []);

  const setIframeRef = useCallback((el: HTMLIFrameElement | null) => {
    iframeRef.current = el;
    if (el) {
      // Send initial handshake when iframe is mounted
      el.onload = () => {
        el.contentWindow?.postMessage({ type: "HANDSHAKE" }, "*");
      };
    }
  }, []);

  const reconnect = useCallback(() => {
    disconnectedRef.current = false;
    iframeRef.current?.contentWindow?.postMessage({ type: "HANDSHAKE" }, "*");
  }, []);

  const clearHover = useCallback(() => {
    hoverRectRef.current = null;
  }, []);

  // Sync page/mode changes to iframe
  // useSyncExternalStore result changes trigger re-renders; we piggyback on that
  // to also re-send state. In a real scenario, this should be triggered by actual
  // page/mode changes — use a ref to track previous values.
  const prevPageRef = useRef<Page | null>(null);
  const prevModeRef = useRef<IframeMode>("edit");

  if (readyRef.current) {
    if (prevPageRef.current !== page) {
      prevPageRef.current = page;
      send({ type: "PAGE_UPDATE", payload: page });
    }
    if (prevModeRef.current !== mode) {
      prevModeRef.current = mode;
      send({ type: "MODE_CHANGE", payload: mode });
    }
  }

  return {
    setIframeRef,
    send,
    ready: readyRef.current,
    disconnected: disconnectedRef.current,
    reconnect,
    hoverRect: hoverRectRef.current,
    clearHover,
  };
}
```

Note: This is a simplified version of the reference. The reference uses a more sophisticated heartbeat mechanism. This is sufficient for Phase 17 — the key contract is:
1. No useEffect
2. useSyncExternalStore for message subscription
3. setIframeRef callback ref pattern (not useEffect)
4. send, ready, disconnected, reconnect, hoverRect exposed

After implementing, run full type check:
```bash
bun run --cwd=packages/mesh-plugin-site-editor check 2>&1 | tail -5
```
  </action>
  <verify>
    bun test packages/mesh-plugin-site-editor/client/lib/use-undo-redo.test.ts 2>&1 | tail -5
    Expect: All tests pass (8 tests)

    bun run --cwd=packages/mesh-plugin-site-editor check 2>&1 | grep error | head -5
    Expect: 0 TypeScript errors
  </verify>
  <done>All 8 useUndoRedo tests pass; use-undo-redo.ts and use-iframe-bridge.ts compile cleanly; no useEffect in either file</done>
</task>

</tasks>

<verification>
1. Run `bun test packages/mesh-plugin-site-editor/client/lib/use-undo-redo.test.ts` — all tests GREEN
2. Confirm no `useEffect` import in use-undo-redo.ts or use-iframe-bridge.ts
3. Confirm use-iframe-bridge.ts uses `useSyncExternalStore` for window message subscription
4. Run `bun run --cwd=packages/mesh-plugin-site-editor check` — 0 errors
</verification>

<success_criteria>
- 8 useUndoRedo reducer tests all pass
- undoRedoReducer is a pure function exportable for direct testing
- useIframeBridge uses useSyncExternalStore, no useEffect
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/17-site-editor-plugin/17-03-SUMMARY.md`
</output>
