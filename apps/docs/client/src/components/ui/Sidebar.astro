---
import { getCollection } from "astro:content";
import { ui } from "../../i18n/ui";
import SidebarComponent from "./Sidebar.tsx";

const locale = Astro.params.locale;

const allDocs = await getCollection("docs");
const docs = allDocs.filter((doc) => doc.id.split("/")[0] === locale);

interface TreeNode {
  name: string;
  type: "file" | "folder";
  children: TreeNode[];
  doc?: any;
  path: string[];
  id: string;
}

function buildTree(docs: any[]): TreeNode[] {
  const root: TreeNode[] = [];

  docs.forEach((doc) => {
    const pathParts = doc.id.split("/").slice(1);
    let currentLevel = root;

    pathParts.forEach((part: string, index: number) => {
      const isFile = index === pathParts.length - 1;
      const existing = currentLevel.find((node) => node.name === part);

      if (existing) {
        if (isFile) {
          existing.doc = doc;
        }
        currentLevel = existing.children;
      } else {
        const newNode: TreeNode = {
          name: part,
          type: isFile ? "file" : "folder",
          children: [],
          path: pathParts.slice(0, index + 1),
          id: pathParts.slice(0, index + 1).join("/"),
          ...(isFile && { doc }),
        };
        currentLevel.push(newNode);
        currentLevel = newNode.children;
      }
    });
  });

  // Sort the tree for consistent ordering
  const sortTree = (nodes: TreeNode[]): TreeNode[] => {
    const sorted = nodes.sort((a, b) => {
      // Special case: api-reference should come after folders
      if (a.name === "api-reference" && b.type === "folder") {
        return 1; // api-reference comes after folders
      }
      if (b.name === "api-reference" && a.type === "folder") {
        return -1; // folders come before api-reference
      }

      // First sort by type: files before folders
      if (a.type !== b.type) {
        return a.type === "file" ? -1 : 1;
      }

      // For files only - custom ordering
      if (a.type === "file" && b.type === "file") {
        // Get parent folder to determine which order to use
        const parentPath = a.path[a.path.length - 2];

        // Custom order for decocms top-level pages
        if (parentPath === "mcp-mesh") {
          // NOTE: doc IDs do not include ".mdx" (e.g. "overview", not "overview.mdx")
          // Order follows: Quickstart → Overview → Core Concepts → Working with MCP → Monitoring → User Management → Reference
          const mcpMeshOrder = [
            // Quickstart & Overview
            "quickstart",
            "overview",
            // Core Concepts
            "concepts",
            // Working with MCP
            "connections",
            "virtual-mcps",
            "projects",
            "agents",
            // Monitoring & Observability
            "monitoring",
            // User Management
            "api-keys",
            "user-management",
            // Reference
            "api-reference",
          ];
          const aIndex = mcpMeshOrder.indexOf(a.name);
          const bIndex = mcpMeshOrder.indexOf(b.name);
          if (aIndex !== -1 && bIndex !== -1) {
            return aIndex - bIndex;
          }
          if (aIndex !== -1) return -1;
          if (bIndex !== -1) return 1;
        }

        // Custom order for decopilot subfolder
        if (parentPath === "decopilot") {
          const decopilotOrder = [
            "overview",
            "quickstart",
            "context",
            "tasks-and-spawning",
            "tools",
            "scopes",
            "architecture",
          ];
          const aIndex = decopilotOrder.indexOf(a.name);
          const bIndex = decopilotOrder.indexOf(b.name);
          if (aIndex !== -1 && bIndex !== -1) {
            return aIndex - bIndex;
          }
          if (aIndex !== -1) return -1;
          if (bIndex !== -1) return 1;
        }

        // Custom order for no-code-guides files
        if (parentPath === "no-code-guides") {
          const noCodeOrder = ["creating-tools", "creating-agents"];
          const aIndex = noCodeOrder.indexOf(a.name);
          const bIndex = noCodeOrder.indexOf(b.name);
          if (aIndex !== -1 && bIndex !== -1) {
            return aIndex - bIndex;
          }
          if (aIndex !== -1) return -1;
          if (bIndex !== -1) return 1;
        }

        // Custom order for full-code-guides files
        if (parentPath === "full-code-guides") {
          const fullCodeOrder = [
            "project-structure",
            "building-tools",
            "building-views",
            "resources",
            "deployment",
          ];
          const aIndex = fullCodeOrder.indexOf(a.name);
          const bIndex = fullCodeOrder.indexOf(b.name);
          if (aIndex !== -1 && bIndex !== -1) {
            return aIndex - bIndex;
          }
          if (aIndex !== -1) return -1;
          if (bIndex !== -1) return 1;
        }

        // Custom order for self-hosting section
        if (parentPath === "self-hosting") {
          const selfHostingOrder = ["quickstart", "authentication"];
          const aIndex = selfHostingOrder.indexOf(a.name);
          const bIndex = selfHostingOrder.indexOf(b.name);
          if (aIndex !== -1 && bIndex !== -1) {
            return aIndex - bIndex;
          }
          if (aIndex !== -1) return -1;
          if (bIndex !== -1) return 1;
        }

        // Custom order for api-reference section
        if (parentPath === "api-reference") {
          const apiRefOrder = ["built-in-tools"];
          const aIndex = apiRefOrder.indexOf(a.name);
          const bIndex = apiRefOrder.indexOf(b.name);
          if (aIndex !== -1 && bIndex !== -1) {
            return aIndex - bIndex;
          }
          if (aIndex !== -1) return -1;
          if (bIndex !== -1) return 1;
        }

        // Custom order for built-in-tools section
        if (parentPath === "built-in-tools") {
          const builtInToolsOrder = [
            "tool-search",
            "tool-enable",
            "agent-search",
            "subtask-run",
            "user-ask",
            "resource-read",
            "prompt-read",
          ];
          const aIndex = builtInToolsOrder.indexOf(a.name);
          const bIndex = builtInToolsOrder.indexOf(b.name);
          if (aIndex !== -1 && bIndex !== -1) {
            return aIndex - bIndex;
          }
          if (aIndex !== -1) return -1;
          if (bIndex !== -1) return 1;
        }

        // Custom order for deploy docs (now under self-hosting)
        const rootPath = a.path[0];
        if (rootPath === "mcp-mesh" && parentPath === "deploy") {
          const deployOrder = ["docker-compose", "kubernetes"];
          const aIndex = deployOrder.indexOf(a.name);
          const bIndex = deployOrder.indexOf(b.name);
          if (aIndex !== -1 && bIndex !== -1) {
            return aIndex - bIndex;
          }
          if (aIndex !== -1) return -1;
          if (bIndex !== -1) return 1;
        }
      }

      // For folders - custom ordering
      if (a.type === "folder" && b.type === "folder") {
        const folderOrder: Record<string, number> = {
          // Order follows improved information architecture
          "mcp-mesh": 0, // decocms docs (main product)
          "getting-started": 1, // Getting Started (after intro)
          decopilot: 2, // Decopilot (elevated section within mcp-mesh)
          "self-hosting": 3, // Self-hosting section
          deploy: 4, // Deploy section (under self-hosting)
          "no-code-guides": 5, // Legacy admin guides
          "full-code-guides": 6, // Legacy admin guides
        };

        const aOrder = folderOrder[a.name] ?? Number.POSITIVE_INFINITY;
        const bOrder = folderOrder[b.name] ?? Number.POSITIVE_INFINITY;
        if (aOrder !== bOrder) return aOrder - bOrder;
      }

      // Default alphabetical
      return a.name.localeCompare(b.name);
    });

    return sorted.map((node) => ({
      ...node,
      children: sortTree(node.children),
    }));
  };

  return sortTree(root);
}

function prefixNode(node: TreeNode, prefix: string[]): TreeNode {
  const newPath = [...prefix, ...node.path];
  return {
    ...node,
    path: newPath,
    id: newPath.join("/"),
    children: node.children.map((child) => prefixNode(child, prefix)),
  };
}

function groupLegacyAdminSections(nodes: TreeNode[]): TreeNode[] {
  const legacyRootName = "admin-decocms-com";

  const files = nodes.filter((n) => n.type === "file");
  const folders = nodes.filter((n) => n.type === "folder");

  const mcpMesh = folders.find((f) => f.name === "mcp-mesh");
  const legacyChildren = folders.filter((f) => f.name !== "mcp-mesh");

  const legacyFolder: TreeNode | null =
    legacyChildren.length > 0
      ? {
          name: legacyRootName,
          type: "folder",
          children: legacyChildren.map((child) =>
            prefixNode(child, [legacyRootName]),
          ),
          path: [legacyRootName],
          id: legacyRootName,
        }
      : null;

  // Flatten mcp-mesh folder - bring its children to the top level
  // mcp-mesh children will be shown at the top level
  const next: TreeNode[] = [];

  // Add all mcp-mesh children directly at top level (order controlled by mcpMeshOrder array)
  if (mcpMesh && mcpMesh.children.length > 0) {
    next.push(...mcpMesh.children);
  }

  // Add any other top-level files
  next.push(...files);

  // Add legacy admin section at the end
  if (legacyFolder) next.push(legacyFolder);

  return next;
}

const tree = groupLegacyAdminSections(buildTree(docs));

interface FlatNode {
  name: string;
  type: "file" | "folder";
  doc?: any;
  path: string[];
  depth: number;
  id: string;
  hasChildren: boolean;
}

function flattenTree(nodes: TreeNode[], depth = 0): FlatNode[] {
  const result: FlatNode[] = [];

  nodes.forEach((node) => {
    result.push({
      name: node.name,
      type: node.type,
      doc: node.doc,
      path: node.path,
      depth,
      id: node.id,
      hasChildren: node.children.length > 0,
    });

    if (node.children.length > 0) {
      result.push(...flattenTree(node.children, depth + 1));
    }
  });

  return result;
}

const flatTree = flattenTree(tree);
---

<SidebarComponent
  client:load
  tree={flatTree}
  locale={locale || "en"}
  translations={ui[locale as keyof typeof ui] || ui.en}
/>
