---
title: Virtual MCPs
description: Remix connections into reusable packages—select tools and context from multiple sources, add custom logic, and create purpose-built MCPs for your workflows
icon: Waypoints
---

import Callout from "../../../../components/ui/Callout.astro";

## What Are Virtual MCPs?

In deco CMS, a **Virtual MCP** is a reusable package of capabilities—[tools, resources, and prompts](/en/mcp-mesh/concepts#mcp-protocol-primitives)—remixed from multiple [connections](/en/mcp-mesh/connections).

Instead of giving your AI agent access to everything from every connection, you **compose virtual MCPs** that expose exactly what's needed for each use case. You can:

- **Remix connections**: Select specific tools and context from each connection
- **Combine multiple sources**: Package Shopify + inventory systems + databases into one unified MCP
- **Add custom logic**: Extend with inline tools, prompts, and resources
- **Update dynamically**: Change what's included without reconfiguring your agents

Virtual MCPs are the **backbone of deco CMS**—powering [Projects](/en/mcp-mesh/projects), [Agents](/en/mcp-mesh/agents), and organizational boundaries for how capabilities are packaged and composed.

## How Virtual MCPs Work

Virtual MCPs are built by **remixing connections**—selecting capabilities from external MCPs—and optionally **extending with custom tools, prompts, and resources**.

### Remix from Connections

**Remixing** lets you select and combine tools, resources, and prompts from multiple [connections](/en/mcp-mesh/connections).

A **connection** is how you wire up an external MCP server to deco CMS (see [Connections](/en/mcp-mesh/connections) for details). Once you have connections set up, remixing works like this:

1. **Select specific capabilities** from each connection—tools, resources, prompts
2. **Combine them** into a single virtual MCP package
3. **Your agent gets** aggregated access to all selected capabilities in one place

**Example**: An "order-fulfillment-ops" virtual MCP might remix:
- **Shopify connection**: Order management tools + product catalog
- **ShipStation connection**: Shipping label generation and tracking tools
- **Email provider connection**: Order confirmation and shipping notification tools

Your AI agent uses this one virtual MCP to orchestrate the entire order fulfillment process across all three systems.

### Extend with Inline Capabilities

**Inline creation** lets you define tools, resources, and prompts directly within a virtual MCP—extending what connections provide.

Inline tools can **call any MCP connection** available in your deco CMS instance, enabling powerful patterns like orchestration, validation, and feature gating.

Inline tools can call other tools using `callTool(connectionId:TOOL_NAME, params)`, enabling orchestration, validation, and feature gating across your MCP infrastructure.

This remixing approach is perfect for:

- **Custom prompts** that guide agents through team-specific workflows
- **Context resources** like guidelines, documentation, or domain knowledge
- **Orchestration tools** that compose tools from multiple connections into higher-level operations
- **Feature gating and validation** that wrap connection tools with authorization logic (see [Authorization and Roles](/en/mcp-mesh/user-management))

#### Use Case: Feature Gating

Inline tools are ideal for **feature gating**—wrapping connection tools with validation, authorization, or custom behavior.

**Example**: A read-only database tool that validates queries before calling the underlying connection, blocking dangerous operations like `DROP`, `DELETE`, or `UPDATE`.

#### Use Case: Orchestration

Inline tools can coordinate multiple connections in a single operation.

**Example**: An order fulfillment tool that checks inventory (warehouse connection), creates a shipping label (ShipStation connection), sends order confirmation (SendGrid connection), and updates order status (Shopify connection)—all in one coordinated workflow.

These patterns enable **authorization enforcement**, **input validation**, **audit logging** (see [Monitoring](/en/mcp-mesh/monitoring)), and **workflow orchestration** across your MCP infrastructure.

### Combine Both

The real power comes from combining both approaches—remixing capabilities from connections and extending them with inline definitions.

**Example**: A "customer-service-assistant" virtual MCP that combines:
- **Shopify connection tools**: Order lookup, refund processing
- **Shopify connection resources**: Product catalog and return policies
- **Inline prompts**: Custom customer communication templates
- **Inline resources**: Customer service guidelines and FAQ responses

One virtual MCP, multiple sources (connections + inline definitions), unified agent experience.

## Namespacing & Collision Avoidance

When aggregating capabilities from multiple connections, deco CMS uses **connection-based namespacing** to avoid collisions. Each connection gets a unique ID, and all capabilities from that connection are prefixed with this ID.

### Tools and Prompts

Tools and prompts use the format: `connection_id::CAPABILITY_NAME`

- **Namespace separator**: `::` (double colon) between connection ID and capability name
- **64-character limit**: The entire namespaced name cannot exceed 64 characters

**Example**: Two Shopify connections can both expose a `GET_ORDERS` tool:
- `shopify_store_a_456::GET_ORDERS` (Store A account)
- `shopify_store_b_789::GET_ORDERS` (Store B account)

This ensures capabilities remain distinct even when multiple connections expose tools with the same name.

### Resources

Resources use URI-based namespacing, **except for well-known protocols**.

**Custom protocols** (like `store://`, `inventory://`) get namespaced with the connection ID and URL-encoded:
- Original: `store://my-brand/products/catalog.json`
- Namespaced: `shopify_conn_123://store%3A%2F%2Fmy-brand%2Fproducts%2Fcatalog.json`

**Well-known protocols** (like `http://`, `https://`, `ws://`) are **NOT namespaced** and remain unchanged.

**Automatic content rewriting**: When resources are read through a virtual MCP, deco CMS automatically rewrites internal resource links to use the namespaced format. This ensures resources can reference each other correctly.

<Callout type="info">
Tools and prompts use `connection_id::CAPABILITY_NAME` format (max 64 chars). Resources use `connection_id://encodedUri` for custom protocols, or stay unchanged for well-known protocols.
</Callout>

## Features Powered by Virtual MCPs

Virtual MCPs provide the **foundational capability** that powers specialized features across deco CMS. All of these inherit full [monitoring capabilities](/en/mcp-mesh/monitoring) for audit trails and observability.

**MCP Client Compatibility**: Virtual MCPs are callable by any MCP-compatible client—including Cursor, Claude Code, VS Code extensions, and any application that implements the Model Context Protocol. This makes your composed capability packages universally accessible across the AI tooling ecosystem.

**Specialized features built on virtual MCPs:**

- **[Agents](/en/mcp-mesh/agents)**: Single-purpose capability packages optimized for specific tasks
- **[Projects](/en/mcp-mesh/projects)**: Team-scoped capability packages for organizational boundaries

## Use Cases & Benefits

Virtual MCPs turn fragmented MCP connections into unified, reusable capability packages:

**Real-world applications:**
- **Order Fulfillment Operations**: Package Shopify (orders) + ShipStation (shipping) + email provider (notifications) into one fulfillment MCP
- **Customer Service Hub**: Remix Shopify tools with inline customer service prompts and return policy guidelines
- **Inventory Management**: Combine warehouse APIs + Shopify inventory tools with inline stock alert workflows
- **Multi-brand Store Management**: Share access to a Shopify MCP connection across your team while filtering brand-specific operations—giving managers scoped access to their brand's products and orders without exposing other brands
- **Ecommerce Analytics**: Package Shopify, Google Analytics, and Stripe tools for end-to-end sales and conversion tracking

**Key benefits:**
- **Selective remixing**: Choose exactly which tools, resources, and prompts to include from each connection
- **Inline extensions**: Add custom orchestration, validation, and feature gating logic
- **Dynamic updates**: Modify what's included without reconfiguring agents
- **Foundation for specialization**: Building block for [Projects](/en/mcp-mesh/projects) and [Agents](/en/mcp-mesh/agents)

---

## Next Steps

<Callout type="info">
Start with [Connections](/en/mcp-mesh/connections) to understand how to wire up external MCP servers first.
</Callout>

**Ready to build?** Follow the [Quickstart](/en/mcp-mesh/quickstart) for step-by-step setup.

**Building for teams?** Learn about [Projects](/en/mcp-mesh/projects) for team-scoped virtual MCPs, or [Agents](/en/mcp-mesh/agents) for single-purpose capability packages.

**Need authorization controls?** See [Authorization and Roles](/en/mcp-mesh/user-management) for securing virtual MCP access with feature gating and policies.
