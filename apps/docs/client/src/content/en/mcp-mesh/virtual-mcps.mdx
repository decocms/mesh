---
title: Virtual MCPs
description: Publish a virtual MCP server that aggregates tools/resources/prompts from multiple connections
icon: Waypoints
---

import Callout from "../../../components/ui/Callout.astro";

## What is a Virtual MCP?

A **Virtual MCP** is a foundational concept in MCP Mesh—it's a **virtual MCP server** that aggregates multiple connections into a single MCP surface:

- tools (`tools/list`, `tools/call`)
- resources (`resources/list`, `resources/read`)
- prompts (`prompts/list`, `prompts/get`)

This is how you create a curated endpoint for clients without exposing every tool from every connected integration.

## Endpoint

- `POST /mcp/virtual/:virtualId`

You can also omit `:virtualId` and rely on the organization's default Virtual MCP by providing one of these headers:

- `x-org-id`, or
- `x-org-slug`

## Selection modes

- **Include**: only the listed connections/tools are exposed.
- **Exclude**: expose the whole org surface *except* excluded connections/tools.

## Tool exposure strategies

Virtual MCPs also control **how tools are exposed** to clients (useful when tool surfaces get large).
These strategies ship by default:

### Passthrough (baseline)

- Exposes all Virtual MCP tools directly via `tools/list`.
- Best for small tool surfaces and deterministic behavior.

### Smart tool selection

- Exposes meta-tools for discovery and targeted execution:
  - `VIRTUAL_SEARCH_TOOLS` (keyword search)
  - `VIRTUAL_DESCRIBE_TOOLS` (fetch full schemas)
  - `VIRTUAL_CALL_TOOL` (execute a chosen tool)
- Goal: keep the tool list small and let the client request details on demand.

### Code execution

- Exposes meta-tools for discovery + sandboxed execution:
  - `VIRTUAL_SEARCH_TOOLS`
  - `VIRTUAL_DESCRIBE_TOOLS`
  - `VIRTUAL_RUN_CODE` (run JS in a sandbox that can call tools)
- Goal: reduce tool exposure overhead on large surfaces by shifting work into a constrained runtime.

## The default Virtual MCP (auto-created per org)

Every new organization gets a **Default Virtual MCP**:

- **Strategy**: `passthrough`
- **Mode**: `exclusion`
- **Default exclusions**: the built-in **Mesh MCP** connection (management tools) and the **Store/Registry** connection are excluded by default
- **Default behavior**: everything else in the org is included — so as you connect Integrations, this endpoint becomes the "all tools in the org" Virtual MCP

This is the endpoint most teams use as the single aggregated MCP surface for an org.

## Benchmark: strategy tradeoffs

We ran a Virtual MCP strategy benchmark here: [MCP Virtual MCP Benchmark (GitHub Actions run)](https://github.com/decocms/mesh/actions/runs/20584203227).

**Summary (high level):**

- **Small tool surface (~10 tools)**:
  - **Passthrough** used fewer tokens, but had lower success than **Code execution**
  - **Smart tool selection** was the least reliable in this run
- **Large tool surface (~128 tools)**:
  - **Code execution** reduced token usage substantially vs **Passthrough** and had the highest success
  - **Smart tool selection** was the most expensive in tokens in this run

If you want the raw numbers, open the run and download the **benchmark-results** artifact.

## Code Execution Tools in the Management MCP

In addition to Virtual MCP strategies, you can use code execution tools directly from the **Management MCP** (`/mcp`):

- `CODE_EXECUTION_SEARCH_TOOLS` - search tools by name or description
- `CODE_EXECUTION_DESCRIBE_TOOLS` - get detailed tool schemas
- `CODE_EXECUTION_RUN_CODE` - run JS in a sandbox with tool access

These tools operate on:
- All active connections in the organization (by default)
- Virtual MCP-specific connections (if `virtualId` is set in context)

This lets you use the code execution paradigm without configuring a specific Virtual MCP strategy.

