---
title: Construindo Tools
description: Construa tools em TypeScript com total type safety e extensibilidade
icon: Wrench
---

import Callout from "../../../components/ui/Callout.astro";

Tools são funções tipadas que agents, workflows e views podem chamar. Este guia mostra como construir tools em TypeScript para máximo controle e extensibilidade.

<Callout type="tip">
  **Prefere a UI?** Veja [Tools (Sem Código)](/pt-br/no-code-guides/creating-tools) para criar tools via chat.
</Callout>

## Anatomia de um Tool

Todo tool requer quatro componentes:

1. **ID** - Identificador único seguindo padrão `RECURSO_ACAO` (ex: `EMAIL_SEND`, `CUSTOMER_FETCH`)
2. **Descrição** - Diz aos agents quando e como usar o tool
3. **Schemas** - Schemas Zod para validação de input e tipagem de output
4. **Execute** - A lógica de implementação


## Exemplo Básico

```typescript
import { createTool } from "@deco/workers-runtime";
import { z } from "zod";

const createEmailTool = (env: Env) =>
  createTool({
    id: "EMAIL_SEND",
    description: "Enviar um email via Gmail. Use para notificações e comunicações.",
    inputSchema: z.object({
      to: z.string().email(),
      subject: z.string(),
      body: z.string(),
    }),
    outputSchema: z.object({ 
      success: z.boolean(),
      messageId: z.string().optional(),
    }),
    execute: async ({ context }) => {
      const response = await env["gmail"].SEND_EMAIL({
        to: context.to,
        subject: context.subject,
        body: context.body,
      });
      return { 
        success: true,
        messageId: response.id,
      };
    },
  }); 
```

**Pontos-chave:**
- Use `context` para acessar input validado
- Retorne dados que correspondam ao seu `outputSchema`
- Acesse integrações via `env["integration-id"]` onde `integration-id` é o ID do app no seu workspace

## Padrões Comuns

### Chamadas de API Externa

```typescript
const createWeatherTool = (env: Env) =>
  createTool({
    id: "WEATHER_FETCH",
    description: "Obter clima atual de uma cidade usando OpenWeather API",
    inputSchema: z.object({
      city: z.string().min(1),
    }),
    outputSchema: z.object({
      temperature: z.number(),
      condition: z.string(),
      humidity: z.number().optional(),
    }),
    execute: async ({ context }) => {
      const response = await fetch(
        `https://api.openweathermap.org/data/2.5/weather?q=${context.city}&appid=${env.OPENWEATHER_API_KEY}`
      );
      
      if (!response.ok) {
        throw new Error(`Erro da API de clima: ${response.statusText}`);
      }
      
      const data = await response.json();
      return {
        temperature: data.main.temp,
        condition: data.weather[0].description,
        humidity: data.main.humidity,
      };
    },
  });
```

### Usando Integrações

Chame integrações instaladas através do environment:

```typescript
const createNotificationTool = (env: Env) =>
  createTool({
    id: "SLACK_NOTIFY",
    description: "Enviar uma notificação para um canal Slack",
    inputSchema: z.object({
      channel: z.string(),
      message: z.string(),
    }),
    outputSchema: z.object({ 
      sent: z.boolean(),
      timestamp: z.string(),
    }),
    execute: async ({ context }) => {
      const result = await env["slack"].POST_MESSAGE({
        channel: context.channel,
        text: context.message,
      });
      return {
        sent: true,
        timestamp: result.ts,
      };
    },
  });
```

Instale integrações de **Apps** no seu workspace. As tools de cada integração estão disponíveis em `env["integration-id"]` onde o ID é mostrado na seção Apps (ex: `env["gmail"]`, `env["slack"]`).

### Operações de Banco de Dados

Todo workspace inclui SQLite integrado com Drizzle ORM:

```typescript
import { getDb } from "./db";
import { customers } from "./schema";

const createCustomerTool = (env: Env) =>
  createTool({
    id: "CUSTOMER_CREATE",
    description: "Criar um novo cliente no banco de dados",
    inputSchema: z.object({
      name: z.string().min(1),
      email: z.string().email(),
      city: z.string(),
      state: z.string().length(2),
    }),
    outputSchema: z.object({ 
      id: z.number(),
      createdAt: z.date(),
    }),
    execute: async ({ context }) => {
      const db = await getDb(env);
      const [result] = await db
        .insert(customers)
        .values({
          name: context.name,
          email: context.email,
          city: context.city,
          state: context.state,
        })
        .returning();

      return { 
        id: result.id,
        createdAt: result.createdAt,
      };
    },
  });
```

Cada projeto obtém armazenamento SQLite isolado no D1 do Cloudflare. Sem necessidade de credenciais.

## Registrando Tools

Adicione tools em `server/main.ts`:

```typescript
import { withRuntime } from "@deco/workers-runtime";
import { createEmailTool } from "./tools/email";
import { createCustomerTool } from "./tools/customers";

const { Workflow, ...runtime } = withRuntime<Env>({
  tools: [
    createEmailTool,
    createCustomerTool,
    // Adicione mais tools aqui
  ],
  workflows: [],
  views: [],
});

export { Workflow };
export default runtime;
```

Após registro, execute `npm run gen:self` para gerar tipos para seu frontend.

## Testando Tools

Inicie seu servidor dev e teste de duas maneiras:

**1. Via Admin UI:**
1. `npm run dev`
2. Copie URL de preview
3. **Admin → Apps → Adicionar Integração** (cole URL + `/mcp`)
4. Teste tools através da interface auto-gerada

**2. Via Código:**
```typescript
// No seu componente React
import { client } from "./lib/rpc";

const result = await client.tools.EMAIL_SEND({
  to: "user@example.com",
  subject: "Teste",
  body: "Olá!",
});
```

Tools estão imediatamente disponíveis via RPC tipado, sem necessidade de camada de API.

## Melhores Práticas

**Responsabilidade Única**
```
✅ EMAIL_SEND, CUSTOMER_CREATE, INVOICE_GENERATE
❌ CUSTOMER_CREATE_AND_EMAIL_AND_NOTIFY
```

**Nomes Descritivos**
Siga o padrão `RECURSO_ACAO`:
```
✅ ORDER_TOTAL_CALCULATE, LEAD_QUALIFY
❌ calculateTotal, qualify_lead
```

**Tipagem Forte**
Schemas Zod fornecem validação em runtime e tipos em compile-time:
```typescript
inputSchema: z.object({
  email: z.string().email(),        // Validação de email
  amount: z.number().positive(),    // Deve ser > 0
  tier: z.enum(["A", "B", "C"]),   // Apenas estes valores
})
```

**Tratamento de Erros**
```typescript
execute: async ({ context }) => {
  try {
    const result = await api.call(context);
    return result;
  } catch (error) {
    throw new Error(`Falha ao processar: ${error.message}`);
  }
}
```

## Organizando Tools

Agrupe tools relacionados em arquivos:

```
server/tools/
├── index.ts          # Exporta todos os tools
├── customers.ts      # CUSTOMER_CREATE, CUSTOMER_FETCH, etc.
├── emails.ts         # EMAIL_SEND, EMAIL_VALIDATE
└── billing.ts        # INVOICE_CREATE, PAYMENT_PROCESS
```

Exporte de `index.ts`:
```typescript
export { createCustomerTool, createCustomerFetchTool } from "./customers";
export { createEmailTool } from "./emails";
export { createInvoiceTool } from "./billing";
```
