---
title: Resources
description: Crie resources tipados e versionados com sincronização em tempo real
icon: Database
---

import Callout from "../../../components/ui/Callout.astro";

deconfig é o sistema de arquivos versionado tipo-git do deco CMS para armazenar resources. Este guia mostra como definir tipos customizados de resources com operações CRUD completas e sincronização em tempo real.

**Casos de uso:**
- Configurações de tema
- Preferências de usuário
- Dados de configuração
- Feature flags
- Qualquer dado tipado que precise de versionamento e atualizações em tempo real

## Como Funciona

Defina um schema de resource → Tools CRUD auto-gerados → Cliente frontend type-safe → Atualizações SSE em tempo real

Resources são:
- **Tipados** com schemas Zod
- **Versionados** no deconfig (armazenamento tipo-git)
- **Referenciáveis** via URIs `rsc://`
- **Tempo real** com Server-Sent Events

---

## Definir um Resource

Crie um schema em `server/tools/`:

```typescript
import { DeconfigResource } from "@decocms/runtime/deconfig";
import { z } from "zod";

const ThemeSettings = DeconfigResource.define({
  resourceName: "theme_settings",
  dataSchema: z.object({
    name: z.string().min(1),
    primaryColor: z.string().regex(/^#[0-9A-Fa-f]{6}$/),
    secondaryColor: z.string().regex(/^#[0-9A-Fa-f]{6}$/),
    textColor: z.string().regex(/^#[0-9A-Fa-f]{6}$/),
  }),
});

// Registre no seu array de tools
export const tools = [
  (env: Env) => ThemeSettings.create(env),
  // ... outros tools
];

export { ThemeSettings };
```

Isso gera 6 tools CRUD automaticamente:

| Tool | Propósito |
|------|-----------|
| `CREATE` | Criar novo resource com dados |
| `READ` | Obter resource por URI |
| `UPDATE` | Atualizar resource (merge parcial) |
| `DELETE` | Deletar resource por URI |
| `SEARCH` | Listar/filtrar resources com paginação |
| `DESCRIBE` | Obter metadados e endpoint SSE |

### URIs de Resource

Resources são identificados por URIs no formato: `rsc://app-id/theme_settings/resource-id`

O `resource-id` pode ser auto-gerado ou você pode especificá-lo no CREATE:

```typescript
await client.tools.DECO_RESOURCE_THEME_SETTINGS_CREATE({
  resourceId: "tema-escuro", // Opcional: especifique ID
  data: { /* ... */ }
});
```

## Usar no Frontend

Após executar `npm run gen:self`, use o cliente gerado:

### Operações Básicas

```typescript
import { client } from "./lib/rpc";

// Criar
const theme = await client.tools.DECO_RESOURCE_THEME_SETTINGS_CREATE({
  data: {
    name: "Tema Escuro",
    primaryColor: "#1a1a1a",
    secondaryColor: "#2d2d2d",
    textColor: "#ffffff",
  }
});

// Ler
const theme = await client.tools.DECO_RESOURCE_THEME_SETTINGS_READ({
  uri: "rsc://meu-app/theme_settings/tema-escuro"
});

// Atualizar (atualização parcial - faz merge com existente)
await client.tools.DECO_RESOURCE_THEME_SETTINGS_UPDATE({
  uri: "rsc://meu-app/theme_settings/tema-escuro",
  data: { primaryColor: "#000000" }
});

// Deletar
await client.tools.DECO_RESOURCE_THEME_SETTINGS_DELETE({
  uri: "rsc://meu-app/theme_settings/tema-escuro"
});

// Buscar com filtragem e paginação
const results = await client.tools.DECO_RESOURCE_THEME_SETTINGS_SEARCH({
  term: "escuro",          // Busca em name, description, resourceId
  page: 1,                 // Número da página (começa em 1)
  pageSize: 10,            // Itens por página (use Infinity para todos)
  sortBy: "name",          // Ordenar por: "name", "resourceId", "mtime"
  sortOrder: "asc",        // "asc" ou "desc"
  filters: {               // Filtros opcionais
    created_by: "user-id",
    updated_by: ["user-1", "user-2"],
  },
});

// Estrutura do resultado
// {
//   items: Resource[],
//   total: number,
//   page: number,
//   pageSize: number
// }
```

<Callout type="tip">
  **Rastreamento de metadados:** Resources automaticamente rastreiam `created_by`, `updated_by`, `created_at` e `updated_at`.
</Callout>

### Atualizações em Tempo Real com SSE

Inscreva-se em mudanças de resources via Server-Sent Events:

```typescript
import { useEffect } from "react";
import { useQueryClient } from "@tanstack/react-query";
import { client } from "./lib/rpc";

function useThemeSync() {
  const queryClient = useQueryClient();

  useEffect(() => {
    let eventSource: EventSource;

    const setup = async () => {
      // Obter endpoint SSE
      const desc = await client.tools.DECO_RESOURCE_THEME_SETTINGS_DESCRIBE({});
      const watchUrl = desc.features?.watch?.pathname;
      
      if (!watchUrl) return;

      // Conectar ao stream SSE (observar todos theme_settings resources)
      const uri = desc.uriTemplate; // rsc://app/theme_settings/*
      eventSource = new EventSource(`${watchUrl}?uri=${encodeURIComponent(uri)}`);

      eventSource.onmessage = (event) => {
        const update = JSON.parse(event.data);
        // Invalidar queries para acionar refetch
        queryClient.invalidateQueries({ queryKey: ["themes"] });
      };

      eventSource.onerror = (error) => {
        console.error("Erro de conexão SSE:", error);
        eventSource.close();
        // Implemente lógica de reconexão se necessário
      };
    };

    setup();

    return () => {
      eventSource?.close();
    };
  }, [queryClient]);
}
```

**Como funciona:**
1. Chame `DESCRIBE` para obter endpoint SSE
2. Conecte EventSource ao watch URL com padrão URI
3. Receba eventos quando resources mudarem
4. Atualize UI invalidando cache do React Query

Mudanças se propagam instantaneamente para todos os clientes conectados.

### Exemplo Completo

Combine CRUD + sincronização em tempo real:

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useEffect } from 'react';
import { client } from './your-client';

export function useThemeSettings() {
  const queryClient = useQueryClient();

  // Buscar todos os temas
  const { data: themes, isLoading } = useQuery({
    queryKey: ["themes"],
    queryFn: async () => {
      const result = await client.DECO_RESOURCE_THEME_SETTINGS_SEARCH({
        pageSize: Infinity,
      });
      return result.items;
    },
  });

  // Criar mutation
  const createTheme = useMutation({
    mutationFn: async (data: ThemeData) => {
      return client.DECO_RESOURCE_THEME_SETTINGS_CREATE({ data });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["themes"] });
    },
  });

  // Atualizar mutation
  const updateTheme = useMutation({
    mutationFn: async ({ uri, data }: { uri: string; data: Partial<ThemeData> }) => {
      return client.DECO_RESOURCE_THEME_SETTINGS_UPDATE({ uri, data });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["themes"] });
    },
  });

  // Inscrição SSE em tempo real
  useEffect(() => {
    let eventSource: EventSource | null = null;

    const setupSSE = async () => {
      try {
        const description = await client.DECO_RESOURCE_THEME_SETTINGS_DESCRIBE({});
        const watchPathname = description.features?.watch?.pathname;
        const uriTemplate = description.uriTemplate;

        if (watchPathname) {
          const watchUrl = `${watchPathname}?uri=${encodeURIComponent(uriTemplate)}`;
          eventSource = new EventSource(watchUrl);

          eventSource.onmessage = (event) => {
            const update = JSON.parse(event.data);
            if (update.uri) {
              queryClient.invalidateQueries({ queryKey: ["themes"] });
            }
          };
        }
      } catch (error) {
        console.error("Falha ao configurar SSE:", error);
      }
    };

    setupSSE();

    return () => {
      eventSource?.close();
    };
  }, [queryClient]);

  return {
    themes,
    isLoading,
    createTheme: createTheme.mutate,
    updateTheme: updateTheme.mutate,
  };
}
```

## Melhores Práticas de Schema

Projete resources com busca em mente:

```typescript
const MyResource = DeconfigResource.define({
  resourceName: "my_resource",
  dataSchema: z.object({
    name: z.string().min(1).describe("Nome de exibição"),
    description: z.string().describe("Descrição do resource"),
    // ^ Estes campos são buscáveis por padrão
    
    // Seus campos customizados
    apiKey: z.string().describe("Chave da API"),
    environment: z.enum(["dev", "prod"]).describe("Ambiente"),
    isActive: z.boolean().default(true),
  }),
});
```

**Dicas:**
- Inclua `name` e `description` para melhor busca
- Use `.describe()` para documentação
- Defina padrões sensatos com `.default()`
- Valide formatos estritamente (cores hex, emails, URLs).

## Opções Avançadas

### Validação Customizada

Adicione validação de lógica de negócio além de verificações de schema:

```typescript
const UserSettings = DeconfigResource.define({
  resourceName: "user_settings",
  dataSchema: z.object({
    username: z.string(),
    email: z.string().email(),
  }),
  validate: async (data) => {
    const exists = await checkUsernameExists(data.username);
    if (exists) {
      throw new Error("Nome de usuário já existe");
    }
  },
});
```

### Caminho de Armazenamento Customizado

```typescript
const PrivateSettings = DeconfigResource.define({
  resourceName: "private_settings",
  dataSchema: /* ... */,
  directory: "/private/user_settings",
});
```

### Observar Resource Específico

```typescript
// Observar um resource específico em vez de todos
const uri = "rsc://meu-app/theme_settings/tema-escuro";
const watchUrl = `${watchPathname}?uri=${encodeURIComponent(uri)}`;
```

### Aprimoramentos de Descrição de Tool

Customize descrições de tools gerados:

```typescript
const MyResource = DeconfigResource.define({
  resourceName: "my_resource",
  dataSchema: /* ... */,
  enhancements: {
    DECO_RESOURCE_MY_RESOURCE_SEARCH: {
      description: "Buscar meus resources com filtros customizados",
    },
  },
});
```

### Sinalização de Dados Externos

Use resources deconfig como sinais para acionar refetches de dados externos (Airtable, Google Sheets, APIs):

**Padrão:**
1. Crie resource de sinal mínimo com timestamp `lastUpdated`
2. Atualize sinal quando dados externos mudarem
3. Frontend observa sinal via SSE, refaz fetch de dados externos em mudanças

**Exemplo:**
```typescript
// Backend: Resource de sinal
const ExternalSync = DeconfigResource.define({
  resourceName: "external_sync",
  dataSchema: z.object({
    source: z.string(),
    lastUpdated: z.string().datetime(),
  }),
});

// Backend: Atualizar sinal após mudança externa
await client.tools.DECO_RESOURCE_EXTERNAL_SYNC_UPDATE({
  uri: "rsc://app/external_sync/airtable-data",
  data: { source: "airtable", lastUpdated: new Date().toISOString() }
});

// Frontend: Observar sinal e refazer fetch
useEffect(() => {
  // Observar external_sync resource
  // Na mudança → refazer fetch do Airtable/API externa
}, []);
```

## Tratamento de Erros

Trate erros de operações de resource:

```typescript
try {
  const theme = await client.tools.DECO_RESOURCE_THEME_SETTINGS_READ({
    uri: "rsc://app/theme_settings/faltando"
  });
} catch (error) {
  if (error.message.includes("not found")) {
    // Resource não existe
  } else if (error.message.includes("validation")) {
    // Validação de schema falhou
  } else {
    // Outros erros
  }
}
```

**Erros comuns:**
- `NotFoundError`: URI de resource não existe
- `ValidationError`: Dados não correspondem ao schema
- `ConflictError`: Resource com ID já existe (no CREATE)

## Dicas de Performance

**Paginação:**
```typescript
// Ruim: Carregar tudo
pageSize: Infinity

// Bom: Paginar datasets grandes
pageSize: 20, page: currentPage
```

**Stale time do React Query:**
```typescript
useQuery({
  queryKey: ["themes"],
  queryFn: fetchThemes,
  staleTime: 5 * 60 * 1000, // Cache por 5 minutos
});
```

**Debounce de atualizações:**
```typescript
const debouncedUpdate = debounce(
  (data) => client.tools.DECO_RESOURCE_THEME_SETTINGS_UPDATE({ uri, data }),
  500
);
```

## Referência de Configuração

Todas as opções disponíveis em `DeconfigResource.define()`:

```typescript
DeconfigResource.define({
  // Obrigatório
  resourceName: string,              // Tipo de resource (snake_case)
  dataSchema: ZodSchema,             // Schema Zod para validação
  
  // Opcional
  directory?: string,                // Caminho de armazenamento customizado
  validate?: async (data) => void,  // Lógica de validação customizada
  enhancements?: {                   // Descrições de tools customizadas
    DECO_RESOURCE_NAME_OPERATION: {
      description: string,
    },
  },
})
```

**Retorna:**
- `create(env)`: Função para registrar tools de resource
- Tools CRUD gerados com interfaces tipadas
